
simpleserial-mldsa-CW308_STM32F4.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000048bc  08000188  08000188  00010188  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000004c4  08004a48  08004a48  00014a48  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08004f0c  08004f0c  00020840  2**0
                  CONTENTS
  4 .ARM          00000000  08004f0c  08004f0c  00020840  2**0
                  CONTENTS
  5 .preinit_array 00000000  08004f0c  08004f0c  00020840  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000008  08004f0c  08004f0c  00014f0c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08004f14  08004f14  00014f14  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000840  20000000  08004f18  00020000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          000010dc  20000840  08005758  00020840  2**2
                  ALLOC
 10 ._user_heap_stack 00000404  2000191c  08005758  0002191c  2**0
                  ALLOC
 11 .ARM.attributes 0000002a  00000000  00000000  00020840  2**0
                  CONTENTS, READONLY
 12 .comment      00000033  00000000  00000000  0002086a  2**0
                  CONTENTS, READONLY
 13 .debug_info   00016719  00000000  00000000  0002089d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 000045f2  00000000  00000000  00036fb6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_loc    00011ccf  00000000  00000000  0003b5a8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_aranges 000009c8  00000000  00000000  0004d278  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_ranges 00001d50  00000000  00000000  0004dc40  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   0000e53b  00000000  00000000  0004f990  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    000033ca  00000000  00000000  0005decb  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_frame  00001ad8  00000000  00000000  00061298  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .stab         0000015c  00000000  00000000  00062d70  2**2
                  CONTENTS, READONLY, DEBUGGING
 22 .stabstr      0000008f  00000000  00000000  00062ecc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000188 <deregister_tm_clones>:
 8000188:	4803      	ldr	r0, [pc, #12]	; (8000198 <deregister_tm_clones+0x10>)
 800018a:	4b04      	ldr	r3, [pc, #16]	; (800019c <deregister_tm_clones+0x14>)
 800018c:	4283      	cmp	r3, r0
 800018e:	d002      	beq.n	8000196 <deregister_tm_clones+0xe>
 8000190:	4b03      	ldr	r3, [pc, #12]	; (80001a0 <deregister_tm_clones+0x18>)
 8000192:	b103      	cbz	r3, 8000196 <deregister_tm_clones+0xe>
 8000194:	4718      	bx	r3
 8000196:	4770      	bx	lr
 8000198:	20000840 	.word	0x20000840
 800019c:	20000840 	.word	0x20000840
 80001a0:	00000000 	.word	0x00000000

080001a4 <register_tm_clones>:
 80001a4:	4805      	ldr	r0, [pc, #20]	; (80001bc <register_tm_clones+0x18>)
 80001a6:	4906      	ldr	r1, [pc, #24]	; (80001c0 <register_tm_clones+0x1c>)
 80001a8:	1a0b      	subs	r3, r1, r0
 80001aa:	0fd9      	lsrs	r1, r3, #31
 80001ac:	eb01 01a3 	add.w	r1, r1, r3, asr #2
 80001b0:	1049      	asrs	r1, r1, #1
 80001b2:	d002      	beq.n	80001ba <register_tm_clones+0x16>
 80001b4:	4b03      	ldr	r3, [pc, #12]	; (80001c4 <register_tm_clones+0x20>)
 80001b6:	b103      	cbz	r3, 80001ba <register_tm_clones+0x16>
 80001b8:	4718      	bx	r3
 80001ba:	4770      	bx	lr
 80001bc:	20000840 	.word	0x20000840
 80001c0:	20000840 	.word	0x20000840
 80001c4:	00000000 	.word	0x00000000

080001c8 <__do_global_dtors_aux>:
 80001c8:	b510      	push	{r4, lr}
 80001ca:	4c06      	ldr	r4, [pc, #24]	; (80001e4 <__do_global_dtors_aux+0x1c>)
 80001cc:	7823      	ldrb	r3, [r4, #0]
 80001ce:	b943      	cbnz	r3, 80001e2 <__do_global_dtors_aux+0x1a>
 80001d0:	f7ff ffda 	bl	8000188 <deregister_tm_clones>
 80001d4:	4b04      	ldr	r3, [pc, #16]	; (80001e8 <__do_global_dtors_aux+0x20>)
 80001d6:	b113      	cbz	r3, 80001de <__do_global_dtors_aux+0x16>
 80001d8:	4804      	ldr	r0, [pc, #16]	; (80001ec <__do_global_dtors_aux+0x24>)
 80001da:	f3af 8000 	nop.w
 80001de:	2301      	movs	r3, #1
 80001e0:	7023      	strb	r3, [r4, #0]
 80001e2:	bd10      	pop	{r4, pc}
 80001e4:	20000840 	.word	0x20000840
 80001e8:	00000000 	.word	0x00000000
 80001ec:	08004a2c 	.word	0x08004a2c

080001f0 <frame_dummy>:
 80001f0:	b508      	push	{r3, lr}
 80001f2:	4b04      	ldr	r3, [pc, #16]	; (8000204 <frame_dummy+0x14>)
 80001f4:	b11b      	cbz	r3, 80001fe <frame_dummy+0xe>
 80001f6:	4904      	ldr	r1, [pc, #16]	; (8000208 <frame_dummy+0x18>)
 80001f8:	4804      	ldr	r0, [pc, #16]	; (800020c <frame_dummy+0x1c>)
 80001fa:	f3af 8000 	nop.w
 80001fe:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8000202:	e7cf      	b.n	80001a4 <register_tm_clones>
 8000204:	00000000 	.word	0x00000000
 8000208:	20000844 	.word	0x20000844
 800020c:	08004a2c 	.word	0x08004a2c

08000210 <atexit>:
 8000210:	2300      	movs	r3, #0
 8000212:	4601      	mov	r1, r0
 8000214:	461a      	mov	r2, r3
 8000216:	4618      	mov	r0, r3
 8000218:	f000 bc4a 	b.w	8000ab0 <__register_exitproc>

0800021c <__errno>:
 800021c:	4b01      	ldr	r3, [pc, #4]	; (8000224 <__errno+0x8>)
 800021e:	6818      	ldr	r0, [r3, #0]
 8000220:	4770      	bx	lr
 8000222:	bf00      	nop
 8000224:	20000000 	.word	0x20000000

08000228 <exit>:
 8000228:	b508      	push	{r3, lr}
 800022a:	2100      	movs	r1, #0
 800022c:	4604      	mov	r4, r0
 800022e:	f000 fc73 	bl	8000b18 <__call_exitprocs>
 8000232:	4b04      	ldr	r3, [pc, #16]	; (8000244 <exit+0x1c>)
 8000234:	6818      	ldr	r0, [r3, #0]
 8000236:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 8000238:	b103      	cbz	r3, 800023c <exit+0x14>
 800023a:	4798      	blx	r3
 800023c:	4620      	mov	r0, r4
 800023e:	f000 fe37 	bl	8000eb0 <_exit>
 8000242:	bf00      	nop
 8000244:	08004f08 	.word	0x08004f08

08000248 <__libc_fini_array>:
 8000248:	b538      	push	{r3, r4, r5, lr}
 800024a:	4b08      	ldr	r3, [pc, #32]	; (800026c <__libc_fini_array+0x24>)
 800024c:	4d08      	ldr	r5, [pc, #32]	; (8000270 <__libc_fini_array+0x28>)
 800024e:	1b5b      	subs	r3, r3, r5
 8000250:	109c      	asrs	r4, r3, #2
 8000252:	d007      	beq.n	8000264 <__libc_fini_array+0x1c>
 8000254:	3b04      	subs	r3, #4
 8000256:	441d      	add	r5, r3
 8000258:	3c01      	subs	r4, #1
 800025a:	f855 3904 	ldr.w	r3, [r5], #-4
 800025e:	4798      	blx	r3
 8000260:	2c00      	cmp	r4, #0
 8000262:	d1f9      	bne.n	8000258 <__libc_fini_array+0x10>
 8000264:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8000268:	f004 bbe6 	b.w	8004a38 <_fini>
 800026c:	08004f18 	.word	0x08004f18
 8000270:	08004f14 	.word	0x08004f14

08000274 <__libc_init_array>:
 8000274:	b570      	push	{r4, r5, r6, lr}
 8000276:	4e0d      	ldr	r6, [pc, #52]	; (80002ac <__libc_init_array+0x38>)
 8000278:	4d0d      	ldr	r5, [pc, #52]	; (80002b0 <__libc_init_array+0x3c>)
 800027a:	1b76      	subs	r6, r6, r5
 800027c:	10b6      	asrs	r6, r6, #2
 800027e:	d006      	beq.n	800028e <__libc_init_array+0x1a>
 8000280:	2400      	movs	r4, #0
 8000282:	f855 3b04 	ldr.w	r3, [r5], #4
 8000286:	3401      	adds	r4, #1
 8000288:	4798      	blx	r3
 800028a:	42a6      	cmp	r6, r4
 800028c:	d1f9      	bne.n	8000282 <__libc_init_array+0xe>
 800028e:	4e09      	ldr	r6, [pc, #36]	; (80002b4 <__libc_init_array+0x40>)
 8000290:	4d09      	ldr	r5, [pc, #36]	; (80002b8 <__libc_init_array+0x44>)
 8000292:	1b76      	subs	r6, r6, r5
 8000294:	f004 fbca 	bl	8004a2c <_init>
 8000298:	10b6      	asrs	r6, r6, #2
 800029a:	d006      	beq.n	80002aa <__libc_init_array+0x36>
 800029c:	2400      	movs	r4, #0
 800029e:	f855 3b04 	ldr.w	r3, [r5], #4
 80002a2:	3401      	adds	r4, #1
 80002a4:	4798      	blx	r3
 80002a6:	42a6      	cmp	r6, r4
 80002a8:	d1f9      	bne.n	800029e <__libc_init_array+0x2a>
 80002aa:	bd70      	pop	{r4, r5, r6, pc}
 80002ac:	08004f0c 	.word	0x08004f0c
 80002b0:	08004f0c 	.word	0x08004f0c
 80002b4:	08004f14 	.word	0x08004f14
 80002b8:	08004f0c 	.word	0x08004f0c

080002bc <malloc>:
 80002bc:	4b02      	ldr	r3, [pc, #8]	; (80002c8 <malloc+0xc>)
 80002be:	4601      	mov	r1, r0
 80002c0:	6818      	ldr	r0, [r3, #0]
 80002c2:	f000 b80b 	b.w	80002dc <_malloc_r>
 80002c6:	bf00      	nop
 80002c8:	20000000 	.word	0x20000000

080002cc <free>:
 80002cc:	4b02      	ldr	r3, [pc, #8]	; (80002d8 <free+0xc>)
 80002ce:	4601      	mov	r1, r0
 80002d0:	6818      	ldr	r0, [r3, #0]
 80002d2:	f000 bcc9 	b.w	8000c68 <_free_r>
 80002d6:	bf00      	nop
 80002d8:	20000000 	.word	0x20000000

080002dc <_malloc_r>:
 80002dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80002e0:	f101 060b 	add.w	r6, r1, #11
 80002e4:	2e16      	cmp	r6, #22
 80002e6:	b083      	sub	sp, #12
 80002e8:	4604      	mov	r4, r0
 80002ea:	d824      	bhi.n	8000336 <_malloc_r+0x5a>
 80002ec:	2910      	cmp	r1, #16
 80002ee:	f200 80ba 	bhi.w	8000466 <_malloc_r+0x18a>
 80002f2:	f000 fb89 	bl	8000a08 <__malloc_lock>
 80002f6:	2610      	movs	r6, #16
 80002f8:	2218      	movs	r2, #24
 80002fa:	2002      	movs	r0, #2
 80002fc:	4fb7      	ldr	r7, [pc, #732]	; (80005dc <_malloc_r+0x300>)
 80002fe:	443a      	add	r2, r7
 8000300:	f1a2 0108 	sub.w	r1, r2, #8
 8000304:	6853      	ldr	r3, [r2, #4]
 8000306:	428b      	cmp	r3, r1
 8000308:	f000 80ba 	beq.w	8000480 <_malloc_r+0x1a4>
 800030c:	685a      	ldr	r2, [r3, #4]
 800030e:	68d9      	ldr	r1, [r3, #12]
 8000310:	f022 0203 	bic.w	r2, r2, #3
 8000314:	441a      	add	r2, r3
 8000316:	689d      	ldr	r5, [r3, #8]
 8000318:	60e9      	str	r1, [r5, #12]
 800031a:	608d      	str	r5, [r1, #8]
 800031c:	6851      	ldr	r1, [r2, #4]
 800031e:	f041 0101 	orr.w	r1, r1, #1
 8000322:	4620      	mov	r0, r4
 8000324:	6051      	str	r1, [r2, #4]
 8000326:	f103 0508 	add.w	r5, r3, #8
 800032a:	f000 fb6f 	bl	8000a0c <__malloc_unlock>
 800032e:	4628      	mov	r0, r5
 8000330:	b003      	add	sp, #12
 8000332:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000336:	f036 0607 	bics.w	r6, r6, #7
 800033a:	f100 8094 	bmi.w	8000466 <_malloc_r+0x18a>
 800033e:	42b1      	cmp	r1, r6
 8000340:	f200 8091 	bhi.w	8000466 <_malloc_r+0x18a>
 8000344:	f000 fb60 	bl	8000a08 <__malloc_lock>
 8000348:	f5b6 7ffc 	cmp.w	r6, #504	; 0x1f8
 800034c:	f0c0 8196 	bcc.w	800067c <_malloc_r+0x3a0>
 8000350:	0a73      	lsrs	r3, r6, #9
 8000352:	f000 808f 	beq.w	8000474 <_malloc_r+0x198>
 8000356:	2b04      	cmp	r3, #4
 8000358:	f200 816b 	bhi.w	8000632 <_malloc_r+0x356>
 800035c:	09b3      	lsrs	r3, r6, #6
 800035e:	f103 0039 	add.w	r0, r3, #57	; 0x39
 8000362:	f103 0c38 	add.w	ip, r3, #56	; 0x38
 8000366:	00c3      	lsls	r3, r0, #3
 8000368:	4f9c      	ldr	r7, [pc, #624]	; (80005dc <_malloc_r+0x300>)
 800036a:	443b      	add	r3, r7
 800036c:	f1a3 0508 	sub.w	r5, r3, #8
 8000370:	685b      	ldr	r3, [r3, #4]
 8000372:	429d      	cmp	r5, r3
 8000374:	d106      	bne.n	8000384 <_malloc_r+0xa8>
 8000376:	e00c      	b.n	8000392 <_malloc_r+0xb6>
 8000378:	2900      	cmp	r1, #0
 800037a:	f280 812b 	bge.w	80005d4 <_malloc_r+0x2f8>
 800037e:	68db      	ldr	r3, [r3, #12]
 8000380:	429d      	cmp	r5, r3
 8000382:	d006      	beq.n	8000392 <_malloc_r+0xb6>
 8000384:	685a      	ldr	r2, [r3, #4]
 8000386:	f022 0203 	bic.w	r2, r2, #3
 800038a:	1b91      	subs	r1, r2, r6
 800038c:	290f      	cmp	r1, #15
 800038e:	ddf3      	ble.n	8000378 <_malloc_r+0x9c>
 8000390:	4660      	mov	r0, ip
 8000392:	693d      	ldr	r5, [r7, #16]
 8000394:	f8df c248 	ldr.w	ip, [pc, #584]	; 80005e0 <_malloc_r+0x304>
 8000398:	4565      	cmp	r5, ip
 800039a:	d07c      	beq.n	8000496 <_malloc_r+0x1ba>
 800039c:	686a      	ldr	r2, [r5, #4]
 800039e:	f022 0203 	bic.w	r2, r2, #3
 80003a2:	1b93      	subs	r3, r2, r6
 80003a4:	2b0f      	cmp	r3, #15
 80003a6:	f300 8177 	bgt.w	8000698 <_malloc_r+0x3bc>
 80003aa:	2b00      	cmp	r3, #0
 80003ac:	e9c7 cc04 	strd	ip, ip, [r7, #16]
 80003b0:	f280 8168 	bge.w	8000684 <_malloc_r+0x3a8>
 80003b4:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 80003b8:	f080 8116 	bcs.w	80005e8 <_malloc_r+0x30c>
 80003bc:	08d3      	lsrs	r3, r2, #3
 80003be:	6879      	ldr	r1, [r7, #4]
 80003c0:	3301      	adds	r3, #1
 80003c2:	ea4f 1e52 	mov.w	lr, r2, lsr #5
 80003c6:	2201      	movs	r2, #1
 80003c8:	fa02 f20e 	lsl.w	r2, r2, lr
 80003cc:	430a      	orrs	r2, r1
 80003ce:	f857 e033 	ldr.w	lr, [r7, r3, lsl #3]
 80003d2:	f8c5 e008 	str.w	lr, [r5, #8]
 80003d6:	eb07 01c3 	add.w	r1, r7, r3, lsl #3
 80003da:	3908      	subs	r1, #8
 80003dc:	60e9      	str	r1, [r5, #12]
 80003de:	607a      	str	r2, [r7, #4]
 80003e0:	f847 5033 	str.w	r5, [r7, r3, lsl #3]
 80003e4:	f8ce 500c 	str.w	r5, [lr, #12]
 80003e8:	1083      	asrs	r3, r0, #2
 80003ea:	2101      	movs	r1, #1
 80003ec:	4099      	lsls	r1, r3
 80003ee:	4291      	cmp	r1, r2
 80003f0:	d857      	bhi.n	80004a2 <_malloc_r+0x1c6>
 80003f2:	4211      	tst	r1, r2
 80003f4:	d106      	bne.n	8000404 <_malloc_r+0x128>
 80003f6:	f020 0003 	bic.w	r0, r0, #3
 80003fa:	0049      	lsls	r1, r1, #1
 80003fc:	4211      	tst	r1, r2
 80003fe:	f100 0004 	add.w	r0, r0, #4
 8000402:	d0fa      	beq.n	80003fa <_malloc_r+0x11e>
 8000404:	eb07 09c0 	add.w	r9, r7, r0, lsl #3
 8000408:	464d      	mov	r5, r9
 800040a:	4686      	mov	lr, r0
 800040c:	f8d5 800c 	ldr.w	r8, [r5, #12]
 8000410:	4545      	cmp	r5, r8
 8000412:	d108      	bne.n	8000426 <_malloc_r+0x14a>
 8000414:	e119      	b.n	800064a <_malloc_r+0x36e>
 8000416:	2b00      	cmp	r3, #0
 8000418:	f280 8120 	bge.w	800065c <_malloc_r+0x380>
 800041c:	f8d8 800c 	ldr.w	r8, [r8, #12]
 8000420:	4545      	cmp	r5, r8
 8000422:	f000 8112 	beq.w	800064a <_malloc_r+0x36e>
 8000426:	f8d8 2004 	ldr.w	r2, [r8, #4]
 800042a:	f022 0203 	bic.w	r2, r2, #3
 800042e:	1b93      	subs	r3, r2, r6
 8000430:	2b0f      	cmp	r3, #15
 8000432:	ddf0      	ble.n	8000416 <_malloc_r+0x13a>
 8000434:	4620      	mov	r0, r4
 8000436:	e9d8 5402 	ldrd	r5, r4, [r8, #8]
 800043a:	eb08 0106 	add.w	r1, r8, r6
 800043e:	f046 0601 	orr.w	r6, r6, #1
 8000442:	f8c8 6004 	str.w	r6, [r8, #4]
 8000446:	60ec      	str	r4, [r5, #12]
 8000448:	60a5      	str	r5, [r4, #8]
 800044a:	f043 0401 	orr.w	r4, r3, #1
 800044e:	e9c7 1104 	strd	r1, r1, [r7, #16]
 8000452:	e9c1 cc02 	strd	ip, ip, [r1, #8]
 8000456:	604c      	str	r4, [r1, #4]
 8000458:	f848 3002 	str.w	r3, [r8, r2]
 800045c:	f000 fad6 	bl	8000a0c <__malloc_unlock>
 8000460:	f108 0508 	add.w	r5, r8, #8
 8000464:	e002      	b.n	800046c <_malloc_r+0x190>
 8000466:	230c      	movs	r3, #12
 8000468:	6023      	str	r3, [r4, #0]
 800046a:	2500      	movs	r5, #0
 800046c:	4628      	mov	r0, r5
 800046e:	b003      	add	sp, #12
 8000470:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000474:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000478:	2040      	movs	r0, #64	; 0x40
 800047a:	f04f 0c3f 	mov.w	ip, #63	; 0x3f
 800047e:	e773      	b.n	8000368 <_malloc_r+0x8c>
 8000480:	68d3      	ldr	r3, [r2, #12]
 8000482:	429a      	cmp	r2, r3
 8000484:	bf08      	it	eq
 8000486:	3002      	addeq	r0, #2
 8000488:	f47f af40 	bne.w	800030c <_malloc_r+0x30>
 800048c:	693d      	ldr	r5, [r7, #16]
 800048e:	f8df c150 	ldr.w	ip, [pc, #336]	; 80005e0 <_malloc_r+0x304>
 8000492:	4565      	cmp	r5, ip
 8000494:	d182      	bne.n	800039c <_malloc_r+0xc0>
 8000496:	687a      	ldr	r2, [r7, #4]
 8000498:	1083      	asrs	r3, r0, #2
 800049a:	2101      	movs	r1, #1
 800049c:	4099      	lsls	r1, r3
 800049e:	4291      	cmp	r1, r2
 80004a0:	d9a7      	bls.n	80003f2 <_malloc_r+0x116>
 80004a2:	68bd      	ldr	r5, [r7, #8]
 80004a4:	686b      	ldr	r3, [r5, #4]
 80004a6:	f023 0803 	bic.w	r8, r3, #3
 80004aa:	4546      	cmp	r6, r8
 80004ac:	d803      	bhi.n	80004b6 <_malloc_r+0x1da>
 80004ae:	eba8 0306 	sub.w	r3, r8, r6
 80004b2:	2b0f      	cmp	r3, #15
 80004b4:	dc7e      	bgt.n	80005b4 <_malloc_r+0x2d8>
 80004b6:	f8df 912c 	ldr.w	r9, [pc, #300]	; 80005e4 <_malloc_r+0x308>
 80004ba:	f8d7 2408 	ldr.w	r2, [r7, #1032]	; 0x408
 80004be:	f8d9 3000 	ldr.w	r3, [r9]
 80004c2:	3201      	adds	r2, #1
 80004c4:	4433      	add	r3, r6
 80004c6:	eb05 0a08 	add.w	sl, r5, r8
 80004ca:	f000 812f 	beq.w	800072c <_malloc_r+0x450>
 80004ce:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80004d2:	330f      	adds	r3, #15
 80004d4:	f423 6b7f 	bic.w	fp, r3, #4080	; 0xff0
 80004d8:	f02b 0b0f 	bic.w	fp, fp, #15
 80004dc:	4659      	mov	r1, fp
 80004de:	4620      	mov	r0, r4
 80004e0:	f000 faba 	bl	8000a58 <_sbrk_r>
 80004e4:	1c41      	adds	r1, r0, #1
 80004e6:	4602      	mov	r2, r0
 80004e8:	f000 80ef 	beq.w	80006ca <_malloc_r+0x3ee>
 80004ec:	4582      	cmp	sl, r0
 80004ee:	f200 80ea 	bhi.w	80006c6 <_malloc_r+0x3ea>
 80004f2:	f8d9 1004 	ldr.w	r1, [r9, #4]
 80004f6:	4459      	add	r1, fp
 80004f8:	f8c9 1004 	str.w	r1, [r9, #4]
 80004fc:	460b      	mov	r3, r1
 80004fe:	f000 814b 	beq.w	8000798 <_malloc_r+0x4bc>
 8000502:	f8d7 1408 	ldr.w	r1, [r7, #1032]	; 0x408
 8000506:	3101      	adds	r1, #1
 8000508:	bf1b      	ittet	ne
 800050a:	eba2 0a0a 	subne.w	sl, r2, sl
 800050e:	4453      	addne	r3, sl
 8000510:	f8c7 2408 	streq.w	r2, [r7, #1032]	; 0x408
 8000514:	f8c9 3004 	strne.w	r3, [r9, #4]
 8000518:	f012 0307 	ands.w	r3, r2, #7
 800051c:	f000 8112 	beq.w	8000744 <_malloc_r+0x468>
 8000520:	f1c3 0108 	rsb	r1, r3, #8
 8000524:	440a      	add	r2, r1
 8000526:	f5c3 5180 	rsb	r1, r3, #4096	; 0x1000
 800052a:	4493      	add	fp, r2
 800052c:	3108      	adds	r1, #8
 800052e:	eba1 010b 	sub.w	r1, r1, fp
 8000532:	f3c1 0a0b 	ubfx	sl, r1, #0, #12
 8000536:	4651      	mov	r1, sl
 8000538:	4620      	mov	r0, r4
 800053a:	9201      	str	r2, [sp, #4]
 800053c:	9300      	str	r3, [sp, #0]
 800053e:	f000 fa8b 	bl	8000a58 <_sbrk_r>
 8000542:	1c42      	adds	r2, r0, #1
 8000544:	e9dd 3200 	ldrd	r3, r2, [sp]
 8000548:	f000 814b 	beq.w	80007e2 <_malloc_r+0x506>
 800054c:	1a83      	subs	r3, r0, r2
 800054e:	eb03 0b0a 	add.w	fp, r3, sl
 8000552:	f8d9 0004 	ldr.w	r0, [r9, #4]
 8000556:	60ba      	str	r2, [r7, #8]
 8000558:	f04b 0301 	orr.w	r3, fp, #1
 800055c:	eb0a 0100 	add.w	r1, sl, r0
 8000560:	42bd      	cmp	r5, r7
 8000562:	6053      	str	r3, [r2, #4]
 8000564:	f8c9 1004 	str.w	r1, [r9, #4]
 8000568:	f000 8122 	beq.w	80007b0 <_malloc_r+0x4d4>
 800056c:	f1b8 0f0f 	cmp.w	r8, #15
 8000570:	f240 8120 	bls.w	80007b4 <_malloc_r+0x4d8>
 8000574:	686b      	ldr	r3, [r5, #4]
 8000576:	f1a8 000c 	sub.w	r0, r8, #12
 800057a:	f020 0007 	bic.w	r0, r0, #7
 800057e:	f003 0301 	and.w	r3, r3, #1
 8000582:	4303      	orrs	r3, r0
 8000584:	606b      	str	r3, [r5, #4]
 8000586:	f04f 0c05 	mov.w	ip, #5
 800058a:	182b      	adds	r3, r5, r0
 800058c:	280f      	cmp	r0, #15
 800058e:	e9c3 cc01 	strd	ip, ip, [r3, #4]
 8000592:	f200 812d 	bhi.w	80007f0 <_malloc_r+0x514>
 8000596:	6853      	ldr	r3, [r2, #4]
 8000598:	4615      	mov	r5, r2
 800059a:	f8d9 202c 	ldr.w	r2, [r9, #44]	; 0x2c
 800059e:	428a      	cmp	r2, r1
 80005a0:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
 80005a4:	bf38      	it	cc
 80005a6:	f8c9 102c 	strcc.w	r1, [r9, #44]	; 0x2c
 80005aa:	428a      	cmp	r2, r1
 80005ac:	bf38      	it	cc
 80005ae:	f8c9 1030 	strcc.w	r1, [r9, #48]	; 0x30
 80005b2:	e08c      	b.n	80006ce <_malloc_r+0x3f2>
 80005b4:	19aa      	adds	r2, r5, r6
 80005b6:	f043 0301 	orr.w	r3, r3, #1
 80005ba:	f046 0601 	orr.w	r6, r6, #1
 80005be:	606e      	str	r6, [r5, #4]
 80005c0:	4620      	mov	r0, r4
 80005c2:	60ba      	str	r2, [r7, #8]
 80005c4:	6053      	str	r3, [r2, #4]
 80005c6:	f000 fa21 	bl	8000a0c <__malloc_unlock>
 80005ca:	3508      	adds	r5, #8
 80005cc:	4628      	mov	r0, r5
 80005ce:	b003      	add	sp, #12
 80005d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80005d4:	68d9      	ldr	r1, [r3, #12]
 80005d6:	441a      	add	r2, r3
 80005d8:	e69d      	b.n	8000316 <_malloc_r+0x3a>
 80005da:	bf00      	nop
 80005dc:	20000430 	.word	0x20000430
 80005e0:	20000438 	.word	0x20000438
 80005e4:	200018e4 	.word	0x200018e4
 80005e8:	f5b2 6f20 	cmp.w	r2, #2560	; 0xa00
 80005ec:	ea4f 2352 	mov.w	r3, r2, lsr #9
 80005f0:	d363      	bcc.n	80006ba <_malloc_r+0x3de>
 80005f2:	2b14      	cmp	r3, #20
 80005f4:	f200 80b8 	bhi.w	8000768 <_malloc_r+0x48c>
 80005f8:	f103 015c 	add.w	r1, r3, #92	; 0x5c
 80005fc:	00c9      	lsls	r1, r1, #3
 80005fe:	335b      	adds	r3, #91	; 0x5b
 8000600:	eb07 0e01 	add.w	lr, r7, r1
 8000604:	5879      	ldr	r1, [r7, r1]
 8000606:	f1ae 0e08 	sub.w	lr, lr, #8
 800060a:	458e      	cmp	lr, r1
 800060c:	f000 8091 	beq.w	8000732 <_malloc_r+0x456>
 8000610:	684b      	ldr	r3, [r1, #4]
 8000612:	f023 0303 	bic.w	r3, r3, #3
 8000616:	4293      	cmp	r3, r2
 8000618:	d902      	bls.n	8000620 <_malloc_r+0x344>
 800061a:	6889      	ldr	r1, [r1, #8]
 800061c:	458e      	cmp	lr, r1
 800061e:	d1f7      	bne.n	8000610 <_malloc_r+0x334>
 8000620:	f8d1 e00c 	ldr.w	lr, [r1, #12]
 8000624:	687a      	ldr	r2, [r7, #4]
 8000626:	e9c5 1e02 	strd	r1, lr, [r5, #8]
 800062a:	f8ce 5008 	str.w	r5, [lr, #8]
 800062e:	60cd      	str	r5, [r1, #12]
 8000630:	e6da      	b.n	80003e8 <_malloc_r+0x10c>
 8000632:	2b14      	cmp	r3, #20
 8000634:	d959      	bls.n	80006ea <_malloc_r+0x40e>
 8000636:	2b54      	cmp	r3, #84	; 0x54
 8000638:	f200 809e 	bhi.w	8000778 <_malloc_r+0x49c>
 800063c:	0b33      	lsrs	r3, r6, #12
 800063e:	f103 006f 	add.w	r0, r3, #111	; 0x6f
 8000642:	f103 0c6e 	add.w	ip, r3, #110	; 0x6e
 8000646:	00c3      	lsls	r3, r0, #3
 8000648:	e68e      	b.n	8000368 <_malloc_r+0x8c>
 800064a:	f10e 0e01 	add.w	lr, lr, #1
 800064e:	f01e 0f03 	tst.w	lr, #3
 8000652:	f105 0508 	add.w	r5, r5, #8
 8000656:	f47f aed9 	bne.w	800040c <_malloc_r+0x130>
 800065a:	e051      	b.n	8000700 <_malloc_r+0x424>
 800065c:	4442      	add	r2, r8
 800065e:	4645      	mov	r5, r8
 8000660:	6853      	ldr	r3, [r2, #4]
 8000662:	f8d8 100c 	ldr.w	r1, [r8, #12]
 8000666:	f043 0301 	orr.w	r3, r3, #1
 800066a:	6053      	str	r3, [r2, #4]
 800066c:	f855 3f08 	ldr.w	r3, [r5, #8]!
 8000670:	4620      	mov	r0, r4
 8000672:	60d9      	str	r1, [r3, #12]
 8000674:	608b      	str	r3, [r1, #8]
 8000676:	f000 f9c9 	bl	8000a0c <__malloc_unlock>
 800067a:	e6f7      	b.n	800046c <_malloc_r+0x190>
 800067c:	08f0      	lsrs	r0, r6, #3
 800067e:	f106 0208 	add.w	r2, r6, #8
 8000682:	e63b      	b.n	80002fc <_malloc_r+0x20>
 8000684:	442a      	add	r2, r5
 8000686:	4620      	mov	r0, r4
 8000688:	6853      	ldr	r3, [r2, #4]
 800068a:	f043 0301 	orr.w	r3, r3, #1
 800068e:	6053      	str	r3, [r2, #4]
 8000690:	3508      	adds	r5, #8
 8000692:	f000 f9bb 	bl	8000a0c <__malloc_unlock>
 8000696:	e6e9      	b.n	800046c <_malloc_r+0x190>
 8000698:	19a9      	adds	r1, r5, r6
 800069a:	4620      	mov	r0, r4
 800069c:	f046 0601 	orr.w	r6, r6, #1
 80006a0:	f043 0401 	orr.w	r4, r3, #1
 80006a4:	606e      	str	r6, [r5, #4]
 80006a6:	e9c7 1104 	strd	r1, r1, [r7, #16]
 80006aa:	e9c1 cc02 	strd	ip, ip, [r1, #8]
 80006ae:	604c      	str	r4, [r1, #4]
 80006b0:	50ab      	str	r3, [r5, r2]
 80006b2:	f000 f9ab 	bl	8000a0c <__malloc_unlock>
 80006b6:	3508      	adds	r5, #8
 80006b8:	e6d8      	b.n	800046c <_malloc_r+0x190>
 80006ba:	0993      	lsrs	r3, r2, #6
 80006bc:	f103 0139 	add.w	r1, r3, #57	; 0x39
 80006c0:	00c9      	lsls	r1, r1, #3
 80006c2:	3338      	adds	r3, #56	; 0x38
 80006c4:	e79c      	b.n	8000600 <_malloc_r+0x324>
 80006c6:	42bd      	cmp	r5, r7
 80006c8:	d060      	beq.n	800078c <_malloc_r+0x4b0>
 80006ca:	68bd      	ldr	r5, [r7, #8]
 80006cc:	686b      	ldr	r3, [r5, #4]
 80006ce:	f023 0b03 	bic.w	fp, r3, #3
 80006d2:	455e      	cmp	r6, fp
 80006d4:	ebab 0306 	sub.w	r3, fp, r6
 80006d8:	d802      	bhi.n	80006e0 <_malloc_r+0x404>
 80006da:	2b0f      	cmp	r3, #15
 80006dc:	f73f af6a 	bgt.w	80005b4 <_malloc_r+0x2d8>
 80006e0:	4620      	mov	r0, r4
 80006e2:	f000 f993 	bl	8000a0c <__malloc_unlock>
 80006e6:	2500      	movs	r5, #0
 80006e8:	e6c0      	b.n	800046c <_malloc_r+0x190>
 80006ea:	f103 005c 	add.w	r0, r3, #92	; 0x5c
 80006ee:	f103 0c5b 	add.w	ip, r3, #91	; 0x5b
 80006f2:	00c3      	lsls	r3, r0, #3
 80006f4:	e638      	b.n	8000368 <_malloc_r+0x8c>
 80006f6:	f859 3908 	ldr.w	r3, [r9], #-8
 80006fa:	454b      	cmp	r3, r9
 80006fc:	f040 8096 	bne.w	800082c <_malloc_r+0x550>
 8000700:	f010 0f03 	tst.w	r0, #3
 8000704:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
 8000708:	d1f5      	bne.n	80006f6 <_malloc_r+0x41a>
 800070a:	687b      	ldr	r3, [r7, #4]
 800070c:	ea23 0301 	bic.w	r3, r3, r1
 8000710:	607b      	str	r3, [r7, #4]
 8000712:	0049      	lsls	r1, r1, #1
 8000714:	4299      	cmp	r1, r3
 8000716:	f63f aec4 	bhi.w	80004a2 <_malloc_r+0x1c6>
 800071a:	b919      	cbnz	r1, 8000724 <_malloc_r+0x448>
 800071c:	e6c1      	b.n	80004a2 <_malloc_r+0x1c6>
 800071e:	0049      	lsls	r1, r1, #1
 8000720:	f10e 0e04 	add.w	lr, lr, #4
 8000724:	4219      	tst	r1, r3
 8000726:	d0fa      	beq.n	800071e <_malloc_r+0x442>
 8000728:	4670      	mov	r0, lr
 800072a:	e66b      	b.n	8000404 <_malloc_r+0x128>
 800072c:	f103 0b10 	add.w	fp, r3, #16
 8000730:	e6d4      	b.n	80004dc <_malloc_r+0x200>
 8000732:	109a      	asrs	r2, r3, #2
 8000734:	f04f 0801 	mov.w	r8, #1
 8000738:	687b      	ldr	r3, [r7, #4]
 800073a:	fa08 f202 	lsl.w	r2, r8, r2
 800073e:	431a      	orrs	r2, r3
 8000740:	607a      	str	r2, [r7, #4]
 8000742:	e770      	b.n	8000626 <_malloc_r+0x34a>
 8000744:	eb02 010b 	add.w	r1, r2, fp
 8000748:	4249      	negs	r1, r1
 800074a:	f3c1 0a0b 	ubfx	sl, r1, #0, #12
 800074e:	4651      	mov	r1, sl
 8000750:	4620      	mov	r0, r4
 8000752:	9301      	str	r3, [sp, #4]
 8000754:	9200      	str	r2, [sp, #0]
 8000756:	f000 f97f 	bl	8000a58 <_sbrk_r>
 800075a:	1c43      	adds	r3, r0, #1
 800075c:	e9dd 2300 	ldrd	r2, r3, [sp]
 8000760:	f47f aef4 	bne.w	800054c <_malloc_r+0x270>
 8000764:	469a      	mov	sl, r3
 8000766:	e6f4      	b.n	8000552 <_malloc_r+0x276>
 8000768:	2b54      	cmp	r3, #84	; 0x54
 800076a:	d826      	bhi.n	80007ba <_malloc_r+0x4de>
 800076c:	0b13      	lsrs	r3, r2, #12
 800076e:	f103 016f 	add.w	r1, r3, #111	; 0x6f
 8000772:	00c9      	lsls	r1, r1, #3
 8000774:	336e      	adds	r3, #110	; 0x6e
 8000776:	e743      	b.n	8000600 <_malloc_r+0x324>
 8000778:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
 800077c:	d826      	bhi.n	80007cc <_malloc_r+0x4f0>
 800077e:	0bf3      	lsrs	r3, r6, #15
 8000780:	f103 0078 	add.w	r0, r3, #120	; 0x78
 8000784:	f103 0c77 	add.w	ip, r3, #119	; 0x77
 8000788:	00c3      	lsls	r3, r0, #3
 800078a:	e5ed      	b.n	8000368 <_malloc_r+0x8c>
 800078c:	f8d9 3004 	ldr.w	r3, [r9, #4]
 8000790:	445b      	add	r3, fp
 8000792:	f8c9 3004 	str.w	r3, [r9, #4]
 8000796:	e6b4      	b.n	8000502 <_malloc_r+0x226>
 8000798:	f3ca 000b 	ubfx	r0, sl, #0, #12
 800079c:	2800      	cmp	r0, #0
 800079e:	f47f aeb0 	bne.w	8000502 <_malloc_r+0x226>
 80007a2:	68bd      	ldr	r5, [r7, #8]
 80007a4:	eb08 030b 	add.w	r3, r8, fp
 80007a8:	f043 0301 	orr.w	r3, r3, #1
 80007ac:	606b      	str	r3, [r5, #4]
 80007ae:	e6f4      	b.n	800059a <_malloc_r+0x2be>
 80007b0:	4615      	mov	r5, r2
 80007b2:	e6f2      	b.n	800059a <_malloc_r+0x2be>
 80007b4:	2301      	movs	r3, #1
 80007b6:	6053      	str	r3, [r2, #4]
 80007b8:	e792      	b.n	80006e0 <_malloc_r+0x404>
 80007ba:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
 80007be:	d821      	bhi.n	8000804 <_malloc_r+0x528>
 80007c0:	0bd3      	lsrs	r3, r2, #15
 80007c2:	f103 0178 	add.w	r1, r3, #120	; 0x78
 80007c6:	00c9      	lsls	r1, r1, #3
 80007c8:	3377      	adds	r3, #119	; 0x77
 80007ca:	e719      	b.n	8000600 <_malloc_r+0x324>
 80007cc:	f240 5254 	movw	r2, #1364	; 0x554
 80007d0:	4293      	cmp	r3, r2
 80007d2:	d821      	bhi.n	8000818 <_malloc_r+0x53c>
 80007d4:	0cb3      	lsrs	r3, r6, #18
 80007d6:	f103 007d 	add.w	r0, r3, #125	; 0x7d
 80007da:	f103 0c7c 	add.w	ip, r3, #124	; 0x7c
 80007de:	00c3      	lsls	r3, r0, #3
 80007e0:	e5c2      	b.n	8000368 <_malloc_r+0x8c>
 80007e2:	3b08      	subs	r3, #8
 80007e4:	449b      	add	fp, r3
 80007e6:	ebab 0b02 	sub.w	fp, fp, r2
 80007ea:	f04f 0a00 	mov.w	sl, #0
 80007ee:	e6b0      	b.n	8000552 <_malloc_r+0x276>
 80007f0:	f105 0108 	add.w	r1, r5, #8
 80007f4:	4620      	mov	r0, r4
 80007f6:	f000 fa37 	bl	8000c68 <_free_r>
 80007fa:	68bd      	ldr	r5, [r7, #8]
 80007fc:	f8d9 1004 	ldr.w	r1, [r9, #4]
 8000800:	686b      	ldr	r3, [r5, #4]
 8000802:	e6ca      	b.n	800059a <_malloc_r+0x2be>
 8000804:	f240 5154 	movw	r1, #1364	; 0x554
 8000808:	428b      	cmp	r3, r1
 800080a:	d80b      	bhi.n	8000824 <_malloc_r+0x548>
 800080c:	0c93      	lsrs	r3, r2, #18
 800080e:	f103 017d 	add.w	r1, r3, #125	; 0x7d
 8000812:	00c9      	lsls	r1, r1, #3
 8000814:	337c      	adds	r3, #124	; 0x7c
 8000816:	e6f3      	b.n	8000600 <_malloc_r+0x324>
 8000818:	f44f 737e 	mov.w	r3, #1016	; 0x3f8
 800081c:	207f      	movs	r0, #127	; 0x7f
 800081e:	f04f 0c7e 	mov.w	ip, #126	; 0x7e
 8000822:	e5a1      	b.n	8000368 <_malloc_r+0x8c>
 8000824:	f44f 717e 	mov.w	r1, #1016	; 0x3f8
 8000828:	237e      	movs	r3, #126	; 0x7e
 800082a:	e6e9      	b.n	8000600 <_malloc_r+0x324>
 800082c:	687b      	ldr	r3, [r7, #4]
 800082e:	e770      	b.n	8000712 <_malloc_r+0x436>

08000830 <memcpy>:
 8000830:	4684      	mov	ip, r0
 8000832:	ea41 0300 	orr.w	r3, r1, r0
 8000836:	f013 0303 	ands.w	r3, r3, #3
 800083a:	d16d      	bne.n	8000918 <memcpy+0xe8>
 800083c:	3a40      	subs	r2, #64	; 0x40
 800083e:	d341      	bcc.n	80008c4 <memcpy+0x94>
 8000840:	f851 3b04 	ldr.w	r3, [r1], #4
 8000844:	f840 3b04 	str.w	r3, [r0], #4
 8000848:	f851 3b04 	ldr.w	r3, [r1], #4
 800084c:	f840 3b04 	str.w	r3, [r0], #4
 8000850:	f851 3b04 	ldr.w	r3, [r1], #4
 8000854:	f840 3b04 	str.w	r3, [r0], #4
 8000858:	f851 3b04 	ldr.w	r3, [r1], #4
 800085c:	f840 3b04 	str.w	r3, [r0], #4
 8000860:	f851 3b04 	ldr.w	r3, [r1], #4
 8000864:	f840 3b04 	str.w	r3, [r0], #4
 8000868:	f851 3b04 	ldr.w	r3, [r1], #4
 800086c:	f840 3b04 	str.w	r3, [r0], #4
 8000870:	f851 3b04 	ldr.w	r3, [r1], #4
 8000874:	f840 3b04 	str.w	r3, [r0], #4
 8000878:	f851 3b04 	ldr.w	r3, [r1], #4
 800087c:	f840 3b04 	str.w	r3, [r0], #4
 8000880:	f851 3b04 	ldr.w	r3, [r1], #4
 8000884:	f840 3b04 	str.w	r3, [r0], #4
 8000888:	f851 3b04 	ldr.w	r3, [r1], #4
 800088c:	f840 3b04 	str.w	r3, [r0], #4
 8000890:	f851 3b04 	ldr.w	r3, [r1], #4
 8000894:	f840 3b04 	str.w	r3, [r0], #4
 8000898:	f851 3b04 	ldr.w	r3, [r1], #4
 800089c:	f840 3b04 	str.w	r3, [r0], #4
 80008a0:	f851 3b04 	ldr.w	r3, [r1], #4
 80008a4:	f840 3b04 	str.w	r3, [r0], #4
 80008a8:	f851 3b04 	ldr.w	r3, [r1], #4
 80008ac:	f840 3b04 	str.w	r3, [r0], #4
 80008b0:	f851 3b04 	ldr.w	r3, [r1], #4
 80008b4:	f840 3b04 	str.w	r3, [r0], #4
 80008b8:	f851 3b04 	ldr.w	r3, [r1], #4
 80008bc:	f840 3b04 	str.w	r3, [r0], #4
 80008c0:	3a40      	subs	r2, #64	; 0x40
 80008c2:	d2bd      	bcs.n	8000840 <memcpy+0x10>
 80008c4:	3230      	adds	r2, #48	; 0x30
 80008c6:	d311      	bcc.n	80008ec <memcpy+0xbc>
 80008c8:	f851 3b04 	ldr.w	r3, [r1], #4
 80008cc:	f840 3b04 	str.w	r3, [r0], #4
 80008d0:	f851 3b04 	ldr.w	r3, [r1], #4
 80008d4:	f840 3b04 	str.w	r3, [r0], #4
 80008d8:	f851 3b04 	ldr.w	r3, [r1], #4
 80008dc:	f840 3b04 	str.w	r3, [r0], #4
 80008e0:	f851 3b04 	ldr.w	r3, [r1], #4
 80008e4:	f840 3b04 	str.w	r3, [r0], #4
 80008e8:	3a10      	subs	r2, #16
 80008ea:	d2ed      	bcs.n	80008c8 <memcpy+0x98>
 80008ec:	320c      	adds	r2, #12
 80008ee:	d305      	bcc.n	80008fc <memcpy+0xcc>
 80008f0:	f851 3b04 	ldr.w	r3, [r1], #4
 80008f4:	f840 3b04 	str.w	r3, [r0], #4
 80008f8:	3a04      	subs	r2, #4
 80008fa:	d2f9      	bcs.n	80008f0 <memcpy+0xc0>
 80008fc:	3204      	adds	r2, #4
 80008fe:	d008      	beq.n	8000912 <memcpy+0xe2>
 8000900:	07d2      	lsls	r2, r2, #31
 8000902:	bf1c      	itt	ne
 8000904:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000908:	f800 3b01 	strbne.w	r3, [r0], #1
 800090c:	d301      	bcc.n	8000912 <memcpy+0xe2>
 800090e:	880b      	ldrh	r3, [r1, #0]
 8000910:	8003      	strh	r3, [r0, #0]
 8000912:	4660      	mov	r0, ip
 8000914:	4770      	bx	lr
 8000916:	bf00      	nop
 8000918:	2a08      	cmp	r2, #8
 800091a:	d313      	bcc.n	8000944 <memcpy+0x114>
 800091c:	078b      	lsls	r3, r1, #30
 800091e:	d08d      	beq.n	800083c <memcpy+0xc>
 8000920:	f010 0303 	ands.w	r3, r0, #3
 8000924:	d08a      	beq.n	800083c <memcpy+0xc>
 8000926:	f1c3 0304 	rsb	r3, r3, #4
 800092a:	1ad2      	subs	r2, r2, r3
 800092c:	07db      	lsls	r3, r3, #31
 800092e:	bf1c      	itt	ne
 8000930:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000934:	f800 3b01 	strbne.w	r3, [r0], #1
 8000938:	d380      	bcc.n	800083c <memcpy+0xc>
 800093a:	f831 3b02 	ldrh.w	r3, [r1], #2
 800093e:	f820 3b02 	strh.w	r3, [r0], #2
 8000942:	e77b      	b.n	800083c <memcpy+0xc>
 8000944:	3a04      	subs	r2, #4
 8000946:	d3d9      	bcc.n	80008fc <memcpy+0xcc>
 8000948:	3a01      	subs	r2, #1
 800094a:	f811 3b01 	ldrb.w	r3, [r1], #1
 800094e:	f800 3b01 	strb.w	r3, [r0], #1
 8000952:	d2f9      	bcs.n	8000948 <memcpy+0x118>
 8000954:	780b      	ldrb	r3, [r1, #0]
 8000956:	7003      	strb	r3, [r0, #0]
 8000958:	784b      	ldrb	r3, [r1, #1]
 800095a:	7043      	strb	r3, [r0, #1]
 800095c:	788b      	ldrb	r3, [r1, #2]
 800095e:	7083      	strb	r3, [r0, #2]
 8000960:	4660      	mov	r0, ip
 8000962:	4770      	bx	lr

08000964 <memset>:
 8000964:	0783      	lsls	r3, r0, #30
 8000966:	b530      	push	{r4, r5, lr}
 8000968:	d048      	beq.n	80009fc <memset+0x98>
 800096a:	1e54      	subs	r4, r2, #1
 800096c:	2a00      	cmp	r2, #0
 800096e:	d03f      	beq.n	80009f0 <memset+0x8c>
 8000970:	b2ca      	uxtb	r2, r1
 8000972:	4603      	mov	r3, r0
 8000974:	e001      	b.n	800097a <memset+0x16>
 8000976:	3c01      	subs	r4, #1
 8000978:	d33a      	bcc.n	80009f0 <memset+0x8c>
 800097a:	f803 2b01 	strb.w	r2, [r3], #1
 800097e:	079d      	lsls	r5, r3, #30
 8000980:	d1f9      	bne.n	8000976 <memset+0x12>
 8000982:	2c03      	cmp	r4, #3
 8000984:	d92d      	bls.n	80009e2 <memset+0x7e>
 8000986:	b2cd      	uxtb	r5, r1
 8000988:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 800098c:	2c0f      	cmp	r4, #15
 800098e:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 8000992:	d936      	bls.n	8000a02 <memset+0x9e>
 8000994:	f1a4 0210 	sub.w	r2, r4, #16
 8000998:	f022 0c0f 	bic.w	ip, r2, #15
 800099c:	f103 0e20 	add.w	lr, r3, #32
 80009a0:	44e6      	add	lr, ip
 80009a2:	ea4f 1c12 	mov.w	ip, r2, lsr #4
 80009a6:	f103 0210 	add.w	r2, r3, #16
 80009aa:	e942 5504 	strd	r5, r5, [r2, #-16]
 80009ae:	e942 5502 	strd	r5, r5, [r2, #-8]
 80009b2:	3210      	adds	r2, #16
 80009b4:	4572      	cmp	r2, lr
 80009b6:	d1f8      	bne.n	80009aa <memset+0x46>
 80009b8:	f10c 0201 	add.w	r2, ip, #1
 80009bc:	f014 0f0c 	tst.w	r4, #12
 80009c0:	eb03 1202 	add.w	r2, r3, r2, lsl #4
 80009c4:	f004 0c0f 	and.w	ip, r4, #15
 80009c8:	d013      	beq.n	80009f2 <memset+0x8e>
 80009ca:	f1ac 0304 	sub.w	r3, ip, #4
 80009ce:	f023 0303 	bic.w	r3, r3, #3
 80009d2:	3304      	adds	r3, #4
 80009d4:	4413      	add	r3, r2
 80009d6:	f842 5b04 	str.w	r5, [r2], #4
 80009da:	4293      	cmp	r3, r2
 80009dc:	d1fb      	bne.n	80009d6 <memset+0x72>
 80009de:	f00c 0403 	and.w	r4, ip, #3
 80009e2:	b12c      	cbz	r4, 80009f0 <memset+0x8c>
 80009e4:	b2ca      	uxtb	r2, r1
 80009e6:	441c      	add	r4, r3
 80009e8:	f803 2b01 	strb.w	r2, [r3], #1
 80009ec:	429c      	cmp	r4, r3
 80009ee:	d1fb      	bne.n	80009e8 <memset+0x84>
 80009f0:	bd30      	pop	{r4, r5, pc}
 80009f2:	4664      	mov	r4, ip
 80009f4:	4613      	mov	r3, r2
 80009f6:	2c00      	cmp	r4, #0
 80009f8:	d1f4      	bne.n	80009e4 <memset+0x80>
 80009fa:	e7f9      	b.n	80009f0 <memset+0x8c>
 80009fc:	4603      	mov	r3, r0
 80009fe:	4614      	mov	r4, r2
 8000a00:	e7bf      	b.n	8000982 <memset+0x1e>
 8000a02:	461a      	mov	r2, r3
 8000a04:	46a4      	mov	ip, r4
 8000a06:	e7e0      	b.n	80009ca <memset+0x66>

08000a08 <__malloc_lock>:
 8000a08:	4770      	bx	lr
 8000a0a:	bf00      	nop

08000a0c <__malloc_unlock>:
 8000a0c:	4770      	bx	lr
 8000a0e:	bf00      	nop

08000a10 <srand>:
 8000a10:	4b02      	ldr	r3, [pc, #8]	; (8000a1c <srand+0xc>)
 8000a12:	681b      	ldr	r3, [r3, #0]
 8000a14:	2200      	movs	r2, #0
 8000a16:	e9c3 022a 	strd	r0, r2, [r3, #168]	; 0xa8
 8000a1a:	4770      	bx	lr
 8000a1c:	20000000 	.word	0x20000000

08000a20 <rand>:
 8000a20:	4a0a      	ldr	r2, [pc, #40]	; (8000a4c <rand+0x2c>)
 8000a22:	490b      	ldr	r1, [pc, #44]	; (8000a50 <rand+0x30>)
 8000a24:	b410      	push	{r4}
 8000a26:	6814      	ldr	r4, [r2, #0]
 8000a28:	4a0a      	ldr	r2, [pc, #40]	; (8000a54 <rand+0x34>)
 8000a2a:	e9d4 032a 	ldrd	r0, r3, [r4, #168]	; 0xa8
 8000a2e:	fb00 f202 	mul.w	r2, r0, r2
 8000a32:	fb01 2203 	mla	r2, r1, r3, r2
 8000a36:	fba0 0101 	umull	r0, r1, r0, r1
 8000a3a:	1c43      	adds	r3, r0, #1
 8000a3c:	eb42 0001 	adc.w	r0, r2, r1
 8000a40:	e9c4 302a 	strd	r3, r0, [r4, #168]	; 0xa8
 8000a44:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 8000a48:	bc10      	pop	{r4}
 8000a4a:	4770      	bx	lr
 8000a4c:	20000000 	.word	0x20000000
 8000a50:	4c957f2d 	.word	0x4c957f2d
 8000a54:	5851f42d 	.word	0x5851f42d

08000a58 <_sbrk_r>:
 8000a58:	b538      	push	{r3, r4, r5, lr}
 8000a5a:	4d07      	ldr	r5, [pc, #28]	; (8000a78 <_sbrk_r+0x20>)
 8000a5c:	2200      	movs	r2, #0
 8000a5e:	4604      	mov	r4, r0
 8000a60:	4608      	mov	r0, r1
 8000a62:	602a      	str	r2, [r5, #0]
 8000a64:	f003 ff76 	bl	8004954 <_sbrk>
 8000a68:	1c43      	adds	r3, r0, #1
 8000a6a:	d000      	beq.n	8000a6e <_sbrk_r+0x16>
 8000a6c:	bd38      	pop	{r3, r4, r5, pc}
 8000a6e:	682b      	ldr	r3, [r5, #0]
 8000a70:	2b00      	cmp	r3, #0
 8000a72:	d0fb      	beq.n	8000a6c <_sbrk_r+0x14>
 8000a74:	6023      	str	r3, [r4, #0]
 8000a76:	bd38      	pop	{r3, r4, r5, pc}
 8000a78:	20001918 	.word	0x20001918

08000a7c <time>:
 8000a7c:	b510      	push	{r4, lr}
 8000a7e:	4b0b      	ldr	r3, [pc, #44]	; (8000aac <time+0x30>)
 8000a80:	b084      	sub	sp, #16
 8000a82:	4604      	mov	r4, r0
 8000a84:	2200      	movs	r2, #0
 8000a86:	6818      	ldr	r0, [r3, #0]
 8000a88:	4669      	mov	r1, sp
 8000a8a:	f000 f9f3 	bl	8000e74 <_gettimeofday_r>
 8000a8e:	2800      	cmp	r0, #0
 8000a90:	db06      	blt.n	8000aa0 <time+0x24>
 8000a92:	e9dd 0100 	ldrd	r0, r1, [sp]
 8000a96:	b10c      	cbz	r4, 8000a9c <time+0x20>
 8000a98:	e9c4 0100 	strd	r0, r1, [r4]
 8000a9c:	b004      	add	sp, #16
 8000a9e:	bd10      	pop	{r4, pc}
 8000aa0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8000aa4:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8000aa8:	e7f5      	b.n	8000a96 <time+0x1a>
 8000aaa:	bf00      	nop
 8000aac:	20000000 	.word	0x20000000

08000ab0 <__register_exitproc>:
 8000ab0:	b470      	push	{r4, r5, r6}
 8000ab2:	4c18      	ldr	r4, [pc, #96]	; (8000b14 <__register_exitproc+0x64>)
 8000ab4:	6825      	ldr	r5, [r4, #0]
 8000ab6:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
 8000aba:	b31c      	cbz	r4, 8000b04 <__register_exitproc+0x54>
 8000abc:	6865      	ldr	r5, [r4, #4]
 8000abe:	2d1f      	cmp	r5, #31
 8000ac0:	dc25      	bgt.n	8000b0e <__register_exitproc+0x5e>
 8000ac2:	b938      	cbnz	r0, 8000ad4 <__register_exitproc+0x24>
 8000ac4:	1cab      	adds	r3, r5, #2
 8000ac6:	3501      	adds	r5, #1
 8000ac8:	6065      	str	r5, [r4, #4]
 8000aca:	f844 1023 	str.w	r1, [r4, r3, lsl #2]
 8000ace:	2000      	movs	r0, #0
 8000ad0:	bc70      	pop	{r4, r5, r6}
 8000ad2:	4770      	bx	lr
 8000ad4:	eb04 0c85 	add.w	ip, r4, r5, lsl #2
 8000ad8:	2802      	cmp	r0, #2
 8000ada:	f8cc 2088 	str.w	r2, [ip, #136]	; 0x88
 8000ade:	f8d4 6188 	ldr.w	r6, [r4, #392]	; 0x188
 8000ae2:	f04f 0201 	mov.w	r2, #1
 8000ae6:	fa02 f205 	lsl.w	r2, r2, r5
 8000aea:	ea46 0602 	orr.w	r6, r6, r2
 8000aee:	f8c4 6188 	str.w	r6, [r4, #392]	; 0x188
 8000af2:	f8cc 3108 	str.w	r3, [ip, #264]	; 0x108
 8000af6:	d1e5      	bne.n	8000ac4 <__register_exitproc+0x14>
 8000af8:	f8d4 318c 	ldr.w	r3, [r4, #396]	; 0x18c
 8000afc:	4313      	orrs	r3, r2
 8000afe:	f8c4 318c 	str.w	r3, [r4, #396]	; 0x18c
 8000b02:	e7df      	b.n	8000ac4 <__register_exitproc+0x14>
 8000b04:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
 8000b08:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
 8000b0c:	e7d6      	b.n	8000abc <__register_exitproc+0xc>
 8000b0e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8000b12:	e7dd      	b.n	8000ad0 <__register_exitproc+0x20>
 8000b14:	08004f08 	.word	0x08004f08

08000b18 <__call_exitprocs>:
 8000b18:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000b1c:	4b29      	ldr	r3, [pc, #164]	; (8000bc4 <__call_exitprocs+0xac>)
 8000b1e:	681f      	ldr	r7, [r3, #0]
 8000b20:	b083      	sub	sp, #12
 8000b22:	f8d7 6148 	ldr.w	r6, [r7, #328]	; 0x148
 8000b26:	9001      	str	r0, [sp, #4]
 8000b28:	b1b6      	cbz	r6, 8000b58 <__call_exitprocs+0x40>
 8000b2a:	468b      	mov	fp, r1
 8000b2c:	f04f 0801 	mov.w	r8, #1
 8000b30:	f04f 0900 	mov.w	r9, #0
 8000b34:	6874      	ldr	r4, [r6, #4]
 8000b36:	1e65      	subs	r5, r4, #1
 8000b38:	d40e      	bmi.n	8000b58 <__call_exitprocs+0x40>
 8000b3a:	3401      	adds	r4, #1
 8000b3c:	eb06 0484 	add.w	r4, r6, r4, lsl #2
 8000b40:	f1bb 0f00 	cmp.w	fp, #0
 8000b44:	d00b      	beq.n	8000b5e <__call_exitprocs+0x46>
 8000b46:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
 8000b4a:	455b      	cmp	r3, fp
 8000b4c:	d007      	beq.n	8000b5e <__call_exitprocs+0x46>
 8000b4e:	3d01      	subs	r5, #1
 8000b50:	1c6b      	adds	r3, r5, #1
 8000b52:	f1a4 0404 	sub.w	r4, r4, #4
 8000b56:	d1f3      	bne.n	8000b40 <__call_exitprocs+0x28>
 8000b58:	b003      	add	sp, #12
 8000b5a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000b5e:	6873      	ldr	r3, [r6, #4]
 8000b60:	6822      	ldr	r2, [r4, #0]
 8000b62:	3b01      	subs	r3, #1
 8000b64:	42ab      	cmp	r3, r5
 8000b66:	bf0c      	ite	eq
 8000b68:	6075      	streq	r5, [r6, #4]
 8000b6a:	f8c4 9000 	strne.w	r9, [r4]
 8000b6e:	2a00      	cmp	r2, #0
 8000b70:	d0ed      	beq.n	8000b4e <__call_exitprocs+0x36>
 8000b72:	f8d6 0188 	ldr.w	r0, [r6, #392]	; 0x188
 8000b76:	f8d6 a004 	ldr.w	sl, [r6, #4]
 8000b7a:	fa08 f105 	lsl.w	r1, r8, r5
 8000b7e:	4201      	tst	r1, r0
 8000b80:	d10b      	bne.n	8000b9a <__call_exitprocs+0x82>
 8000b82:	4790      	blx	r2
 8000b84:	6872      	ldr	r2, [r6, #4]
 8000b86:	4552      	cmp	r2, sl
 8000b88:	d112      	bne.n	8000bb0 <__call_exitprocs+0x98>
 8000b8a:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 8000b8e:	42b3      	cmp	r3, r6
 8000b90:	d0dd      	beq.n	8000b4e <__call_exitprocs+0x36>
 8000b92:	461e      	mov	r6, r3
 8000b94:	2e00      	cmp	r6, #0
 8000b96:	d1cd      	bne.n	8000b34 <__call_exitprocs+0x1c>
 8000b98:	e7de      	b.n	8000b58 <__call_exitprocs+0x40>
 8000b9a:	f8d6 018c 	ldr.w	r0, [r6, #396]	; 0x18c
 8000b9e:	4201      	tst	r1, r0
 8000ba0:	d10b      	bne.n	8000bba <__call_exitprocs+0xa2>
 8000ba2:	f8d4 1080 	ldr.w	r1, [r4, #128]	; 0x80
 8000ba6:	9801      	ldr	r0, [sp, #4]
 8000ba8:	4790      	blx	r2
 8000baa:	6872      	ldr	r2, [r6, #4]
 8000bac:	4552      	cmp	r2, sl
 8000bae:	d0ec      	beq.n	8000b8a <__call_exitprocs+0x72>
 8000bb0:	f8d7 6148 	ldr.w	r6, [r7, #328]	; 0x148
 8000bb4:	2e00      	cmp	r6, #0
 8000bb6:	d1bd      	bne.n	8000b34 <__call_exitprocs+0x1c>
 8000bb8:	e7ce      	b.n	8000b58 <__call_exitprocs+0x40>
 8000bba:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
 8000bbe:	4790      	blx	r2
 8000bc0:	e7e0      	b.n	8000b84 <__call_exitprocs+0x6c>
 8000bc2:	bf00      	nop
 8000bc4:	08004f08 	.word	0x08004f08

08000bc8 <_malloc_trim_r>:
 8000bc8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000bca:	4f24      	ldr	r7, [pc, #144]	; (8000c5c <_malloc_trim_r+0x94>)
 8000bcc:	460c      	mov	r4, r1
 8000bce:	4606      	mov	r6, r0
 8000bd0:	f7ff ff1a 	bl	8000a08 <__malloc_lock>
 8000bd4:	68ba      	ldr	r2, [r7, #8]
 8000bd6:	6855      	ldr	r5, [r2, #4]
 8000bd8:	f5c4 637e 	rsb	r3, r4, #4064	; 0xfe0
 8000bdc:	330f      	adds	r3, #15
 8000bde:	f025 0503 	bic.w	r5, r5, #3
 8000be2:	442b      	add	r3, r5
 8000be4:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 8000be8:	f023 030f 	bic.w	r3, r3, #15
 8000bec:	f5a3 5480 	sub.w	r4, r3, #4096	; 0x1000
 8000bf0:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
 8000bf4:	db07      	blt.n	8000c06 <_malloc_trim_r+0x3e>
 8000bf6:	2100      	movs	r1, #0
 8000bf8:	4630      	mov	r0, r6
 8000bfa:	f7ff ff2d 	bl	8000a58 <_sbrk_r>
 8000bfe:	68bb      	ldr	r3, [r7, #8]
 8000c00:	442b      	add	r3, r5
 8000c02:	4298      	cmp	r0, r3
 8000c04:	d004      	beq.n	8000c10 <_malloc_trim_r+0x48>
 8000c06:	4630      	mov	r0, r6
 8000c08:	f7ff ff00 	bl	8000a0c <__malloc_unlock>
 8000c0c:	2000      	movs	r0, #0
 8000c0e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000c10:	4261      	negs	r1, r4
 8000c12:	4630      	mov	r0, r6
 8000c14:	f7ff ff20 	bl	8000a58 <_sbrk_r>
 8000c18:	3001      	adds	r0, #1
 8000c1a:	d00d      	beq.n	8000c38 <_malloc_trim_r+0x70>
 8000c1c:	4a10      	ldr	r2, [pc, #64]	; (8000c60 <_malloc_trim_r+0x98>)
 8000c1e:	68bb      	ldr	r3, [r7, #8]
 8000c20:	1b2d      	subs	r5, r5, r4
 8000c22:	f045 0501 	orr.w	r5, r5, #1
 8000c26:	605d      	str	r5, [r3, #4]
 8000c28:	6813      	ldr	r3, [r2, #0]
 8000c2a:	4630      	mov	r0, r6
 8000c2c:	1b1b      	subs	r3, r3, r4
 8000c2e:	6013      	str	r3, [r2, #0]
 8000c30:	f7ff feec 	bl	8000a0c <__malloc_unlock>
 8000c34:	2001      	movs	r0, #1
 8000c36:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000c38:	2100      	movs	r1, #0
 8000c3a:	4630      	mov	r0, r6
 8000c3c:	f7ff ff0c 	bl	8000a58 <_sbrk_r>
 8000c40:	68ba      	ldr	r2, [r7, #8]
 8000c42:	1a83      	subs	r3, r0, r2
 8000c44:	2b0f      	cmp	r3, #15
 8000c46:	ddde      	ble.n	8000c06 <_malloc_trim_r+0x3e>
 8000c48:	f043 0301 	orr.w	r3, r3, #1
 8000c4c:	6053      	str	r3, [r2, #4]
 8000c4e:	4b05      	ldr	r3, [pc, #20]	; (8000c64 <_malloc_trim_r+0x9c>)
 8000c50:	4903      	ldr	r1, [pc, #12]	; (8000c60 <_malloc_trim_r+0x98>)
 8000c52:	681b      	ldr	r3, [r3, #0]
 8000c54:	1ac0      	subs	r0, r0, r3
 8000c56:	6008      	str	r0, [r1, #0]
 8000c58:	e7d5      	b.n	8000c06 <_malloc_trim_r+0x3e>
 8000c5a:	bf00      	nop
 8000c5c:	20000430 	.word	0x20000430
 8000c60:	200018e8 	.word	0x200018e8
 8000c64:	20000838 	.word	0x20000838

08000c68 <_free_r>:
 8000c68:	2900      	cmp	r1, #0
 8000c6a:	d061      	beq.n	8000d30 <_free_r+0xc8>
 8000c6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000c6e:	460c      	mov	r4, r1
 8000c70:	4606      	mov	r6, r0
 8000c72:	f7ff fec9 	bl	8000a08 <__malloc_lock>
 8000c76:	f854 2c04 	ldr.w	r2, [r4, #-4]
 8000c7a:	4f7b      	ldr	r7, [pc, #492]	; (8000e68 <_free_r+0x200>)
 8000c7c:	f1a4 0508 	sub.w	r5, r4, #8
 8000c80:	f022 0101 	bic.w	r1, r2, #1
 8000c84:	eb05 0c01 	add.w	ip, r5, r1
 8000c88:	68b8      	ldr	r0, [r7, #8]
 8000c8a:	f8dc 3004 	ldr.w	r3, [ip, #4]
 8000c8e:	4560      	cmp	r0, ip
 8000c90:	f023 0303 	bic.w	r3, r3, #3
 8000c94:	f000 808b 	beq.w	8000dae <_free_r+0x146>
 8000c98:	07d2      	lsls	r2, r2, #31
 8000c9a:	f8cc 3004 	str.w	r3, [ip, #4]
 8000c9e:	d432      	bmi.n	8000d06 <_free_r+0x9e>
 8000ca0:	f854 2c08 	ldr.w	r2, [r4, #-8]
 8000ca4:	1aad      	subs	r5, r5, r2
 8000ca6:	4411      	add	r1, r2
 8000ca8:	68aa      	ldr	r2, [r5, #8]
 8000caa:	f107 0008 	add.w	r0, r7, #8
 8000cae:	4282      	cmp	r2, r0
 8000cb0:	d06a      	beq.n	8000d88 <_free_r+0x120>
 8000cb2:	eb0c 0403 	add.w	r4, ip, r3
 8000cb6:	f8d4 e004 	ldr.w	lr, [r4, #4]
 8000cba:	68ec      	ldr	r4, [r5, #12]
 8000cbc:	60d4      	str	r4, [r2, #12]
 8000cbe:	f01e 0f01 	tst.w	lr, #1
 8000cc2:	60a2      	str	r2, [r4, #8]
 8000cc4:	f000 8097 	beq.w	8000df6 <_free_r+0x18e>
 8000cc8:	f041 0301 	orr.w	r3, r1, #1
 8000ccc:	606b      	str	r3, [r5, #4]
 8000cce:	f8cc 1000 	str.w	r1, [ip]
 8000cd2:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8000cd6:	d235      	bcs.n	8000d44 <_free_r+0xdc>
 8000cd8:	687a      	ldr	r2, [r7, #4]
 8000cda:	08cb      	lsrs	r3, r1, #3
 8000cdc:	0948      	lsrs	r0, r1, #5
 8000cde:	2101      	movs	r1, #1
 8000ce0:	3301      	adds	r3, #1
 8000ce2:	4081      	lsls	r1, r0
 8000ce4:	4311      	orrs	r1, r2
 8000ce6:	6079      	str	r1, [r7, #4]
 8000ce8:	eb07 02c3 	add.w	r2, r7, r3, lsl #3
 8000cec:	f857 1033 	ldr.w	r1, [r7, r3, lsl #3]
 8000cf0:	3a08      	subs	r2, #8
 8000cf2:	e9c5 1202 	strd	r1, r2, [r5, #8]
 8000cf6:	f847 5033 	str.w	r5, [r7, r3, lsl #3]
 8000cfa:	60cd      	str	r5, [r1, #12]
 8000cfc:	4630      	mov	r0, r6
 8000cfe:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8000d02:	f7ff be83 	b.w	8000a0c <__malloc_unlock>
 8000d06:	eb0c 0203 	add.w	r2, ip, r3
 8000d0a:	6852      	ldr	r2, [r2, #4]
 8000d0c:	07d0      	lsls	r0, r2, #31
 8000d0e:	d410      	bmi.n	8000d32 <_free_r+0xca>
 8000d10:	4419      	add	r1, r3
 8000d12:	f107 0008 	add.w	r0, r7, #8
 8000d16:	f8dc 3008 	ldr.w	r3, [ip, #8]
 8000d1a:	4283      	cmp	r3, r0
 8000d1c:	d073      	beq.n	8000e06 <_free_r+0x19e>
 8000d1e:	f8dc 200c 	ldr.w	r2, [ip, #12]
 8000d22:	60da      	str	r2, [r3, #12]
 8000d24:	6093      	str	r3, [r2, #8]
 8000d26:	f041 0301 	orr.w	r3, r1, #1
 8000d2a:	606b      	str	r3, [r5, #4]
 8000d2c:	5069      	str	r1, [r5, r1]
 8000d2e:	e7d0      	b.n	8000cd2 <_free_r+0x6a>
 8000d30:	4770      	bx	lr
 8000d32:	f041 0301 	orr.w	r3, r1, #1
 8000d36:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8000d3a:	f844 3c04 	str.w	r3, [r4, #-4]
 8000d3e:	f8cc 1000 	str.w	r1, [ip]
 8000d42:	d3c9      	bcc.n	8000cd8 <_free_r+0x70>
 8000d44:	f5b1 6f20 	cmp.w	r1, #2560	; 0xa00
 8000d48:	ea4f 2351 	mov.w	r3, r1, lsr #9
 8000d4c:	d248      	bcs.n	8000de0 <_free_r+0x178>
 8000d4e:	098b      	lsrs	r3, r1, #6
 8000d50:	f103 0039 	add.w	r0, r3, #57	; 0x39
 8000d54:	f103 0238 	add.w	r2, r3, #56	; 0x38
 8000d58:	00c3      	lsls	r3, r0, #3
 8000d5a:	18f8      	adds	r0, r7, r3
 8000d5c:	58fb      	ldr	r3, [r7, r3]
 8000d5e:	3808      	subs	r0, #8
 8000d60:	4298      	cmp	r0, r3
 8000d62:	d059      	beq.n	8000e18 <_free_r+0x1b0>
 8000d64:	685a      	ldr	r2, [r3, #4]
 8000d66:	f022 0203 	bic.w	r2, r2, #3
 8000d6a:	428a      	cmp	r2, r1
 8000d6c:	d902      	bls.n	8000d74 <_free_r+0x10c>
 8000d6e:	689b      	ldr	r3, [r3, #8]
 8000d70:	4298      	cmp	r0, r3
 8000d72:	d1f7      	bne.n	8000d64 <_free_r+0xfc>
 8000d74:	68d8      	ldr	r0, [r3, #12]
 8000d76:	e9c5 3002 	strd	r3, r0, [r5, #8]
 8000d7a:	6085      	str	r5, [r0, #8]
 8000d7c:	60dd      	str	r5, [r3, #12]
 8000d7e:	4630      	mov	r0, r6
 8000d80:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8000d84:	f7ff be42 	b.w	8000a0c <__malloc_unlock>
 8000d88:	eb0c 0203 	add.w	r2, ip, r3
 8000d8c:	6852      	ldr	r2, [r2, #4]
 8000d8e:	07d2      	lsls	r2, r2, #31
 8000d90:	d463      	bmi.n	8000e5a <_free_r+0x1f2>
 8000d92:	440b      	add	r3, r1
 8000d94:	e9dc 1202 	ldrd	r1, r2, [ip, #8]
 8000d98:	60ca      	str	r2, [r1, #12]
 8000d9a:	6091      	str	r1, [r2, #8]
 8000d9c:	f043 0201 	orr.w	r2, r3, #1
 8000da0:	606a      	str	r2, [r5, #4]
 8000da2:	4630      	mov	r0, r6
 8000da4:	50eb      	str	r3, [r5, r3]
 8000da6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8000daa:	f7ff be2f 	b.w	8000a0c <__malloc_unlock>
 8000dae:	440b      	add	r3, r1
 8000db0:	07d1      	lsls	r1, r2, #31
 8000db2:	d407      	bmi.n	8000dc4 <_free_r+0x15c>
 8000db4:	f854 2c08 	ldr.w	r2, [r4, #-8]
 8000db8:	1aad      	subs	r5, r5, r2
 8000dba:	4413      	add	r3, r2
 8000dbc:	e9d5 1202 	ldrd	r1, r2, [r5, #8]
 8000dc0:	60ca      	str	r2, [r1, #12]
 8000dc2:	6091      	str	r1, [r2, #8]
 8000dc4:	f043 0201 	orr.w	r2, r3, #1
 8000dc8:	606a      	str	r2, [r5, #4]
 8000dca:	4a28      	ldr	r2, [pc, #160]	; (8000e6c <_free_r+0x204>)
 8000dcc:	60bd      	str	r5, [r7, #8]
 8000dce:	6812      	ldr	r2, [r2, #0]
 8000dd0:	429a      	cmp	r2, r3
 8000dd2:	d893      	bhi.n	8000cfc <_free_r+0x94>
 8000dd4:	4b26      	ldr	r3, [pc, #152]	; (8000e70 <_free_r+0x208>)
 8000dd6:	4630      	mov	r0, r6
 8000dd8:	6819      	ldr	r1, [r3, #0]
 8000dda:	f7ff fef5 	bl	8000bc8 <_malloc_trim_r>
 8000dde:	e78d      	b.n	8000cfc <_free_r+0x94>
 8000de0:	2b14      	cmp	r3, #20
 8000de2:	d90a      	bls.n	8000dfa <_free_r+0x192>
 8000de4:	2b54      	cmp	r3, #84	; 0x54
 8000de6:	d81f      	bhi.n	8000e28 <_free_r+0x1c0>
 8000de8:	0b0b      	lsrs	r3, r1, #12
 8000dea:	f103 006f 	add.w	r0, r3, #111	; 0x6f
 8000dee:	f103 026e 	add.w	r2, r3, #110	; 0x6e
 8000df2:	00c3      	lsls	r3, r0, #3
 8000df4:	e7b1      	b.n	8000d5a <_free_r+0xf2>
 8000df6:	4419      	add	r1, r3
 8000df8:	e78d      	b.n	8000d16 <_free_r+0xae>
 8000dfa:	f103 005c 	add.w	r0, r3, #92	; 0x5c
 8000dfe:	f103 025b 	add.w	r2, r3, #91	; 0x5b
 8000e02:	00c3      	lsls	r3, r0, #3
 8000e04:	e7a9      	b.n	8000d5a <_free_r+0xf2>
 8000e06:	f041 0301 	orr.w	r3, r1, #1
 8000e0a:	e9c7 5504 	strd	r5, r5, [r7, #16]
 8000e0e:	e9c5 0002 	strd	r0, r0, [r5, #8]
 8000e12:	606b      	str	r3, [r5, #4]
 8000e14:	5069      	str	r1, [r5, r1]
 8000e16:	e771      	b.n	8000cfc <_free_r+0x94>
 8000e18:	6879      	ldr	r1, [r7, #4]
 8000e1a:	1092      	asrs	r2, r2, #2
 8000e1c:	2401      	movs	r4, #1
 8000e1e:	fa04 f202 	lsl.w	r2, r4, r2
 8000e22:	430a      	orrs	r2, r1
 8000e24:	607a      	str	r2, [r7, #4]
 8000e26:	e7a6      	b.n	8000d76 <_free_r+0x10e>
 8000e28:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
 8000e2c:	d806      	bhi.n	8000e3c <_free_r+0x1d4>
 8000e2e:	0bcb      	lsrs	r3, r1, #15
 8000e30:	f103 0078 	add.w	r0, r3, #120	; 0x78
 8000e34:	f103 0277 	add.w	r2, r3, #119	; 0x77
 8000e38:	00c3      	lsls	r3, r0, #3
 8000e3a:	e78e      	b.n	8000d5a <_free_r+0xf2>
 8000e3c:	f240 5254 	movw	r2, #1364	; 0x554
 8000e40:	4293      	cmp	r3, r2
 8000e42:	d806      	bhi.n	8000e52 <_free_r+0x1ea>
 8000e44:	0c8b      	lsrs	r3, r1, #18
 8000e46:	f103 007d 	add.w	r0, r3, #125	; 0x7d
 8000e4a:	f103 027c 	add.w	r2, r3, #124	; 0x7c
 8000e4e:	00c3      	lsls	r3, r0, #3
 8000e50:	e783      	b.n	8000d5a <_free_r+0xf2>
 8000e52:	f44f 737e 	mov.w	r3, #1016	; 0x3f8
 8000e56:	227e      	movs	r2, #126	; 0x7e
 8000e58:	e77f      	b.n	8000d5a <_free_r+0xf2>
 8000e5a:	f041 0301 	orr.w	r3, r1, #1
 8000e5e:	606b      	str	r3, [r5, #4]
 8000e60:	f8cc 1000 	str.w	r1, [ip]
 8000e64:	e74a      	b.n	8000cfc <_free_r+0x94>
 8000e66:	bf00      	nop
 8000e68:	20000430 	.word	0x20000430
 8000e6c:	2000083c 	.word	0x2000083c
 8000e70:	200018e4 	.word	0x200018e4

08000e74 <_gettimeofday_r>:
 8000e74:	b570      	push	{r4, r5, r6, lr}
 8000e76:	460c      	mov	r4, r1
 8000e78:	4d08      	ldr	r5, [pc, #32]	; (8000e9c <_gettimeofday_r+0x28>)
 8000e7a:	4603      	mov	r3, r0
 8000e7c:	2600      	movs	r6, #0
 8000e7e:	4620      	mov	r0, r4
 8000e80:	4611      	mov	r1, r2
 8000e82:	461c      	mov	r4, r3
 8000e84:	602e      	str	r6, [r5, #0]
 8000e86:	f000 f80b 	bl	8000ea0 <_gettimeofday>
 8000e8a:	1c43      	adds	r3, r0, #1
 8000e8c:	d000      	beq.n	8000e90 <_gettimeofday_r+0x1c>
 8000e8e:	bd70      	pop	{r4, r5, r6, pc}
 8000e90:	682b      	ldr	r3, [r5, #0]
 8000e92:	2b00      	cmp	r3, #0
 8000e94:	d0fb      	beq.n	8000e8e <_gettimeofday_r+0x1a>
 8000e96:	6023      	str	r3, [r4, #0]
 8000e98:	bd70      	pop	{r4, r5, r6, pc}
 8000e9a:	bf00      	nop
 8000e9c:	20001918 	.word	0x20001918

08000ea0 <_gettimeofday>:
 8000ea0:	4b02      	ldr	r3, [pc, #8]	; (8000eac <_gettimeofday+0xc>)
 8000ea2:	2258      	movs	r2, #88	; 0x58
 8000ea4:	601a      	str	r2, [r3, #0]
 8000ea6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8000eaa:	4770      	bx	lr
 8000eac:	20001918 	.word	0x20001918

08000eb0 <_exit>:
 8000eb0:	e7fe      	b.n	8000eb0 <_exit>
 8000eb2:	bf00      	nop

08000eb4 <sign>:
	for(i=0;i<8;i++){
		buf[i] = n % 256;
		n /= 256;
	}
} 
uint8_t sign(uint8_t cmd, uint8_t scmd, uint8_t len, uint8_t *buf){
 8000eb4:	b530      	push	{r4, r5, lr}
 8000eb6:	f5ad 5d51 	sub.w	sp, sp, #13376	; 0x3440
 8000eba:	b089      	sub	sp, #36	; 0x24
    uint16_t nonce = 0;
    polyvecl s1, y, z;
    poly cp;
    uint8_t sig[32];

    srand((unsigned)time( NULL ) );
 8000ebc:	2000      	movs	r0, #0
uint8_t sign(uint8_t cmd, uint8_t scmd, uint8_t len, uint8_t *buf){
 8000ebe:	461c      	mov	r4, r3
    srand((unsigned)time( NULL ) );
 8000ec0:	f7ff fddc 	bl	8000a7c <time>
 8000ec4:	f7ff fda4 	bl	8000a10 <srand>
    randombytes(rhoprime, 64);
 8000ec8:	2140      	movs	r1, #64	; 0x40
 8000eca:	a808      	add	r0, sp, #32
 8000ecc:	f002 fb64 	bl	8003598 <PQCLEAN_randombytes>
    PQCLEAN_MLDSA44_CLEAN_polyvecl_uniform_eta(&s1, rhoprime, 0);
 8000ed0:	2200      	movs	r2, #0
 8000ed2:	a908      	add	r1, sp, #32
 8000ed4:	f50d 608c 	add.w	r0, sp, #1120	; 0x460
 8000ed8:	f000 fd66 	bl	80019a8 <PQCLEAN_MLDSA44_CLEAN_polyvecl_uniform_eta>
    PQCLEAN_MLDSA44_CLEAN_polyvecl_ntt(&s1);
 8000edc:	f50d 608c 	add.w	r0, sp, #1120	; 0x460
 8000ee0:	f000 fdaa 	bl	8001a38 <PQCLEAN_MLDSA44_CLEAN_polyvecl_ntt>
    
    randombytes(rhoprime, 64);
 8000ee4:	2140      	movs	r1, #64	; 0x40
 8000ee6:	a808      	add	r0, sp, #32
 8000ee8:	f002 fb56 	bl	8003598 <PQCLEAN_randombytes>
    PQCLEAN_MLDSA44_CLEAN_polyvecl_uniform_gamma1(&y, rhoprime, 0);
 8000eec:	2200      	movs	r2, #0
 8000eee:	a908      	add	r1, sp, #32
 8000ef0:	f50d 50a3 	add.w	r0, sp, #5216	; 0x1460
 8000ef4:	f000 fd6a 	bl	80019cc <PQCLEAN_MLDSA44_CLEAN_polyvecl_uniform_gamma1>
    
    randombytes(sig, 32);
 8000ef8:	2120      	movs	r1, #32
 8000efa:	4668      	mov	r0, sp
 8000efc:	f002 fb4c 	bl	8003598 <PQCLEAN_randombytes>
    PQCLEAN_MLDSA44_CLEAN_poly_challenge(&cp, sig); 
 8000f00:	4669      	mov	r1, sp
 8000f02:	a818      	add	r0, sp, #96	; 0x60
 8000f04:	f000 fb98 	bl	8001638 <PQCLEAN_MLDSA44_CLEAN_poly_challenge>
    PQCLEAN_MLDSA44_CLEAN_poly_ntt(&cp);
 8000f08:	a818      	add	r0, sp, #96	; 0x60
 8000f0a:	f000 fa7b 	bl	8001404 <PQCLEAN_MLDSA44_CLEAN_poly_ntt>
		n = n*256 + buf[7-i];
 8000f0e:	79e2      	ldrb	r2, [r4, #7]
 8000f10:	79a3      	ldrb	r3, [r4, #6]
 8000f12:	7ba1      	ldrb	r1, [r4, #14]
 8000f14:	7be0      	ldrb	r0, [r4, #15]
 8000f16:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8000f1a:	7962      	ldrb	r2, [r4, #5]
 8000f1c:	eb02 2303 	add.w	r3, r2, r3, lsl #8
 8000f20:	7922      	ldrb	r2, [r4, #4]
 8000f22:	eb01 2000 	add.w	r0, r1, r0, lsl #8
 8000f26:	7b61      	ldrb	r1, [r4, #13]
 8000f28:	eb02 2203 	add.w	r2, r2, r3, lsl #8
 8000f2c:	78e3      	ldrb	r3, [r4, #3]
 8000f2e:	eb01 2100 	add.w	r1, r1, r0, lsl #8
 8000f32:	7b20      	ldrb	r0, [r4, #12]
 8000f34:	eb03 2202 	add.w	r2, r3, r2, lsl #8
 8000f38:	78a3      	ldrb	r3, [r4, #2]
 8000f3a:	eb00 2101 	add.w	r1, r0, r1, lsl #8
 8000f3e:	7ae0      	ldrb	r0, [r4, #11]
 8000f40:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8000f44:	7aa2      	ldrb	r2, [r4, #10]
 8000f46:	eb00 2001 	add.w	r0, r0, r1, lsl #8
 8000f4a:	eb02 2000 	add.w	r0, r2, r0, lsl #8
 8000f4e:	7862      	ldrb	r2, [r4, #1]
	n -= mask;
 8000f50:	4942      	ldr	r1, [pc, #264]	; (800105c <sign+0x1a8>)
		n = n*256 + buf[7-i];
 8000f52:	eb02 2303 	add.w	r3, r2, r3, lsl #8
 8000f56:	7822      	ldrb	r2, [r4, #0]
	n -= mask;
 8000f58:	1852      	adds	r2, r2, r1
 8000f5a:	eb02 2203 	add.w	r2, r2, r3, lsl #8
		n = n*256 + buf[7-i];
 8000f5e:	7a63      	ldrb	r3, [r4, #9]
	*r = (int32_t)n;
 8000f60:	9218      	str	r2, [sp, #96]	; 0x60
		n = n*256 + buf[7-i];
 8000f62:	eb03 2200 	add.w	r2, r3, r0, lsl #8
 8000f66:	7a23      	ldrb	r3, [r4, #8]
    
    
    decode(buf, &cp.coeffs[0]);
    decode(buf+8, &s1.vec[0].coeffs[0]);
    trigger_high();
    PQCLEAN_MLDSA44_CLEAN_polyvecl_pointwise_poly_montgomery(&z, &cp, &s1);
 8000f68:	f50d 5511 	add.w	r5, sp, #9280	; 0x2440
	n -= mask;
 8000f6c:	185b      	adds	r3, r3, r1
 8000f6e:	eb03 2302 	add.w	r3, r3, r2, lsl #8
    PQCLEAN_MLDSA44_CLEAN_polyvecl_pointwise_poly_montgomery(&z, &cp, &s1);
 8000f72:	3520      	adds	r5, #32
	*r = (int32_t)n;
 8000f74:	f8cd 3460 	str.w	r3, [sp, #1120]	; 0x460
    trigger_high();
 8000f78:	f002 ff66 	bl	8003e48 <trigger_high>
    PQCLEAN_MLDSA44_CLEAN_polyvecl_pointwise_poly_montgomery(&z, &cp, &s1);
 8000f7c:	a918      	add	r1, sp, #96	; 0x60
 8000f7e:	f50d 628c 	add.w	r2, sp, #1120	; 0x460
 8000f82:	4628      	mov	r0, r5
 8000f84:	f000 fd7c 	bl	8001a80 <PQCLEAN_MLDSA44_CLEAN_polyvecl_pointwise_poly_montgomery>
    trigger_low();
 8000f88:	f002 ff66 	bl	8003e58 <trigger_low>
    PQCLEAN_MLDSA44_CLEAN_polyvecl_invntt_tomont(&z);
 8000f8c:	4628      	mov	r0, r5
 8000f8e:	f000 fd65 	bl	8001a5c <PQCLEAN_MLDSA44_CLEAN_polyvecl_invntt_tomont>
    PQCLEAN_MLDSA44_CLEAN_polyvecl_add(&z, &z, &y);
 8000f92:	f50d 52a3 	add.w	r2, sp, #5216	; 0x1460
 8000f96:	4629      	mov	r1, r5
 8000f98:	4628      	mov	r0, r5
 8000f9a:	f000 fd3d 	bl	8001a18 <PQCLEAN_MLDSA44_CLEAN_polyvecl_add>
    PQCLEAN_MLDSA44_CLEAN_polyvecl_reduce(&z);
 8000f9e:	4628      	mov	r0, r5
 8000fa0:	f000 fd28 	bl	80019f4 <PQCLEAN_MLDSA44_CLEAN_polyvecl_reduce>
	n += mask;
 8000fa4:	f8dd 2460 	ldr.w	r2, [sp, #1120]	; 0x460
 8000fa8:	4b2d      	ldr	r3, [pc, #180]	; (8001060 <sign+0x1ac>)
 8000faa:	6828      	ldr	r0, [r5, #0]
 8000fac:	4413      	add	r3, r2
		buf[i] = n % 256;
 8000fae:	4259      	negs	r1, r3
 8000fb0:	b2c9      	uxtb	r1, r1
 8000fb2:	b2da      	uxtb	r2, r3
 8000fb4:	bf58      	it	pl
 8000fb6:	424a      	negpl	r2, r1
		n /= 256;
 8000fb8:	2b00      	cmp	r3, #0
 8000fba:	bfb8      	it	lt
 8000fbc:	33ff      	addlt	r3, #255	; 0xff
 8000fbe:	121b      	asrs	r3, r3, #8
		buf[i] = n % 256;
 8000fc0:	4259      	negs	r1, r3
 8000fc2:	b2c9      	uxtb	r1, r1
 8000fc4:	7022      	strb	r2, [r4, #0]
 8000fc6:	b2da      	uxtb	r2, r3
 8000fc8:	bf58      	it	pl
 8000fca:	424a      	negpl	r2, r1
		n /= 256;
 8000fcc:	2b00      	cmp	r3, #0
 8000fce:	bfb8      	it	lt
 8000fd0:	33ff      	addlt	r3, #255	; 0xff
 8000fd2:	121b      	asrs	r3, r3, #8
		buf[i] = n % 256;
 8000fd4:	4259      	negs	r1, r3
 8000fd6:	b2c9      	uxtb	r1, r1
 8000fd8:	7062      	strb	r2, [r4, #1]
 8000fda:	b2da      	uxtb	r2, r3
 8000fdc:	bf58      	it	pl
 8000fde:	424a      	negpl	r2, r1
 8000fe0:	70a2      	strb	r2, [r4, #2]
		n /= 256;
 8000fe2:	1e1a      	subs	r2, r3, #0
	n += mask;
 8000fe4:	4b1e      	ldr	r3, [pc, #120]	; (8001060 <sign+0x1ac>)
		buf[i] = n % 256;
 8000fe6:	f04f 0100 	mov.w	r1, #0
	n += mask;
 8000fea:	4403      	add	r3, r0
		n /= 256;
 8000fec:	bfb8      	it	lt
 8000fee:	32ff      	addlt	r2, #255	; 0xff
		buf[i] = n % 256;
 8000ff0:	1ac8      	subs	r0, r1, r3
 8000ff2:	b2c0      	uxtb	r0, r0
		n /= 256;
 8000ff4:	ea4f 2222 	mov.w	r2, r2, asr #8
		buf[i] = n % 256;
 8000ff8:	70e2      	strb	r2, [r4, #3]
 8000ffa:	b2da      	uxtb	r2, r3
 8000ffc:	bf58      	it	pl
 8000ffe:	4242      	negpl	r2, r0
		n /= 256;
 8001000:	2b00      	cmp	r3, #0
 8001002:	bfb8      	it	lt
 8001004:	33ff      	addlt	r3, #255	; 0xff
 8001006:	121b      	asrs	r3, r3, #8
		buf[i] = n % 256;
 8001008:	7121      	strb	r1, [r4, #4]
 800100a:	7161      	strb	r1, [r4, #5]
 800100c:	71a1      	strb	r1, [r4, #6]
 800100e:	71e1      	strb	r1, [r4, #7]
 8001010:	4259      	negs	r1, r3
 8001012:	b2c9      	uxtb	r1, r1
 8001014:	7222      	strb	r2, [r4, #8]
 8001016:	b2da      	uxtb	r2, r3
 8001018:	bf58      	it	pl
 800101a:	424a      	negpl	r2, r1
		n /= 256;
 800101c:	2b00      	cmp	r3, #0
 800101e:	bfb8      	it	lt
 8001020:	33ff      	addlt	r3, #255	; 0xff
 8001022:	121b      	asrs	r3, r3, #8
		buf[i] = n % 256;
 8001024:	4259      	negs	r1, r3
 8001026:	b2c9      	uxtb	r1, r1
 8001028:	7262      	strb	r2, [r4, #9]
 800102a:	b2da      	uxtb	r2, r3
 800102c:	bf58      	it	pl
 800102e:	424a      	negpl	r2, r1
		n /= 256;
 8001030:	2b00      	cmp	r3, #0
 8001032:	bfb8      	it	lt
 8001034:	33ff      	addlt	r3, #255	; 0xff
		buf[i] = n % 256;
 8001036:	2500      	movs	r5, #0
		n /= 256;
 8001038:	121b      	asrs	r3, r3, #8
		buf[i] = n % 256;
 800103a:	72a2      	strb	r2, [r4, #10]
 800103c:	72e3      	strb	r3, [r4, #11]
 800103e:	7325      	strb	r5, [r4, #12]
 8001040:	7365      	strb	r5, [r4, #13]
 8001042:	73a5      	strb	r5, [r4, #14]
 8001044:	73e5      	strb	r5, [r4, #15]
    

    encode(buf, s1.vec[0].coeffs[0]);
    encode(buf+8, z.vec[0].coeffs[0]);
    simpleserial_put('r', 16, buf);
 8001046:	4622      	mov	r2, r4
 8001048:	2110      	movs	r1, #16
 800104a:	2072      	movs	r0, #114	; 0x72
 800104c:	f002 fd82 	bl	8003b54 <simpleserial_put>
    return 0x00;
}
 8001050:	4628      	mov	r0, r5
 8001052:	f50d 5d51 	add.w	sp, sp, #13376	; 0x3440
 8001056:	b009      	add	sp, #36	; 0x24
 8001058:	bd30      	pop	{r4, r5, pc}
 800105a:	bf00      	nop
 800105c:	fc00fff6 	.word	0xfc00fff6
 8001060:	03ff000a 	.word	0x03ff000a

08001064 <main>:
uint8_t pk[PQCLEAN_MLDSA44_CLEAN_CRYPTO_PUBLICKEYBYTES];
uint8_t sk[PQCLEAN_MLDSA44_CLEAN_CRYPTO_SECRETKEYBYTES];
int main(void){
 8001064:	b508      	push	{r3, lr}
    srand((unsigned)time(NULL));
 8001066:	2000      	movs	r0, #0
 8001068:	f7ff fd08 	bl	8000a7c <time>
 800106c:	f7ff fcd0 	bl	8000a10 <srand>
    PQCLEAN_MLDSA44_CLEAN_crypto_sign_keypair(pk, sk);
 8001070:	490a      	ldr	r1, [pc, #40]	; (800109c <main+0x38>)
 8001072:	f501 6020 	add.w	r0, r1, #2560	; 0xa00
 8001076:	f000 fdd7 	bl	8001c28 <PQCLEAN_MLDSA44_CLEAN_crypto_sign_keypair>
    platform_init();
 800107a:	f002 fe41 	bl	8003d00 <platform_init>
    init_uart();
 800107e:	f002 fe81 	bl	8003d84 <init_uart>
    trigger_setup();
 8001082:	f002 febf 	bl	8003e04 <trigger_setup>
    simpleserial_init();
 8001086:	f002 fc17 	bl	80038b8 <simpleserial_init>
    simpleserial_addcmd(0x01, 16, sign);
 800108a:	4a05      	ldr	r2, [pc, #20]	; (80010a0 <main+0x3c>)
 800108c:	2110      	movs	r1, #16
 800108e:	2001      	movs	r0, #1
 8001090:	f002 fc44 	bl	800391c <simpleserial_addcmd>
    while(1)
        simpleserial_get();
 8001094:	f002 fc62 	bl	800395c <simpleserial_get>
    while(1)
 8001098:	e7fc      	b.n	8001094 <main+0x30>
 800109a:	bf00      	nop
 800109c:	2000085c 	.word	0x2000085c
 80010a0:	08000eb5 	.word	0x08000eb5

080010a4 <PQCLEAN_MLDSA44_CLEAN_ntt>:
* Description: Forward NTT, in-place. No modular reduction is performed after
*              additions or subtractions. Output vector is in bitreversed order.
*
* Arguments:   - uint32_t p[N]: input/output coefficient array
**************************************************/
void PQCLEAN_MLDSA44_CLEAN_ntt(int32_t a[N]) {
 80010a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80010a8:	b085      	sub	sp, #20
    int32_t zeta, t;

    k = 0;
    for (len = 128; len > 0; len >>= 1) {
        for (start = 0; start < N; start = j + len) {
            zeta = zetas[++k];
 80010aa:	2308      	movs	r3, #8
void PQCLEAN_MLDSA44_CLEAN_ntt(int32_t a[N]) {
 80010ac:	4607      	mov	r7, r0
            zeta = zetas[++k];
 80010ae:	9303      	str	r3, [sp, #12]
 80010b0:	f246 44f7 	movw	r4, #25847	; 0x64f7
    k = 0;
 80010b4:	f04f 0800 	mov.w	r8, #0
    for (len = 128; len > 0; len >>= 1) {
 80010b8:	f04f 0980 	mov.w	r9, #128	; 0x80
        for (start = 0; start < N; start = j + len) {
 80010bc:	4b26      	ldr	r3, [pc, #152]	; (8001158 <PQCLEAN_MLDSA44_CLEAN_ntt+0xb4>)
 80010be:	f108 0a02 	add.w	sl, r8, #2
 80010c2:	eb03 038a 	add.w	r3, r3, sl, lsl #2
 80010c6:	2600      	movs	r6, #0
            zeta = zetas[++k];
 80010c8:	9302      	str	r3, [sp, #8]
            for (j = start; j < start + len; ++j) {
 80010ca:	eb09 0306 	add.w	r3, r9, r6
            zeta = zetas[++k];
 80010ce:	f108 0201 	add.w	r2, r8, #1
            for (j = start; j < start + len; ++j) {
 80010d2:	42b3      	cmp	r3, r6
            zeta = zetas[++k];
 80010d4:	9201      	str	r2, [sp, #4]
            for (j = start; j < start + len; ++j) {
 80010d6:	d92b      	bls.n	8001130 <PQCLEAN_MLDSA44_CLEAN_ntt+0x8c>
 80010d8:	f106 4280 	add.w	r2, r6, #1073741824	; 0x40000000
 80010dc:	3a01      	subs	r2, #1
 80010de:	eb03 0609 	add.w	r6, r3, r9
 80010e2:	eb07 0a83 	add.w	sl, r7, r3, lsl #2
 80010e6:	eb07 0b82 	add.w	fp, r7, r2, lsl #2
 80010ea:	eb07 0586 	add.w	r5, r7, r6, lsl #2
                t = PQCLEAN_MLDSA44_CLEAN_montgomery_reduce((int64_t)zeta * a[j + len]);
 80010ee:	f8da 1000 	ldr.w	r1, [sl]
 80010f2:	fb81 0104 	smull	r0, r1, r1, r4
 80010f6:	f000 fd69 	bl	8001bcc <PQCLEAN_MLDSA44_CLEAN_montgomery_reduce>
                a[j + len] = a[j] - t;
 80010fa:	f85b 3f04 	ldr.w	r3, [fp, #4]!
 80010fe:	1a1b      	subs	r3, r3, r0
 8001100:	f84a 3b04 	str.w	r3, [sl], #4
                a[j] = a[j] + t;
 8001104:	f8db 3000 	ldr.w	r3, [fp]
            for (j = start; j < start + len; ++j) {
 8001108:	4555      	cmp	r5, sl
                a[j] = a[j] + t;
 800110a:	4418      	add	r0, r3
 800110c:	f8cb 0000 	str.w	r0, [fp]
            for (j = start; j < start + len; ++j) {
 8001110:	d1ed      	bne.n	80010ee <PQCLEAN_MLDSA44_CLEAN_ntt+0x4a>
        for (start = 0; start < N; start = j + len) {
 8001112:	2eff      	cmp	r6, #255	; 0xff
 8001114:	d80e      	bhi.n	8001134 <PQCLEAN_MLDSA44_CLEAN_ntt+0x90>
            zeta = zetas[++k];
 8001116:	9b02      	ldr	r3, [sp, #8]
 8001118:	f8dd 8004 	ldr.w	r8, [sp, #4]
 800111c:	f853 4b04 	ldr.w	r4, [r3], #4
 8001120:	9302      	str	r3, [sp, #8]
            for (j = start; j < start + len; ++j) {
 8001122:	eb09 0306 	add.w	r3, r9, r6
            zeta = zetas[++k];
 8001126:	f108 0201 	add.w	r2, r8, #1
            for (j = start; j < start + len; ++j) {
 800112a:	42b3      	cmp	r3, r6
            zeta = zetas[++k];
 800112c:	9201      	str	r2, [sp, #4]
            for (j = start; j < start + len; ++j) {
 800112e:	d8d3      	bhi.n	80010d8 <PQCLEAN_MLDSA44_CLEAN_ntt+0x34>
 8001130:	461e      	mov	r6, r3
 8001132:	e7f0      	b.n	8001116 <PQCLEAN_MLDSA44_CLEAN_ntt+0x72>
    for (len = 128; len > 0; len >>= 1) {
 8001134:	9b03      	ldr	r3, [sp, #12]
 8001136:	3b01      	subs	r3, #1
 8001138:	ea4f 0959 	mov.w	r9, r9, lsr #1
 800113c:	9303      	str	r3, [sp, #12]
 800113e:	d007      	beq.n	8001150 <PQCLEAN_MLDSA44_CLEAN_ntt+0xac>
            zeta = zetas[++k];
 8001140:	f108 0302 	add.w	r3, r8, #2
 8001144:	4a04      	ldr	r2, [pc, #16]	; (8001158 <PQCLEAN_MLDSA44_CLEAN_ntt+0xb4>)
 8001146:	f8dd 8004 	ldr.w	r8, [sp, #4]
 800114a:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
 800114e:	e7b5      	b.n	80010bc <PQCLEAN_MLDSA44_CLEAN_ntt+0x18>
            }
        }
    }
}
 8001150:	b005      	add	sp, #20
 8001152:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001156:	bf00      	nop
 8001158:	08004a48 	.word	0x08004a48

0800115c <PQCLEAN_MLDSA44_CLEAN_invntt_tomont>:
*              Q in absolute value. Output coefficient are smaller than Q in
*              absolute value.
*
* Arguments:   - uint32_t p[N]: input/output coefficient array
**************************************************/
void PQCLEAN_MLDSA44_CLEAN_invntt_tomont(int32_t a[N]) {
 800115c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001160:	b085      	sub	sp, #20

    k = 256;
    for (len = 1; len < N; len <<= 1) {
        for (start = 0; start < N; start = j + len) {
            zeta = -zetas[--k];
            for (j = start; j < start + len; ++j) {
 8001162:	2308      	movs	r3, #8
 8001164:	9303      	str	r3, [sp, #12]
 8001166:	1f03      	subs	r3, r0, #4
void PQCLEAN_MLDSA44_CLEAN_invntt_tomont(int32_t a[N]) {
 8001168:	9001      	str	r0, [sp, #4]
    k = 256;
 800116a:	f44f 7a80 	mov.w	sl, #256	; 0x100
    for (len = 1; len < N; len <<= 1) {
 800116e:	f04f 0901 	mov.w	r9, #1
 8001172:	9302      	str	r3, [sp, #8]
        for (start = 0; start < N; start = j + len) {
 8001174:	4b26      	ldr	r3, [pc, #152]	; (8001210 <PQCLEAN_MLDSA44_CLEAN_invntt_tomont+0xb4>)
 8001176:	f10a 4780 	add.w	r7, sl, #1073741824	; 0x40000000
 800117a:	3f01      	subs	r7, #1
 800117c:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 8001180:	2200      	movs	r2, #0
            zeta = -zetas[--k];
 8001182:	f857 4904 	ldr.w	r4, [r7], #-4
            for (j = start; j < start + len; ++j) {
 8001186:	eb02 0609 	add.w	r6, r2, r9
 800118a:	4296      	cmp	r6, r2
            zeta = -zetas[--k];
 800118c:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
 8001190:	f1c4 0400 	rsb	r4, r4, #0
            for (j = start; j < start + len; ++j) {
 8001194:	d93a      	bls.n	800120c <PQCLEAN_MLDSA44_CLEAN_invntt_tomont+0xb0>
 8001196:	9b01      	ldr	r3, [sp, #4]
 8001198:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 800119c:	3a01      	subs	r2, #1
 800119e:	eb03 0882 	add.w	r8, r3, r2, lsl #2
 80011a2:	eb03 0b86 	add.w	fp, r3, r6, lsl #2
 80011a6:	9b02      	ldr	r3, [sp, #8]
 80011a8:	eb03 0586 	add.w	r5, r3, r6, lsl #2
                t = a[j];
 80011ac:	f858 1f04 	ldr.w	r1, [r8, #4]!
                a[j] = t + a[j + len];
 80011b0:	f8db 3000 	ldr.w	r3, [fp]
 80011b4:	440b      	add	r3, r1
 80011b6:	f8c8 3000 	str.w	r3, [r8]
                a[j + len] = t - a[j + len];
 80011ba:	f85b 0b04 	ldr.w	r0, [fp], #4
 80011be:	1a09      	subs	r1, r1, r0
 80011c0:	f84b 1c04 	str.w	r1, [fp, #-4]
                a[j + len] = PQCLEAN_MLDSA44_CLEAN_montgomery_reduce((int64_t)zeta * a[j + len]);
 80011c4:	fb81 0104 	smull	r0, r1, r1, r4
 80011c8:	f000 fd00 	bl	8001bcc <PQCLEAN_MLDSA44_CLEAN_montgomery_reduce>
            for (j = start; j < start + len; ++j) {
 80011cc:	4545      	cmp	r5, r8
                a[j + len] = PQCLEAN_MLDSA44_CLEAN_montgomery_reduce((int64_t)zeta * a[j + len]);
 80011ce:	f84b 0c04 	str.w	r0, [fp, #-4]
            for (j = start; j < start + len; ++j) {
 80011d2:	d1eb      	bne.n	80011ac <PQCLEAN_MLDSA44_CLEAN_invntt_tomont+0x50>
        for (start = 0; start < N; start = j + len) {
 80011d4:	eb06 0209 	add.w	r2, r6, r9
 80011d8:	2aff      	cmp	r2, #255	; 0xff
 80011da:	d9d2      	bls.n	8001182 <PQCLEAN_MLDSA44_CLEAN_invntt_tomont+0x26>
    for (len = 1; len < N; len <<= 1) {
 80011dc:	9b03      	ldr	r3, [sp, #12]
 80011de:	3b01      	subs	r3, #1
 80011e0:	ea4f 0949 	mov.w	r9, r9, lsl #1
 80011e4:	9303      	str	r3, [sp, #12]
 80011e6:	d1c5      	bne.n	8001174 <PQCLEAN_MLDSA44_CLEAN_invntt_tomont+0x18>
 80011e8:	e9dd 3401 	ldrd	r3, r4, [sp, #4]
            }
        }
    }

    for (j = 0; j < N; ++j) {
        a[j] = PQCLEAN_MLDSA44_CLEAN_montgomery_reduce((int64_t)f * a[j]);
 80011ec:	f24a 35fa 	movw	r5, #41978	; 0xa3fa
 80011f0:	f503 777f 	add.w	r7, r3, #1020	; 0x3fc
 80011f4:	f854 1f04 	ldr.w	r1, [r4, #4]!
 80011f8:	fb81 0105 	smull	r0, r1, r1, r5
 80011fc:	f000 fce6 	bl	8001bcc <PQCLEAN_MLDSA44_CLEAN_montgomery_reduce>
    for (j = 0; j < N; ++j) {
 8001200:	42a7      	cmp	r7, r4
        a[j] = PQCLEAN_MLDSA44_CLEAN_montgomery_reduce((int64_t)f * a[j]);
 8001202:	6020      	str	r0, [r4, #0]
    for (j = 0; j < N; ++j) {
 8001204:	d1f6      	bne.n	80011f4 <PQCLEAN_MLDSA44_CLEAN_invntt_tomont+0x98>
    }
}
 8001206:	b005      	add	sp, #20
 8001208:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            for (j = start; j < start + len; ++j) {
 800120c:	4632      	mov	r2, r6
 800120e:	e7e3      	b.n	80011d8 <PQCLEAN_MLDSA44_CLEAN_invntt_tomont+0x7c>
 8001210:	08004a48 	.word	0x08004a48

08001214 <PQCLEAN_MLDSA44_CLEAN_pack_pk>:
void PQCLEAN_MLDSA44_CLEAN_pack_pk(uint8_t pk[PQCLEAN_MLDSA44_CLEAN_CRYPTO_PUBLICKEYBYTES],
                                   const uint8_t rho[SEEDBYTES],
                                   const polyveck *t1) {
    unsigned int i;

    for (i = 0; i < SEEDBYTES; ++i) {
 8001214:	1c4b      	adds	r3, r1, #1
 8001216:	1ac3      	subs	r3, r0, r3
 8001218:	2b02      	cmp	r3, #2
                                   const polyveck *t1) {
 800121a:	b570      	push	{r4, r5, r6, lr}
 800121c:	4616      	mov	r6, r2
 800121e:	d91e      	bls.n	800125e <PQCLEAN_MLDSA44_CLEAN_pack_pk+0x4a>
        pk[i] = rho[i];
 8001220:	680b      	ldr	r3, [r1, #0]
 8001222:	6003      	str	r3, [r0, #0]
 8001224:	684b      	ldr	r3, [r1, #4]
 8001226:	6043      	str	r3, [r0, #4]
 8001228:	688b      	ldr	r3, [r1, #8]
 800122a:	6083      	str	r3, [r0, #8]
 800122c:	68cb      	ldr	r3, [r1, #12]
 800122e:	60c3      	str	r3, [r0, #12]
 8001230:	690b      	ldr	r3, [r1, #16]
 8001232:	6103      	str	r3, [r0, #16]
 8001234:	694b      	ldr	r3, [r1, #20]
 8001236:	6143      	str	r3, [r0, #20]
 8001238:	698b      	ldr	r3, [r1, #24]
 800123a:	6183      	str	r3, [r0, #24]
 800123c:	69cb      	ldr	r3, [r1, #28]
 800123e:	61c3      	str	r3, [r0, #28]
    for (i = 0; i < SEEDBYTES; ++i) {
 8001240:	f100 0420 	add.w	r4, r0, #32
 8001244:	f500 65a4 	add.w	r5, r0, #1312	; 0x520
    }
    pk += SEEDBYTES;

    for (i = 0; i < K; ++i) {
        PQCLEAN_MLDSA44_CLEAN_polyt1_pack(pk + i * POLYT1_PACKEDBYTES, &t1->vec[i]);
 8001248:	4631      	mov	r1, r6
 800124a:	4620      	mov	r0, r4
    for (i = 0; i < K; ++i) {
 800124c:	f504 74a0 	add.w	r4, r4, #320	; 0x140
        PQCLEAN_MLDSA44_CLEAN_polyt1_pack(pk + i * POLYT1_PACKEDBYTES, &t1->vec[i]);
 8001250:	f000 faa6 	bl	80017a0 <PQCLEAN_MLDSA44_CLEAN_polyt1_pack>
    for (i = 0; i < K; ++i) {
 8001254:	42a5      	cmp	r5, r4
 8001256:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 800125a:	d1f5      	bne.n	8001248 <PQCLEAN_MLDSA44_CLEAN_pack_pk+0x34>
    }
}
 800125c:	bd70      	pop	{r4, r5, r6, pc}
 800125e:	1e4b      	subs	r3, r1, #1
 8001260:	1e42      	subs	r2, r0, #1
 8001262:	f101 041f 	add.w	r4, r1, #31
        pk[i] = rho[i];
 8001266:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 800126a:	f802 1f01 	strb.w	r1, [r2, #1]!
    for (i = 0; i < SEEDBYTES; ++i) {
 800126e:	429c      	cmp	r4, r3
 8001270:	d1f9      	bne.n	8001266 <PQCLEAN_MLDSA44_CLEAN_pack_pk+0x52>
 8001272:	e7e5      	b.n	8001240 <PQCLEAN_MLDSA44_CLEAN_pack_pk+0x2c>

08001274 <PQCLEAN_MLDSA44_CLEAN_pack_sk>:
                                   const uint8_t rho[SEEDBYTES],
                                   const uint8_t tr[TRBYTES],
                                   const uint8_t key[SEEDBYTES],
                                   const polyveck *t0,
                                   const polyvecl *s1,
                                   const polyveck *s2) {
 8001274:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001276:	4605      	mov	r5, r0
 8001278:	1c48      	adds	r0, r1, #1
    unsigned int i;

    for (i = 0; i < SEEDBYTES; ++i) {
 800127a:	1a28      	subs	r0, r5, r0
 800127c:	2802      	cmp	r0, #2
 800127e:	d96f      	bls.n	8001360 <PQCLEAN_MLDSA44_CLEAN_pack_sk+0xec>
        sk[i] = rho[i];
 8001280:	6808      	ldr	r0, [r1, #0]
 8001282:	6028      	str	r0, [r5, #0]
 8001284:	6848      	ldr	r0, [r1, #4]
 8001286:	6068      	str	r0, [r5, #4]
 8001288:	6888      	ldr	r0, [r1, #8]
 800128a:	60a8      	str	r0, [r5, #8]
 800128c:	68c8      	ldr	r0, [r1, #12]
 800128e:	60e8      	str	r0, [r5, #12]
 8001290:	6908      	ldr	r0, [r1, #16]
 8001292:	6128      	str	r0, [r5, #16]
 8001294:	6948      	ldr	r0, [r1, #20]
 8001296:	6168      	str	r0, [r5, #20]
 8001298:	6988      	ldr	r0, [r1, #24]
 800129a:	61a8      	str	r0, [r5, #24]
 800129c:	69c9      	ldr	r1, [r1, #28]
 800129e:	61e9      	str	r1, [r5, #28]
    for (i = 0; i < SEEDBYTES; ++i) {
 80012a0:	1ae9      	subs	r1, r5, r3
 80012a2:	311f      	adds	r1, #31
 80012a4:	2902      	cmp	r1, #2
 80012a6:	d968      	bls.n	800137a <PQCLEAN_MLDSA44_CLEAN_pack_sk+0x106>
    }
    sk += SEEDBYTES;

    for (i = 0; i < SEEDBYTES; ++i) {
        sk[i] = key[i];
 80012a8:	6819      	ldr	r1, [r3, #0]
 80012aa:	6229      	str	r1, [r5, #32]
 80012ac:	6859      	ldr	r1, [r3, #4]
 80012ae:	6269      	str	r1, [r5, #36]	; 0x24
 80012b0:	6899      	ldr	r1, [r3, #8]
 80012b2:	62a9      	str	r1, [r5, #40]	; 0x28
 80012b4:	68d9      	ldr	r1, [r3, #12]
 80012b6:	62e9      	str	r1, [r5, #44]	; 0x2c
 80012b8:	6919      	ldr	r1, [r3, #16]
 80012ba:	6329      	str	r1, [r5, #48]	; 0x30
 80012bc:	6959      	ldr	r1, [r3, #20]
 80012be:	6369      	str	r1, [r5, #52]	; 0x34
 80012c0:	6999      	ldr	r1, [r3, #24]
 80012c2:	63a9      	str	r1, [r5, #56]	; 0x38
 80012c4:	69db      	ldr	r3, [r3, #28]
 80012c6:	63eb      	str	r3, [r5, #60]	; 0x3c
    }
    sk += SEEDBYTES;

    for (i = 0; i < TRBYTES; ++i) {
 80012c8:	1aab      	subs	r3, r5, r2
 80012ca:	333f      	adds	r3, #63	; 0x3f
 80012cc:	2b02      	cmp	r3, #2
 80012ce:	d962      	bls.n	8001396 <PQCLEAN_MLDSA44_CLEAN_pack_sk+0x122>
        sk[i] = tr[i];
 80012d0:	6813      	ldr	r3, [r2, #0]
 80012d2:	642b      	str	r3, [r5, #64]	; 0x40
 80012d4:	6853      	ldr	r3, [r2, #4]
 80012d6:	646b      	str	r3, [r5, #68]	; 0x44
 80012d8:	6893      	ldr	r3, [r2, #8]
 80012da:	64ab      	str	r3, [r5, #72]	; 0x48
 80012dc:	68d3      	ldr	r3, [r2, #12]
 80012de:	64eb      	str	r3, [r5, #76]	; 0x4c
 80012e0:	6913      	ldr	r3, [r2, #16]
 80012e2:	652b      	str	r3, [r5, #80]	; 0x50
 80012e4:	6953      	ldr	r3, [r2, #20]
 80012e6:	656b      	str	r3, [r5, #84]	; 0x54
 80012e8:	6993      	ldr	r3, [r2, #24]
 80012ea:	65ab      	str	r3, [r5, #88]	; 0x58
 80012ec:	69d3      	ldr	r3, [r2, #28]
 80012ee:	65eb      	str	r3, [r5, #92]	; 0x5c
 80012f0:	6a13      	ldr	r3, [r2, #32]
 80012f2:	662b      	str	r3, [r5, #96]	; 0x60
 80012f4:	6a53      	ldr	r3, [r2, #36]	; 0x24
 80012f6:	666b      	str	r3, [r5, #100]	; 0x64
 80012f8:	6a93      	ldr	r3, [r2, #40]	; 0x28
 80012fa:	66ab      	str	r3, [r5, #104]	; 0x68
 80012fc:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 80012fe:	66eb      	str	r3, [r5, #108]	; 0x6c
 8001300:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8001302:	672b      	str	r3, [r5, #112]	; 0x70
 8001304:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8001306:	676b      	str	r3, [r5, #116]	; 0x74
 8001308:	6b93      	ldr	r3, [r2, #56]	; 0x38
 800130a:	67ab      	str	r3, [r5, #120]	; 0x78
 800130c:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 800130e:	67eb      	str	r3, [r5, #124]	; 0x7c
    }
    sk += TRBYTES;

    for (i = 0; i < L; ++i) {
 8001310:	9f07      	ldr	r7, [sp, #28]
 8001312:	f105 0680 	add.w	r6, r5, #128	; 0x80
 8001316:	f505 7400 	add.w	r4, r5, #512	; 0x200
        PQCLEAN_MLDSA44_CLEAN_polyeta_pack(sk + i * POLYETA_PACKEDBYTES, &s1->vec[i]);
 800131a:	4639      	mov	r1, r7
 800131c:	4630      	mov	r0, r6
    for (i = 0; i < L; ++i) {
 800131e:	3660      	adds	r6, #96	; 0x60
        PQCLEAN_MLDSA44_CLEAN_polyeta_pack(sk + i * POLYETA_PACKEDBYTES, &s1->vec[i]);
 8001320:	f000 f9f8 	bl	8001714 <PQCLEAN_MLDSA44_CLEAN_polyeta_pack>
    for (i = 0; i < L; ++i) {
 8001324:	42b4      	cmp	r4, r6
 8001326:	f507 6780 	add.w	r7, r7, #1024	; 0x400
 800132a:	d1f6      	bne.n	800131a <PQCLEAN_MLDSA44_CLEAN_pack_sk+0xa6>
    }
    sk += L * POLYETA_PACKEDBYTES;

    for (i = 0; i < K; ++i) {
 800132c:	9e08      	ldr	r6, [sp, #32]
 800132e:	f505 7760 	add.w	r7, r5, #896	; 0x380
        PQCLEAN_MLDSA44_CLEAN_polyeta_pack(sk + i * POLYETA_PACKEDBYTES, &s2->vec[i]);
 8001332:	4631      	mov	r1, r6
 8001334:	4620      	mov	r0, r4
    for (i = 0; i < K; ++i) {
 8001336:	3460      	adds	r4, #96	; 0x60
        PQCLEAN_MLDSA44_CLEAN_polyeta_pack(sk + i * POLYETA_PACKEDBYTES, &s2->vec[i]);
 8001338:	f000 f9ec 	bl	8001714 <PQCLEAN_MLDSA44_CLEAN_polyeta_pack>
    for (i = 0; i < K; ++i) {
 800133c:	42bc      	cmp	r4, r7
 800133e:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 8001342:	d1f6      	bne.n	8001332 <PQCLEAN_MLDSA44_CLEAN_pack_sk+0xbe>
    }
    sk += K * POLYETA_PACKEDBYTES;

    for (i = 0; i < K; ++i) {
 8001344:	9e06      	ldr	r6, [sp, #24]
 8001346:	f505 6520 	add.w	r5, r5, #2560	; 0xa00
        PQCLEAN_MLDSA44_CLEAN_polyt0_pack(sk + i * POLYT0_PACKEDBYTES, &t0->vec[i]);
 800134a:	4631      	mov	r1, r6
 800134c:	4620      	mov	r0, r4
    for (i = 0; i < K; ++i) {
 800134e:	f504 74d0 	add.w	r4, r4, #416	; 0x1a0
        PQCLEAN_MLDSA44_CLEAN_polyt0_pack(sk + i * POLYT0_PACKEDBYTES, &t0->vec[i]);
 8001352:	f000 fa47 	bl	80017e4 <PQCLEAN_MLDSA44_CLEAN_polyt0_pack>
    for (i = 0; i < K; ++i) {
 8001356:	42ac      	cmp	r4, r5
 8001358:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 800135c:	d1f5      	bne.n	800134a <PQCLEAN_MLDSA44_CLEAN_pack_sk+0xd6>
    }
}
 800135e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001360:	1e48      	subs	r0, r1, #1
 8001362:	1e6c      	subs	r4, r5, #1
 8001364:	311f      	adds	r1, #31
        sk[i] = rho[i];
 8001366:	f810 6f01 	ldrb.w	r6, [r0, #1]!
 800136a:	f804 6f01 	strb.w	r6, [r4, #1]!
    for (i = 0; i < SEEDBYTES; ++i) {
 800136e:	4281      	cmp	r1, r0
 8001370:	d1f9      	bne.n	8001366 <PQCLEAN_MLDSA44_CLEAN_pack_sk+0xf2>
 8001372:	1ae9      	subs	r1, r5, r3
 8001374:	311f      	adds	r1, #31
 8001376:	2902      	cmp	r1, #2
 8001378:	d896      	bhi.n	80012a8 <PQCLEAN_MLDSA44_CLEAN_pack_sk+0x34>
 800137a:	1e59      	subs	r1, r3, #1
 800137c:	f105 001f 	add.w	r0, r5, #31
 8001380:	331f      	adds	r3, #31
        sk[i] = key[i];
 8001382:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8001386:	f800 4f01 	strb.w	r4, [r0, #1]!
    for (i = 0; i < SEEDBYTES; ++i) {
 800138a:	428b      	cmp	r3, r1
 800138c:	d1f9      	bne.n	8001382 <PQCLEAN_MLDSA44_CLEAN_pack_sk+0x10e>
    for (i = 0; i < TRBYTES; ++i) {
 800138e:	1aab      	subs	r3, r5, r2
 8001390:	333f      	adds	r3, #63	; 0x3f
 8001392:	2b02      	cmp	r3, #2
 8001394:	d89c      	bhi.n	80012d0 <PQCLEAN_MLDSA44_CLEAN_pack_sk+0x5c>
 8001396:	1e53      	subs	r3, r2, #1
 8001398:	f105 013f 	add.w	r1, r5, #63	; 0x3f
 800139c:	323f      	adds	r2, #63	; 0x3f
        sk[i] = tr[i];
 800139e:	f813 0f01 	ldrb.w	r0, [r3, #1]!
 80013a2:	f801 0f01 	strb.w	r0, [r1, #1]!
    for (i = 0; i < TRBYTES; ++i) {
 80013a6:	4293      	cmp	r3, r2
 80013a8:	d1f9      	bne.n	800139e <PQCLEAN_MLDSA44_CLEAN_pack_sk+0x12a>
 80013aa:	e7b1      	b.n	8001310 <PQCLEAN_MLDSA44_CLEAN_pack_sk+0x9c>

080013ac <PQCLEAN_MLDSA44_CLEAN_poly_reduce>:
* Description: Inplace reduction of all coefficients of polynomial to
*              representative in [-6283008,6283008].
*
* Arguments:   - poly *a: pointer to input/output polynomial
**************************************************/
void PQCLEAN_MLDSA44_CLEAN_poly_reduce(poly *a) {
 80013ac:	b538      	push	{r3, r4, r5, lr}
 80013ae:	1f04      	subs	r4, r0, #4
 80013b0:	f500 757f 	add.w	r5, r0, #1020	; 0x3fc
    unsigned int i;
    DBENCH_START();

    for (i = 0; i < N; ++i) {
        a->coeffs[i] = PQCLEAN_MLDSA44_CLEAN_reduce32(a->coeffs[i]);
 80013b4:	f854 0f04 	ldr.w	r0, [r4, #4]!
 80013b8:	f000 fc18 	bl	8001bec <PQCLEAN_MLDSA44_CLEAN_reduce32>
    for (i = 0; i < N; ++i) {
 80013bc:	42ac      	cmp	r4, r5
        a->coeffs[i] = PQCLEAN_MLDSA44_CLEAN_reduce32(a->coeffs[i]);
 80013be:	6020      	str	r0, [r4, #0]
    for (i = 0; i < N; ++i) {
 80013c0:	d1f8      	bne.n	80013b4 <PQCLEAN_MLDSA44_CLEAN_poly_reduce+0x8>
    }

    DBENCH_STOP(*tred);
}
 80013c2:	bd38      	pop	{r3, r4, r5, pc}

080013c4 <PQCLEAN_MLDSA44_CLEAN_poly_caddq>:
* Description: For all coefficients of in/out polynomial add Q if
*              coefficient is negative.
*
* Arguments:   - poly *a: pointer to input/output polynomial
**************************************************/
void PQCLEAN_MLDSA44_CLEAN_poly_caddq(poly *a) {
 80013c4:	b538      	push	{r3, r4, r5, lr}
 80013c6:	1f04      	subs	r4, r0, #4
 80013c8:	f500 757f 	add.w	r5, r0, #1020	; 0x3fc
    unsigned int i;
    DBENCH_START();

    for (i = 0; i < N; ++i) {
        a->coeffs[i] = PQCLEAN_MLDSA44_CLEAN_caddq(a->coeffs[i]);
 80013cc:	f854 0f04 	ldr.w	r0, [r4, #4]!
 80013d0:	f000 fc18 	bl	8001c04 <PQCLEAN_MLDSA44_CLEAN_caddq>
    for (i = 0; i < N; ++i) {
 80013d4:	42ac      	cmp	r4, r5
        a->coeffs[i] = PQCLEAN_MLDSA44_CLEAN_caddq(a->coeffs[i]);
 80013d6:	6020      	str	r0, [r4, #0]
    for (i = 0; i < N; ++i) {
 80013d8:	d1f8      	bne.n	80013cc <PQCLEAN_MLDSA44_CLEAN_poly_caddq+0x8>
    }

    DBENCH_STOP(*tred);
}
 80013da:	bd38      	pop	{r3, r4, r5, pc}

080013dc <PQCLEAN_MLDSA44_CLEAN_poly_add>:
*
* Arguments:   - poly *c: pointer to output polynomial
*              - const poly *a: pointer to first summand
*              - const poly *b: pointer to second summand
**************************************************/
void PQCLEAN_MLDSA44_CLEAN_poly_add(poly *c, const poly *a, const poly *b)  {
 80013dc:	b500      	push	{lr}
 80013de:	f1a1 0c04 	sub.w	ip, r1, #4
 80013e2:	f1a2 0e04 	sub.w	lr, r2, #4
 80013e6:	1f02      	subs	r2, r0, #4
 80013e8:	f501 707f 	add.w	r0, r1, #1020	; 0x3fc
    unsigned int i;
    DBENCH_START();

    for (i = 0; i < N; ++i) {
        c->coeffs[i] = a->coeffs[i] + b->coeffs[i];
 80013ec:	f85c 3f04 	ldr.w	r3, [ip, #4]!
 80013f0:	f85e 1f04 	ldr.w	r1, [lr, #4]!
    for (i = 0; i < N; ++i) {
 80013f4:	4584      	cmp	ip, r0
        c->coeffs[i] = a->coeffs[i] + b->coeffs[i];
 80013f6:	440b      	add	r3, r1
 80013f8:	f842 3f04 	str.w	r3, [r2, #4]!
    for (i = 0; i < N; ++i) {
 80013fc:	d1f6      	bne.n	80013ec <PQCLEAN_MLDSA44_CLEAN_poly_add+0x10>
    }

    DBENCH_STOP(*tadd);
}
 80013fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8001402:	bf00      	nop

08001404 <PQCLEAN_MLDSA44_CLEAN_poly_ntt>:
* Arguments:   - poly *a: pointer to input/output polynomial
**************************************************/
void PQCLEAN_MLDSA44_CLEAN_poly_ntt(poly *a) {
    DBENCH_START();

    PQCLEAN_MLDSA44_CLEAN_ntt(a->coeffs);
 8001404:	f7ff be4e 	b.w	80010a4 <PQCLEAN_MLDSA44_CLEAN_ntt>

08001408 <PQCLEAN_MLDSA44_CLEAN_poly_invntt_tomont>:
* Arguments:   - poly *a: pointer to input/output polynomial
**************************************************/
void PQCLEAN_MLDSA44_CLEAN_poly_invntt_tomont(poly *a) {
    DBENCH_START();

    PQCLEAN_MLDSA44_CLEAN_invntt_tomont(a->coeffs);
 8001408:	f7ff bea8 	b.w	800115c <PQCLEAN_MLDSA44_CLEAN_invntt_tomont>

0800140c <PQCLEAN_MLDSA44_CLEAN_poly_pointwise_montgomery>:
*
* Arguments:   - poly *c: pointer to output polynomial
*              - const poly *a: pointer to first input polynomial
*              - const poly *b: pointer to second input polynomial
**************************************************/
void PQCLEAN_MLDSA44_CLEAN_poly_pointwise_montgomery(poly *c, const poly *a, const poly *b) {
 800140c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800140e:	1f0c      	subs	r4, r1, #4
 8001410:	1f16      	subs	r6, r2, #4
 8001412:	1f05      	subs	r5, r0, #4
 8001414:	f501 777f 	add.w	r7, r1, #1020	; 0x3fc
    unsigned int i;
    DBENCH_START();

    for (i = 0; i < N; ++i) {
        c->coeffs[i] = PQCLEAN_MLDSA44_CLEAN_montgomery_reduce((int64_t)a->coeffs[i] * b->coeffs[i]);
 8001418:	f854 1f04 	ldr.w	r1, [r4, #4]!
 800141c:	f856 0f04 	ldr.w	r0, [r6, #4]!
 8001420:	fb81 0100 	smull	r0, r1, r1, r0
 8001424:	f000 fbd2 	bl	8001bcc <PQCLEAN_MLDSA44_CLEAN_montgomery_reduce>
    for (i = 0; i < N; ++i) {
 8001428:	42bc      	cmp	r4, r7
        c->coeffs[i] = PQCLEAN_MLDSA44_CLEAN_montgomery_reduce((int64_t)a->coeffs[i] * b->coeffs[i]);
 800142a:	f845 0f04 	str.w	r0, [r5, #4]!
    for (i = 0; i < N; ++i) {
 800142e:	d1f3      	bne.n	8001418 <PQCLEAN_MLDSA44_CLEAN_poly_pointwise_montgomery+0xc>
    }

    DBENCH_STOP(*tmul);
}
 8001430:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001432:	bf00      	nop

08001434 <PQCLEAN_MLDSA44_CLEAN_poly_power2round>:
*
* Arguments:   - poly *a1: pointer to output polynomial with coefficients c1
*              - poly *a0: pointer to output polynomial with coefficients c0
*              - const poly *a: pointer to input polynomial
**************************************************/
void PQCLEAN_MLDSA44_CLEAN_poly_power2round(poly *a1, poly *a0, const poly *a) {
 8001434:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001436:	1f15      	subs	r5, r2, #4
 8001438:	460c      	mov	r4, r1
 800143a:	1f06      	subs	r6, r0, #4
 800143c:	f502 777f 	add.w	r7, r2, #1020	; 0x3fc
    unsigned int i;
    DBENCH_START();

    for (i = 0; i < N; ++i) {
        a1->coeffs[i] = PQCLEAN_MLDSA44_CLEAN_power2round(&a0->coeffs[i], a->coeffs[i]);
 8001440:	f855 1f04 	ldr.w	r1, [r5, #4]!
 8001444:	4620      	mov	r0, r4
 8001446:	f000 fbe5 	bl	8001c14 <PQCLEAN_MLDSA44_CLEAN_power2round>
    for (i = 0; i < N; ++i) {
 800144a:	42bd      	cmp	r5, r7
        a1->coeffs[i] = PQCLEAN_MLDSA44_CLEAN_power2round(&a0->coeffs[i], a->coeffs[i]);
 800144c:	f846 0f04 	str.w	r0, [r6, #4]!
    for (i = 0; i < N; ++i) {
 8001450:	f104 0404 	add.w	r4, r4, #4
 8001454:	d1f4      	bne.n	8001440 <PQCLEAN_MLDSA44_CLEAN_poly_power2round+0xc>
    }

    DBENCH_STOP(*tround);
}
 8001456:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08001458 <PQCLEAN_MLDSA44_CLEAN_poly_uniform>:
*              - uint16_t nonce: 2-byte nonce
**************************************************/
#define POLY_UNIFORM_NBLOCKS ((768 + STREAM128_BLOCKBYTES - 1)/STREAM128_BLOCKBYTES)
void PQCLEAN_MLDSA44_CLEAN_poly_uniform(poly *a,
                                        const uint8_t seed[SEEDBYTES],
                                        uint16_t nonce) {
 8001458:	b5f0      	push	{r4, r5, r6, r7, lr}
 800145a:	f5ad 7d55 	sub.w	sp, sp, #852	; 0x354
 800145e:	4607      	mov	r7, r0
    unsigned int i, ctr, off;
    unsigned int buflen = POLY_UNIFORM_NBLOCKS * STREAM128_BLOCKBYTES;
    uint8_t buf[POLY_UNIFORM_NBLOCKS * STREAM128_BLOCKBYTES + 2];
    stream128_state state;

    stream128_init(&state, seed, nonce);
 8001460:	4668      	mov	r0, sp
 8001462:	f000 fc63 	bl	8001d2c <PQCLEAN_MLDSA44_CLEAN_dilithium_shake128_stream_init>
    stream128_squeezeblocks(buf, POLY_UNIFORM_NBLOCKS, &state);
 8001466:	466a      	mov	r2, sp
 8001468:	f44f 7152 	mov.w	r1, #840	; 0x348
 800146c:	a801      	add	r0, sp, #4
 800146e:	f001 fea5 	bl	80031bc <shake128_inc_squeeze>
        if (t < Q) {
 8001472:	4d26      	ldr	r5, [pc, #152]	; (800150c <PQCLEAN_MLDSA44_CLEAN_poly_uniform+0xb4>)
 8001474:	aed3      	add	r6, sp, #844	; 0x34c

    ctr = rej_uniform(a->coeffs, N, buf, buflen);
 8001476:	aa01      	add	r2, sp, #4
    ctr = pos = 0;
 8001478:	2400      	movs	r4, #0
 800147a:	e001      	b.n	8001480 <PQCLEAN_MLDSA44_CLEAN_poly_uniform+0x28>
    while (ctr < len && pos + 3 <= buflen) {
 800147c:	4296      	cmp	r6, r2
 800147e:	d018      	beq.n	80014b2 <PQCLEAN_MLDSA44_CLEAN_poly_uniform+0x5a>
        t |= (uint32_t)buf[pos++] << 16;
 8001480:	7893      	ldrb	r3, [r2, #2]
        t |= (uint32_t)buf[pos++] << 8;
 8001482:	7850      	ldrb	r0, [r2, #1]
        t  = buf[pos++];
 8001484:	7811      	ldrb	r1, [r2, #0]
        t |= (uint32_t)buf[pos++] << 16;
 8001486:	041b      	lsls	r3, r3, #16
 8001488:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 800148c:	430b      	orrs	r3, r1
        t &= 0x7FFFFF;
 800148e:	f3c3 0316 	ubfx	r3, r3, #0, #23
        if (t < Q) {
 8001492:	42ab      	cmp	r3, r5
            a[ctr++] = t;
 8001494:	bf9c      	itt	ls
 8001496:	f847 3024 	strls.w	r3, [r7, r4, lsl #2]
 800149a:	3401      	addls	r4, #1
    while (ctr < len && pos + 3 <= buflen) {
 800149c:	f5b4 7f80 	cmp.w	r4, #256	; 0x100
 80014a0:	f102 0203 	add.w	r2, r2, #3
 80014a4:	d1ea      	bne.n	800147c <PQCLEAN_MLDSA44_CLEAN_poly_uniform+0x24>

        stream128_squeezeblocks(buf + off, 1, &state);
        buflen = STREAM128_BLOCKBYTES + off;
        ctr += rej_uniform(a->coeffs + ctr, N - ctr, buf, buflen);
    }
    stream128_release(&state);
 80014a6:	4668      	mov	r0, sp
 80014a8:	f001 ff04 	bl	80032b4 <shake128_inc_ctx_release>
}
 80014ac:	f50d 7d55 	add.w	sp, sp, #852	; 0x354
 80014b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (t < Q) {
 80014b2:	4d16      	ldr	r5, [pc, #88]	; (800150c <PQCLEAN_MLDSA44_CLEAN_poly_uniform+0xb4>)
 80014b4:	ae2b      	add	r6, sp, #172	; 0xac
        stream128_squeezeblocks(buf + off, 1, &state);
 80014b6:	466a      	mov	r2, sp
 80014b8:	21a8      	movs	r1, #168	; 0xa8
 80014ba:	a801      	add	r0, sp, #4
 80014bc:	f001 fe7e 	bl	80031bc <shake128_inc_squeeze>
        ctr += rej_uniform(a->coeffs + ctr, N - ctr, buf, buflen);
 80014c0:	f5c4 7e80 	rsb	lr, r4, #256	; 0x100
 80014c4:	aa01      	add	r2, sp, #4
    ctr = pos = 0;
 80014c6:	2100      	movs	r1, #0
 80014c8:	e001      	b.n	80014ce <PQCLEAN_MLDSA44_CLEAN_poly_uniform+0x76>
    while (ctr < len && pos + 3 <= buflen) {
 80014ca:	4296      	cmp	r6, r2
 80014cc:	d014      	beq.n	80014f8 <PQCLEAN_MLDSA44_CLEAN_poly_uniform+0xa0>
        t |= (uint32_t)buf[pos++] << 16;
 80014ce:	7893      	ldrb	r3, [r2, #2]
        t |= (uint32_t)buf[pos++] << 8;
 80014d0:	f892 c001 	ldrb.w	ip, [r2, #1]
        t  = buf[pos++];
 80014d4:	7810      	ldrb	r0, [r2, #0]
        t |= (uint32_t)buf[pos++] << 16;
 80014d6:	041b      	lsls	r3, r3, #16
 80014d8:	ea43 230c 	orr.w	r3, r3, ip, lsl #8
 80014dc:	4303      	orrs	r3, r0
        t &= 0x7FFFFF;
 80014de:	f3c3 0316 	ubfx	r3, r3, #0, #23
        if (t < Q) {
 80014e2:	42ab      	cmp	r3, r5
            a[ctr++] = t;
 80014e4:	eb04 0001 	add.w	r0, r4, r1
 80014e8:	bf9c      	itt	ls
 80014ea:	3101      	addls	r1, #1
 80014ec:	f847 3020 	strls.w	r3, [r7, r0, lsl #2]
    while (ctr < len && pos + 3 <= buflen) {
 80014f0:	458e      	cmp	lr, r1
 80014f2:	f102 0203 	add.w	r2, r2, #3
 80014f6:	d8e8      	bhi.n	80014ca <PQCLEAN_MLDSA44_CLEAN_poly_uniform+0x72>
        ctr += rej_uniform(a->coeffs + ctr, N - ctr, buf, buflen);
 80014f8:	440c      	add	r4, r1
    while (ctr < N) {
 80014fa:	2cff      	cmp	r4, #255	; 0xff
 80014fc:	d9db      	bls.n	80014b6 <PQCLEAN_MLDSA44_CLEAN_poly_uniform+0x5e>
    stream128_release(&state);
 80014fe:	4668      	mov	r0, sp
 8001500:	f001 fed8 	bl	80032b4 <shake128_inc_ctx_release>
}
 8001504:	f50d 7d55 	add.w	sp, sp, #852	; 0x354
 8001508:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800150a:	bf00      	nop
 800150c:	007fe000 	.word	0x007fe000

08001510 <PQCLEAN_MLDSA44_CLEAN_poly_uniform_eta>:
*              - uint16_t nonce: 2-byte nonce
**************************************************/
#define POLY_UNIFORM_ETA_NBLOCKS ((136 + STREAM256_BLOCKBYTES - 1)/STREAM256_BLOCKBYTES)
void PQCLEAN_MLDSA44_CLEAN_poly_uniform_eta(poly *a,
        const uint8_t seed[CRHBYTES],
        uint16_t nonce) {
 8001510:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8001514:	b0a5      	sub	sp, #148	; 0x94
 8001516:	4605      	mov	r5, r0
    unsigned int ctr;
    unsigned int buflen = POLY_UNIFORM_ETA_NBLOCKS * STREAM256_BLOCKBYTES;
    uint8_t buf[POLY_UNIFORM_ETA_NBLOCKS * STREAM256_BLOCKBYTES];
    stream256_state state;

    stream256_init(&state, seed, nonce);
 8001518:	a801      	add	r0, sp, #4
 800151a:	f000 fc21 	bl	8001d60 <PQCLEAN_MLDSA44_CLEAN_dilithium_shake256_stream_init>
    stream256_squeezeblocks(buf, POLY_UNIFORM_ETA_NBLOCKS, &state);
 800151e:	a802      	add	r0, sp, #8
 8001520:	aa01      	add	r2, sp, #4
 8001522:	2188      	movs	r1, #136	; 0x88
 8001524:	f001 ff12 	bl	800334c <shake256_inc_squeeze>
    while (ctr < len && pos < buflen) {
 8001528:	ac24      	add	r4, sp, #144	; 0x90

    ctr = rej_eta(a->coeffs, N, buf, buflen);
 800152a:	a802      	add	r0, sp, #8
    ctr = pos = 0;
 800152c:	2600      	movs	r6, #0
        t0 = buf[pos] & 0x0F;
 800152e:	f810 2b01 	ldrb.w	r2, [r0], #1
 8001532:	f002 010f 	and.w	r1, r2, #15
            t0 = t0 - (205 * t0 >> 10) * 5;
 8001536:	eb01 0381 	add.w	r3, r1, r1, lsl #2
 800153a:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
 800153e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8001542:	0a9b      	lsrs	r3, r3, #10
 8001544:	eb03 0383 	add.w	r3, r3, r3, lsl #2
            a[ctr++] = 2 - t0;
 8001548:	f1c1 0c02 	rsb	ip, r1, #2
        if (t0 < 15) {
 800154c:	290f      	cmp	r1, #15
            a[ctr++] = 2 - t0;
 800154e:	f106 0701 	add.w	r7, r6, #1
 8001552:	4463      	add	r3, ip
        t1 = buf[pos++] >> 4;
 8001554:	ea4f 1212 	mov.w	r2, r2, lsr #4
        if (t0 < 15) {
 8001558:	d00c      	beq.n	8001574 <PQCLEAN_MLDSA44_CLEAN_poly_uniform_eta+0x64>
        if (t1 < 15 && ctr < len) {
 800155a:	2a0f      	cmp	r2, #15
            a[ctr++] = 2 - t0;
 800155c:	f845 3026 	str.w	r3, [r5, r6, lsl #2]
        if (t1 < 15 && ctr < len) {
 8001560:	d065      	beq.n	800162e <PQCLEAN_MLDSA44_CLEAN_poly_uniform_eta+0x11e>
 8001562:	f5b7 7f80 	cmp.w	r7, #256	; 0x100
 8001566:	d164      	bne.n	8001632 <PQCLEAN_MLDSA44_CLEAN_poly_uniform_eta+0x122>

    while (ctr < N) {
        stream256_squeezeblocks(buf, 1, &state);
        ctr += rej_eta(a->coeffs + ctr, N - ctr, buf, STREAM256_BLOCKBYTES);
    }
    stream256_release(&state);
 8001568:	a801      	add	r0, sp, #4
 800156a:	f001 ff6b 	bl	8003444 <shake256_inc_ctx_release>
}
 800156e:	b025      	add	sp, #148	; 0x94
 8001570:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        if (t1 < 15 && ctr < len) {
 8001574:	2a0f      	cmp	r2, #15
 8001576:	d00e      	beq.n	8001596 <PQCLEAN_MLDSA44_CLEAN_poly_uniform_eta+0x86>
            t1 = t1 - (205 * t1 >> 10) * 5;
 8001578:	eb02 0382 	add.w	r3, r2, r2, lsl #2
 800157c:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8001580:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8001584:	0a9b      	lsrs	r3, r3, #10
 8001586:	eb03 0383 	add.w	r3, r3, r3, lsl #2
            a[ctr++] = 2 - t1;
 800158a:	f1c2 0202 	rsb	r2, r2, #2
 800158e:	441a      	add	r2, r3
 8001590:	f845 2026 	str.w	r2, [r5, r6, lsl #2]
 8001594:	3601      	adds	r6, #1
    while (ctr < len && pos < buflen) {
 8001596:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
 800159a:	d0e5      	beq.n	8001568 <PQCLEAN_MLDSA44_CLEAN_poly_uniform_eta+0x58>
 800159c:	4284      	cmp	r4, r0
 800159e:	d1c6      	bne.n	800152e <PQCLEAN_MLDSA44_CLEAN_poly_uniform_eta+0x1e>
 80015a0:	e008      	b.n	80015b4 <PQCLEAN_MLDSA44_CLEAN_poly_uniform_eta+0xa4>
        if (t1 < 15 && ctr < len) {
 80015a2:	2a0f      	cmp	r2, #15
            a[ctr++] = 2 - t0;
 80015a4:	f848 3020 	str.w	r3, [r8, r0, lsl #2]
        if (t1 < 15 && ctr < len) {
 80015a8:	d03d      	beq.n	8001626 <PQCLEAN_MLDSA44_CLEAN_poly_uniform_eta+0x116>
 80015aa:	4577      	cmp	r7, lr
 80015ac:	d83d      	bhi.n	800162a <PQCLEAN_MLDSA44_CLEAN_poly_uniform_eta+0x11a>
        ctr += rej_eta(a->coeffs + ctr, N - ctr, buf, STREAM256_BLOCKBYTES);
 80015ae:	4476      	add	r6, lr
    while (ctr < N) {
 80015b0:	2eff      	cmp	r6, #255	; 0xff
 80015b2:	d8d9      	bhi.n	8001568 <PQCLEAN_MLDSA44_CLEAN_poly_uniform_eta+0x58>
        stream256_squeezeblocks(buf, 1, &state);
 80015b4:	a802      	add	r0, sp, #8
 80015b6:	aa01      	add	r2, sp, #4
 80015b8:	2188      	movs	r1, #136	; 0x88
 80015ba:	f001 fec7 	bl	800334c <shake256_inc_squeeze>
        ctr += rej_eta(a->coeffs + ctr, N - ctr, buf, STREAM256_BLOCKBYTES);
 80015be:	eb05 0886 	add.w	r8, r5, r6, lsl #2
 80015c2:	f5c6 7780 	rsb	r7, r6, #256	; 0x100
 80015c6:	f10d 0c08 	add.w	ip, sp, #8
    ctr = pos = 0;
 80015ca:	2000      	movs	r0, #0
        t0 = buf[pos] & 0x0F;
 80015cc:	f81c 2b01 	ldrb.w	r2, [ip], #1
 80015d0:	f002 010f 	and.w	r1, r2, #15
            t0 = t0 - (205 * t0 >> 10) * 5;
 80015d4:	eb01 0381 	add.w	r3, r1, r1, lsl #2
 80015d8:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
 80015dc:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80015e0:	0a9b      	lsrs	r3, r3, #10
 80015e2:	eb03 0383 	add.w	r3, r3, r3, lsl #2
            a[ctr++] = 2 - t0;
 80015e6:	f1c1 0902 	rsb	r9, r1, #2
        if (t0 < 15) {
 80015ea:	290f      	cmp	r1, #15
            a[ctr++] = 2 - t0;
 80015ec:	f100 0e01 	add.w	lr, r0, #1
 80015f0:	444b      	add	r3, r9
        t1 = buf[pos++] >> 4;
 80015f2:	ea4f 1212 	mov.w	r2, r2, lsr #4
        if (t0 < 15) {
 80015f6:	d1d4      	bne.n	80015a2 <PQCLEAN_MLDSA44_CLEAN_poly_uniform_eta+0x92>
        if (t1 < 15 && ctr < len) {
 80015f8:	2a0f      	cmp	r2, #15
 80015fa:	d00e      	beq.n	800161a <PQCLEAN_MLDSA44_CLEAN_poly_uniform_eta+0x10a>
            t1 = t1 - (205 * t1 >> 10) * 5;
 80015fc:	eb02 0382 	add.w	r3, r2, r2, lsl #2
 8001600:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8001604:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8001608:	0a9b      	lsrs	r3, r3, #10
 800160a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
            a[ctr++] = 2 - t1;
 800160e:	f1c2 0202 	rsb	r2, r2, #2
 8001612:	4413      	add	r3, r2
 8001614:	f848 3020 	str.w	r3, [r8, r0, lsl #2]
 8001618:	3001      	adds	r0, #1
    while (ctr < len && pos < buflen) {
 800161a:	4287      	cmp	r7, r0
 800161c:	d901      	bls.n	8001622 <PQCLEAN_MLDSA44_CLEAN_poly_uniform_eta+0x112>
 800161e:	4564      	cmp	r4, ip
 8001620:	d1d4      	bne.n	80015cc <PQCLEAN_MLDSA44_CLEAN_poly_uniform_eta+0xbc>
 8001622:	4686      	mov	lr, r0
 8001624:	e7c3      	b.n	80015ae <PQCLEAN_MLDSA44_CLEAN_poly_uniform_eta+0x9e>
            a[ctr++] = 2 - t0;
 8001626:	4670      	mov	r0, lr
 8001628:	e7f7      	b.n	800161a <PQCLEAN_MLDSA44_CLEAN_poly_uniform_eta+0x10a>
 800162a:	4670      	mov	r0, lr
 800162c:	e7e6      	b.n	80015fc <PQCLEAN_MLDSA44_CLEAN_poly_uniform_eta+0xec>
 800162e:	463e      	mov	r6, r7
 8001630:	e7b1      	b.n	8001596 <PQCLEAN_MLDSA44_CLEAN_poly_uniform_eta+0x86>
 8001632:	463e      	mov	r6, r7
 8001634:	e7a0      	b.n	8001578 <PQCLEAN_MLDSA44_CLEAN_poly_uniform_eta+0x68>
 8001636:	bf00      	nop

08001638 <PQCLEAN_MLDSA44_CLEAN_poly_challenge>:
*              SHAKE256(seed).
*
* Arguments:   - poly *c: pointer to output polynomial
*              - const uint8_t mu[]: byte array containing seed of length CTILDEBYTES
**************************************************/
void PQCLEAN_MLDSA44_CLEAN_poly_challenge(poly *c, const uint8_t seed[CTILDEBYTES]) {
 8001638:	b5f0      	push	{r4, r5, r6, r7, lr}
 800163a:	b0a5      	sub	sp, #148	; 0x94
 800163c:	460c      	mov	r4, r1
 800163e:	4607      	mov	r7, r0
    unsigned int i, b, pos;
    uint64_t signs;
    uint8_t buf[SHAKE256_RATE];
    shake256incctx state;

    shake256_inc_init(&state);
 8001640:	a801      	add	r0, sp, #4
 8001642:	f001 fe3b 	bl	80032bc <shake256_inc_init>
    shake256_inc_absorb(&state, seed, CTILDEBYTES);
 8001646:	4621      	mov	r1, r4
 8001648:	2220      	movs	r2, #32
 800164a:	a801      	add	r0, sp, #4
 800164c:	f001 fe4a 	bl	80032e4 <shake256_inc_absorb>
    shake256_inc_finalize(&state);
 8001650:	a801      	add	r0, sp, #4
 8001652:	f001 fe4d 	bl	80032f0 <shake256_inc_finalize>
    shake256_inc_squeeze(buf, sizeof buf, &state);
 8001656:	aa01      	add	r2, sp, #4
 8001658:	2188      	movs	r1, #136	; 0x88
 800165a:	a802      	add	r0, sp, #8
 800165c:	f001 fe76 	bl	800334c <shake256_inc_squeeze>

    signs = 0;
    for (i = 0; i < 8; ++i) {
        signs |= (uint64_t)buf[i] << 8 * i;
 8001660:	f89d 3009 	ldrb.w	r3, [sp, #9]
 8001664:	f89d 5008 	ldrb.w	r5, [sp, #8]
 8001668:	f89d 600c 	ldrb.w	r6, [sp, #12]
 800166c:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
 8001670:	f89d 300a 	ldrb.w	r3, [sp, #10]
 8001674:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 8001678:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800167c:	ea45 6503 	orr.w	r5, r5, r3, lsl #24
 8001680:	f89d 300d 	ldrb.w	r3, [sp, #13]
 8001684:	ea46 2603 	orr.w	r6, r6, r3, lsl #8
 8001688:	f89d 300e 	ldrb.w	r3, [sp, #14]
 800168c:	ea46 4603 	orr.w	r6, r6, r3, lsl #16
 8001690:	f89d 300f 	ldrb.w	r3, [sp, #15]
    }
    pos = 8;

    for (i = 0; i < N; ++i) {
        c->coeffs[i] = 0;
 8001694:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8001698:	2100      	movs	r1, #0
 800169a:	4638      	mov	r0, r7
        signs |= (uint64_t)buf[i] << 8 * i;
 800169c:	ea46 6603 	orr.w	r6, r6, r3, lsl #24
    }
    for (i = N - TAU; i < N; ++i) {
 80016a0:	24d9      	movs	r4, #217	; 0xd9
        c->coeffs[i] = 0;
 80016a2:	f7ff f95f 	bl	8000964 <memset>
    pos = 8;
 80016a6:	f04f 0c08 	mov.w	ip, #8
 80016aa:	e010      	b.n	80016ce <PQCLEAN_MLDSA44_CLEAN_poly_challenge+0x96>
        do {
            if (pos >= SHAKE256_RATE) {
                shake256_inc_squeeze(buf, sizeof buf, &state);
 80016ac:	f001 fe4e 	bl	800334c <shake256_inc_squeeze>
                pos = 0;
            }

            b = buf[pos++];
 80016b0:	f89d 3008 	ldrb.w	r3, [sp, #8]
        } while (b > i);
 80016b4:	429c      	cmp	r4, r3
 80016b6:	f04f 0201 	mov.w	r2, #1
 80016ba:	d211      	bcs.n	80016e0 <PQCLEAN_MLDSA44_CLEAN_poly_challenge+0xa8>
            b = buf[pos++];
 80016bc:	f102 0390 	add.w	r3, r2, #144	; 0x90
 80016c0:	446b      	add	r3, sp
 80016c2:	f102 0c01 	add.w	ip, r2, #1
 80016c6:	f813 3c88 	ldrb.w	r3, [r3, #-136]
        } while (b > i);
 80016ca:	42a3      	cmp	r3, r4
 80016cc:	d909      	bls.n	80016e2 <PQCLEAN_MLDSA44_CLEAN_poly_challenge+0xaa>
            if (pos >= SHAKE256_RATE) {
 80016ce:	f1bc 0f87 	cmp.w	ip, #135	; 0x87
                shake256_inc_squeeze(buf, sizeof buf, &state);
 80016d2:	aa01      	add	r2, sp, #4
 80016d4:	f04f 0188 	mov.w	r1, #136	; 0x88
 80016d8:	a802      	add	r0, sp, #8
            if (pos >= SHAKE256_RATE) {
 80016da:	d8e7      	bhi.n	80016ac <PQCLEAN_MLDSA44_CLEAN_poly_challenge+0x74>
 80016dc:	4662      	mov	r2, ip
 80016de:	e7ed      	b.n	80016bc <PQCLEAN_MLDSA44_CLEAN_poly_challenge+0x84>
        } while (b > i);
 80016e0:	4694      	mov	ip, r2

        c->coeffs[i] = c->coeffs[b];
 80016e2:	f857 1023 	ldr.w	r1, [r7, r3, lsl #2]
 80016e6:	f847 1024 	str.w	r1, [r7, r4, lsl #2]
        c->coeffs[b] = 1 - 2 * (signs & 1);
 80016ea:	f005 0201 	and.w	r2, r5, #1
 80016ee:	0052      	lsls	r2, r2, #1
    for (i = N - TAU; i < N; ++i) {
 80016f0:	3401      	adds	r4, #1
        c->coeffs[b] = 1 - 2 * (signs & 1);
 80016f2:	f1c2 0201 	rsb	r2, r2, #1
        signs >>= 1;
 80016f6:	086d      	lsrs	r5, r5, #1
    for (i = N - TAU; i < N; ++i) {
 80016f8:	f5b4 7f80 	cmp.w	r4, #256	; 0x100
        signs >>= 1;
 80016fc:	ea45 75c6 	orr.w	r5, r5, r6, lsl #31
        c->coeffs[b] = 1 - 2 * (signs & 1);
 8001700:	f847 2023 	str.w	r2, [r7, r3, lsl #2]
        signs >>= 1;
 8001704:	ea4f 0656 	mov.w	r6, r6, lsr #1
    for (i = N - TAU; i < N; ++i) {
 8001708:	d1e1      	bne.n	80016ce <PQCLEAN_MLDSA44_CLEAN_poly_challenge+0x96>
    }
    shake256_inc_ctx_release(&state);
 800170a:	a801      	add	r0, sp, #4
 800170c:	f001 fe9a 	bl	8003444 <shake256_inc_ctx_release>
}
 8001710:	b025      	add	sp, #148	; 0x94
 8001712:	bdf0      	pop	{r4, r5, r6, r7, pc}

08001714 <PQCLEAN_MLDSA44_CLEAN_polyeta_pack>:
*
* Arguments:   - uint8_t *r: pointer to output byte array with at least
*                            POLYETA_PACKEDBYTES bytes
*              - const poly *a: pointer to input polynomial
**************************************************/
void PQCLEAN_MLDSA44_CLEAN_polyeta_pack(uint8_t *r, const poly *a) {
 8001714:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8001718:	f501 6e80 	add.w	lr, r1, #1024	; 0x400
        t[1] = (uint8_t) (ETA - a->coeffs[8 * i + 1]);
        t[2] = (uint8_t) (ETA - a->coeffs[8 * i + 2]);
        t[3] = (uint8_t) (ETA - a->coeffs[8 * i + 3]);
        t[4] = (uint8_t) (ETA - a->coeffs[8 * i + 4]);
        t[5] = (uint8_t) (ETA - a->coeffs[8 * i + 5]);
        t[6] = (uint8_t) (ETA - a->coeffs[8 * i + 6]);
 800171c:	e9d1 6306 	ldrd	r6, r3, [r1, #24]
        t[4] = (uint8_t) (ETA - a->coeffs[8 * i + 4]);
 8001720:	690a      	ldr	r2, [r1, #16]
        t[3] = (uint8_t) (ETA - a->coeffs[8 * i + 3]);
 8001722:	f8d1 c00c 	ldr.w	ip, [r1, #12]
        t[2] = (uint8_t) (ETA - a->coeffs[8 * i + 2]);
 8001726:	688d      	ldr	r5, [r1, #8]
        t[1] = (uint8_t) (ETA - a->coeffs[8 * i + 1]);
 8001728:	684f      	ldr	r7, [r1, #4]
        t[5] = (uint8_t) (ETA - a->coeffs[8 * i + 5]);
 800172a:	694c      	ldr	r4, [r1, #20]
        t[0] = (uint8_t) (ETA - a->coeffs[8 * i + 0]);
 800172c:	f851 8b20 	ldr.w	r8, [r1], #32
        t[4] = (uint8_t) (ETA - a->coeffs[8 * i + 4]);
 8001730:	f1c2 0202 	rsb	r2, r2, #2
        t[3] = (uint8_t) (ETA - a->coeffs[8 * i + 3]);
 8001734:	f1cc 0a02 	rsb	sl, ip, #2
        t[7] = (uint8_t) (ETA - a->coeffs[8 * i + 7]);
 8001738:	f1c3 0302 	rsb	r3, r3, #2
        t[2] = (uint8_t) (ETA - a->coeffs[8 * i + 2]);
 800173c:	f1c5 0502 	rsb	r5, r5, #2
        t[4] = (uint8_t) (ETA - a->coeffs[8 * i + 4]);
 8001740:	b2d2      	uxtb	r2, r2
        t[2] = (uint8_t) (ETA - a->coeffs[8 * i + 2]);
 8001742:	b2ed      	uxtb	r5, r5
        t[1] = (uint8_t) (ETA - a->coeffs[8 * i + 1]);
 8001744:	f1c7 0c02 	rsb	ip, r7, #2
        t[3] = (uint8_t) (ETA - a->coeffs[8 * i + 3]);
 8001748:	fa5f fa8a 	uxtb.w	sl, sl
        t[6] = (uint8_t) (ETA - a->coeffs[8 * i + 6]);
 800174c:	f1c6 0602 	rsb	r6, r6, #2
        t[7] = (uint8_t) (ETA - a->coeffs[8 * i + 7]);
 8001750:	fa5f f983 	uxtb.w	r9, r3

        r[3 * i + 0]  = (t[0] >> 0) | (t[1] << 3) | (t[2] << 6);
        r[3 * i + 1]  = (t[2] >> 2) | (t[3] << 1) | (t[4] << 4) | (t[5] << 7);
 8001754:	0112      	lsls	r2, r2, #4
        r[3 * i + 0]  = (t[0] >> 0) | (t[1] << 3) | (t[2] << 6);
 8001756:	fa5f f78c 	uxtb.w	r7, ip
        t[5] = (uint8_t) (ETA - a->coeffs[8 * i + 5]);
 800175a:	f1c4 0402 	rsb	r4, r4, #2
        t[6] = (uint8_t) (ETA - a->coeffs[8 * i + 6]);
 800175e:	b2f6      	uxtb	r6, r6
        r[3 * i + 0]  = (t[0] >> 0) | (t[1] << 3) | (t[2] << 6);
 8001760:	ea4f 1c85 	mov.w	ip, r5, lsl #6
        r[3 * i + 1]  = (t[2] >> 2) | (t[3] << 1) | (t[4] << 4) | (t[5] << 7);
 8001764:	ea42 024a 	orr.w	r2, r2, sl, lsl #1
        r[3 * i + 2]  = (t[5] >> 1) | (t[6] << 2) | (t[7] << 5);
 8001768:	ea4f 1349 	mov.w	r3, r9, lsl #5
        t[5] = (uint8_t) (ETA - a->coeffs[8 * i + 5]);
 800176c:	b2e4      	uxtb	r4, r4
        r[3 * i + 0]  = (t[0] >> 0) | (t[1] << 3) | (t[2] << 6);
 800176e:	ea4c 0cc7 	orr.w	ip, ip, r7, lsl #3
        r[3 * i + 1]  = (t[2] >> 2) | (t[3] << 1) | (t[4] << 4) | (t[5] << 7);
 8001772:	ea42 0295 	orr.w	r2, r2, r5, lsr #2
        t[0] = (uint8_t) (ETA - a->coeffs[8 * i + 0]);
 8001776:	f1c8 0702 	rsb	r7, r8, #2
        r[3 * i + 2]  = (t[5] >> 1) | (t[6] << 2) | (t[7] << 5);
 800177a:	ea43 0386 	orr.w	r3, r3, r6, lsl #2
        r[3 * i + 0]  = (t[0] >> 0) | (t[1] << 3) | (t[2] << 6);
 800177e:	ea4c 0c07 	orr.w	ip, ip, r7
        r[3 * i + 1]  = (t[2] >> 2) | (t[3] << 1) | (t[4] << 4) | (t[5] << 7);
 8001782:	ea42 12c4 	orr.w	r2, r2, r4, lsl #7
        r[3 * i + 2]  = (t[5] >> 1) | (t[6] << 2) | (t[7] << 5);
 8001786:	ea43 0354 	orr.w	r3, r3, r4, lsr #1
    for (i = 0; i < N / 8; ++i) {
 800178a:	458e      	cmp	lr, r1
        r[3 * i + 0]  = (t[0] >> 0) | (t[1] << 3) | (t[2] << 6);
 800178c:	f880 c000 	strb.w	ip, [r0]
        r[3 * i + 1]  = (t[2] >> 2) | (t[3] << 1) | (t[4] << 4) | (t[5] << 7);
 8001790:	7042      	strb	r2, [r0, #1]
        r[3 * i + 2]  = (t[5] >> 1) | (t[6] << 2) | (t[7] << 5);
 8001792:	7083      	strb	r3, [r0, #2]
    for (i = 0; i < N / 8; ++i) {
 8001794:	f100 0003 	add.w	r0, r0, #3
 8001798:	d1c0      	bne.n	800171c <PQCLEAN_MLDSA44_CLEAN_polyeta_pack+0x8>
    }

    DBENCH_STOP(*tpack);
}
 800179a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800179e:	bf00      	nop

080017a0 <PQCLEAN_MLDSA44_CLEAN_polyt1_pack>:
**************************************************/
void PQCLEAN_MLDSA44_CLEAN_polyt1_pack(uint8_t *r, const poly *a) {
    unsigned int i;
    DBENCH_START();

    for (i = 0; i < N / 4; ++i) {
 80017a0:	f501 6280 	add.w	r2, r1, #1024	; 0x400
        r[5 * i + 0] = (uint8_t) (a->coeffs[4 * i + 0] >> 0);
 80017a4:	680b      	ldr	r3, [r1, #0]
 80017a6:	7003      	strb	r3, [r0, #0]
        r[5 * i + 1] = (uint8_t) ((a->coeffs[4 * i + 0] >> 8) | (a->coeffs[4 * i + 1] << 2));
 80017a8:	684b      	ldr	r3, [r1, #4]
 80017aa:	f8d1 c000 	ldr.w	ip, [r1]
 80017ae:	009b      	lsls	r3, r3, #2
 80017b0:	ea43 232c 	orr.w	r3, r3, ip, asr #8
 80017b4:	7043      	strb	r3, [r0, #1]
        r[5 * i + 2] = (uint8_t) ((a->coeffs[4 * i + 1] >> 6) | (a->coeffs[4 * i + 2] << 4));
 80017b6:	688b      	ldr	r3, [r1, #8]
 80017b8:	f8d1 c004 	ldr.w	ip, [r1, #4]
 80017bc:	011b      	lsls	r3, r3, #4
 80017be:	ea43 13ac 	orr.w	r3, r3, ip, asr #6
 80017c2:	7083      	strb	r3, [r0, #2]
        r[5 * i + 3] = (uint8_t) ((a->coeffs[4 * i + 2] >> 4) | (a->coeffs[4 * i + 3] << 6));
 80017c4:	68cb      	ldr	r3, [r1, #12]
 80017c6:	f8d1 c008 	ldr.w	ip, [r1, #8]
 80017ca:	019b      	lsls	r3, r3, #6
 80017cc:	ea43 132c 	orr.w	r3, r3, ip, asr #4
 80017d0:	70c3      	strb	r3, [r0, #3]
        r[5 * i + 4] = (uint8_t) (a->coeffs[4 * i + 3] >> 2);
 80017d2:	68cb      	ldr	r3, [r1, #12]
    for (i = 0; i < N / 4; ++i) {
 80017d4:	3110      	adds	r1, #16
        r[5 * i + 4] = (uint8_t) (a->coeffs[4 * i + 3] >> 2);
 80017d6:	109b      	asrs	r3, r3, #2
    for (i = 0; i < N / 4; ++i) {
 80017d8:	4291      	cmp	r1, r2
        r[5 * i + 4] = (uint8_t) (a->coeffs[4 * i + 3] >> 2);
 80017da:	7103      	strb	r3, [r0, #4]
    for (i = 0; i < N / 4; ++i) {
 80017dc:	f100 0005 	add.w	r0, r0, #5
 80017e0:	d1e0      	bne.n	80017a4 <PQCLEAN_MLDSA44_CLEAN_polyt1_pack+0x4>
    }

    DBENCH_STOP(*tpack);
}
 80017e2:	4770      	bx	lr

080017e4 <PQCLEAN_MLDSA44_CLEAN_polyt0_pack>:
*
* Arguments:   - uint8_t *r: pointer to output byte array with at least
*                            POLYT0_PACKEDBYTES bytes
*              - const poly *a: pointer to input polynomial
**************************************************/
void PQCLEAN_MLDSA44_CLEAN_polyt0_pack(uint8_t *r, const poly *a) {
 80017e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80017e8:	f500 7ed0 	add.w	lr, r0, #416	; 0x1a0
    DBENCH_START();

    for (i = 0; i < N / 8; ++i) {
        t[0] = (1 << (D - 1)) - a->coeffs[8 * i + 0];
        t[1] = (1 << (D - 1)) - a->coeffs[8 * i + 1];
        t[2] = (1 << (D - 1)) - a->coeffs[8 * i + 2];
 80017ec:	e9d1 4601 	ldrd	r4, r6, [r1, #4]
        t[3] = (1 << (D - 1)) - a->coeffs[8 * i + 3];
        t[4] = (1 << (D - 1)) - a->coeffs[8 * i + 4];
        t[5] = (1 << (D - 1)) - a->coeffs[8 * i + 5];
 80017f0:	e9d1 5704 	ldrd	r5, r7, [r1, #16]
        t[0] = (1 << (D - 1)) - a->coeffs[8 * i + 0];
 80017f4:	f8d1 8000 	ldr.w	r8, [r1]
        t[3] = (1 << (D - 1)) - a->coeffs[8 * i + 3];
 80017f8:	f8d1 c00c 	ldr.w	ip, [r1, #12]
        t[6] = (1 << (D - 1)) - a->coeffs[8 * i + 6];
        t[7] = (1 << (D - 1)) - a->coeffs[8 * i + 7];
 80017fc:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
        t[1] = (1 << (D - 1)) - a->coeffs[8 * i + 1];
 8001800:	f5c4 5480 	rsb	r4, r4, #4096	; 0x1000
        t[0] = (1 << (D - 1)) - a->coeffs[8 * i + 0];
 8001804:	f5c8 5a80 	rsb	sl, r8, #4096	; 0x1000

        r[13 * i + 0]  =  (uint8_t) t[0];
        r[13 * i + 1]  =  (uint8_t) (t[0] >>  8);
        r[13 * i + 1] |=  (uint8_t) (t[1] <<  5);
 8001808:	ea4f 1944 	mov.w	r9, r4, lsl #5
        t[3] = (1 << (D - 1)) - a->coeffs[8 * i + 3];
 800180c:	f5cc 5c80 	rsb	ip, ip, #4096	; 0x1000
        t[4] = (1 << (D - 1)) - a->coeffs[8 * i + 4];
 8001810:	f5c5 5580 	rsb	r5, r5, #4096	; 0x1000
        r[13 * i + 1] |=  (uint8_t) (t[1] <<  5);
 8001814:	ea49 291a 	orr.w	r9, r9, sl, lsr #8
        t[6] = (1 << (D - 1)) - a->coeffs[8 * i + 6];
 8001818:	f5c2 5280 	rsb	r2, r2, #4096	; 0x1000
        r[13 * i + 0]  =  (uint8_t) t[0];
 800181c:	f880 a000 	strb.w	sl, [r0]
        r[13 * i + 1] |=  (uint8_t) (t[1] <<  5);
 8001820:	f880 9001 	strb.w	r9, [r0, #1]
        t[2] = (1 << (D - 1)) - a->coeffs[8 * i + 2];
 8001824:	f5c6 5680 	rsb	r6, r6, #4096	; 0x1000
        r[13 * i + 2]  =  (uint8_t) (t[1] >>  3);
        r[13 * i + 3]  =  (uint8_t) (t[1] >> 11);
        r[13 * i + 3] |=  (uint8_t) (t[2] <<  2);
        r[13 * i + 4]  =  (uint8_t) (t[2] >>  6);
        r[13 * i + 4] |=  (uint8_t) (t[3] <<  7);
 8001828:	ea4f 19cc 	mov.w	r9, ip, lsl #7
        r[13 * i + 5]  =  (uint8_t) (t[3] >>  1);
        r[13 * i + 6]  =  (uint8_t) (t[3] >>  9);
        r[13 * i + 6] |=  (uint8_t) (t[4] <<  4);
 800182c:	ea4f 1a05 	mov.w	sl, r5, lsl #4
        t[5] = (1 << (D - 1)) - a->coeffs[8 * i + 5];
 8001830:	f5c7 5780 	rsb	r7, r7, #4096	; 0x1000
        t[7] = (1 << (D - 1)) - a->coeffs[8 * i + 7];
 8001834:	f5c3 5380 	rsb	r3, r3, #4096	; 0x1000
        r[13 * i + 3] |=  (uint8_t) (t[2] <<  2);
 8001838:	ea4f 0886 	mov.w	r8, r6, lsl #2
        r[13 * i + 6] |=  (uint8_t) (t[4] <<  4);
 800183c:	ea4a 2a5c 	orr.w	sl, sl, ip, lsr #9
        r[13 * i + 4] |=  (uint8_t) (t[3] <<  7);
 8001840:	ea49 1696 	orr.w	r6, r9, r6, lsr #6
        r[13 * i + 5]  =  (uint8_t) (t[3] >>  1);
 8001844:	ea4f 095c 	mov.w	r9, ip, lsr #1
        r[13 * i + 7]  =  (uint8_t) (t[4] >>  4);
        r[13 * i + 8]  =  (uint8_t) (t[4] >> 12);
        r[13 * i + 8] |=  (uint8_t) (t[5] <<  1);
        r[13 * i + 9]  =  (uint8_t) (t[5] >>  7);
        r[13 * i + 9] |=  (uint8_t) (t[6] <<  6);
 8001848:	ea4f 1c82 	mov.w	ip, r2, lsl #6
        r[13 * i + 2]  =  (uint8_t) (t[1] >>  3);
 800184c:	ea4f 0bd4 	mov.w	fp, r4, lsr #3
        r[13 * i + 3] |=  (uint8_t) (t[2] <<  2);
 8001850:	ea48 28d4 	orr.w	r8, r8, r4, lsr #11
        r[13 * i + 8] |=  (uint8_t) (t[5] <<  1);
 8001854:	007c      	lsls	r4, r7, #1
        r[13 * i + 9] |=  (uint8_t) (t[6] <<  6);
 8001856:	ea4c 17d7 	orr.w	r7, ip, r7, lsr #7
        r[13 * i + 10]  =  (uint8_t) (t[6] >>  2);
        r[13 * i + 11]  =  (uint8_t) (t[6] >> 10);
        r[13 * i + 11] |=  (uint8_t) (t[7] <<  3);
 800185a:	ea4f 0cc3 	mov.w	ip, r3, lsl #3
        r[13 * i + 2]  =  (uint8_t) (t[1] >>  3);
 800185e:	f880 b002 	strb.w	fp, [r0, #2]
        r[13 * i + 8] |=  (uint8_t) (t[5] <<  1);
 8001862:	ea44 3415 	orr.w	r4, r4, r5, lsr #12
        r[13 * i + 7]  =  (uint8_t) (t[4] >>  4);
 8001866:	ea4f 1b15 	mov.w	fp, r5, lsr #4
        r[13 * i + 12]  =  (uint8_t) (t[7] >>  5);
 800186a:	095b      	lsrs	r3, r3, #5
        r[13 * i + 10]  =  (uint8_t) (t[6] >>  2);
 800186c:	0895      	lsrs	r5, r2, #2
        r[13 * i + 11] |=  (uint8_t) (t[7] <<  3);
 800186e:	ea4c 2292 	orr.w	r2, ip, r2, lsr #10
        r[13 * i + 7]  =  (uint8_t) (t[4] >>  4);
 8001872:	f880 b007 	strb.w	fp, [r0, #7]
        r[13 * i + 3] |=  (uint8_t) (t[2] <<  2);
 8001876:	f880 8003 	strb.w	r8, [r0, #3]
        r[13 * i + 4] |=  (uint8_t) (t[3] <<  7);
 800187a:	7106      	strb	r6, [r0, #4]
        r[13 * i + 5]  =  (uint8_t) (t[3] >>  1);
 800187c:	f880 9005 	strb.w	r9, [r0, #5]
        r[13 * i + 6] |=  (uint8_t) (t[4] <<  4);
 8001880:	f880 a006 	strb.w	sl, [r0, #6]
        r[13 * i + 8] |=  (uint8_t) (t[5] <<  1);
 8001884:	7204      	strb	r4, [r0, #8]
        r[13 * i + 9] |=  (uint8_t) (t[6] <<  6);
 8001886:	7247      	strb	r7, [r0, #9]
        r[13 * i + 10]  =  (uint8_t) (t[6] >>  2);
 8001888:	7285      	strb	r5, [r0, #10]
        r[13 * i + 11] |=  (uint8_t) (t[7] <<  3);
 800188a:	72c2      	strb	r2, [r0, #11]
        r[13 * i + 12]  =  (uint8_t) (t[7] >>  5);
 800188c:	7303      	strb	r3, [r0, #12]
    for (i = 0; i < N / 8; ++i) {
 800188e:	300d      	adds	r0, #13
 8001890:	4586      	cmp	lr, r0
 8001892:	f101 0120 	add.w	r1, r1, #32
 8001896:	d1a9      	bne.n	80017ec <PQCLEAN_MLDSA44_CLEAN_polyt0_pack+0x8>
    }

    DBENCH_STOP(*tpack);
}
 8001898:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800189c <PQCLEAN_MLDSA44_CLEAN_polyz_unpack>:
*              in [-(GAMMA1 - 1), GAMMA1].
*
* Arguments:   - poly *r: pointer to output polynomial
*              - const uint8_t *a: byte array with bit-packed polynomial
**************************************************/
void PQCLEAN_MLDSA44_CLEAN_polyz_unpack(poly *r, const uint8_t *a) {
 800189c:	b530      	push	{r4, r5, lr}
 800189e:	f501 7c10 	add.w	ip, r1, #576	; 0x240
    unsigned int i;
    DBENCH_START();

    for (i = 0; i < N / 4; ++i) {
        r->coeffs[4 * i + 0]  = a[9 * i + 0];
 80018a2:	780c      	ldrb	r4, [r1, #0]
 80018a4:	6004      	str	r4, [r0, #0]
        r->coeffs[4 * i + 0] |= (uint32_t)a[9 * i + 1] << 8;
 80018a6:	784b      	ldrb	r3, [r1, #1]
 80018a8:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
 80018ac:	6004      	str	r4, [r0, #0]
        r->coeffs[4 * i + 0] |= (uint32_t)a[9 * i + 2] << 16;
 80018ae:	788b      	ldrb	r3, [r1, #2]
 80018b0:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
        r->coeffs[4 * i + 0] &= 0x3FFFF;
 80018b4:	f3c4 0411 	ubfx	r4, r4, #0, #18
 80018b8:	6004      	str	r4, [r0, #0]

        r->coeffs[4 * i + 1]  = a[9 * i + 2] >> 2;
 80018ba:	788a      	ldrb	r2, [r1, #2]
 80018bc:	0892      	lsrs	r2, r2, #2
 80018be:	6042      	str	r2, [r0, #4]
        r->coeffs[4 * i + 1] |= (uint32_t)a[9 * i + 3] << 6;
 80018c0:	78cb      	ldrb	r3, [r1, #3]
 80018c2:	ea42 1283 	orr.w	r2, r2, r3, lsl #6
 80018c6:	6042      	str	r2, [r0, #4]
        r->coeffs[4 * i + 1] |= (uint32_t)a[9 * i + 4] << 14;
 80018c8:	790b      	ldrb	r3, [r1, #4]
 80018ca:	ea42 3283 	orr.w	r2, r2, r3, lsl #14
    for (i = 0; i < N / 4; ++i) {
 80018ce:	3109      	adds	r1, #9
        r->coeffs[4 * i + 1] &= 0x3FFFF;
 80018d0:	f3c2 0211 	ubfx	r2, r2, #0, #18
 80018d4:	6042      	str	r2, [r0, #4]

        r->coeffs[4 * i + 2]  = a[9 * i + 4] >> 4;
 80018d6:	f811 3c05 	ldrb.w	r3, [r1, #-5]
 80018da:	091b      	lsrs	r3, r3, #4
 80018dc:	6083      	str	r3, [r0, #8]
        r->coeffs[4 * i + 2] |= (uint32_t)a[9 * i + 5] << 4;
 80018de:	f811 5c04 	ldrb.w	r5, [r1, #-4]
    for (i = 0; i < N / 4; ++i) {
 80018e2:	3010      	adds	r0, #16
        r->coeffs[4 * i + 2] |= (uint32_t)a[9 * i + 5] << 4;
 80018e4:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
 80018e8:	f840 3c08 	str.w	r3, [r0, #-8]
        r->coeffs[4 * i + 2] |= (uint32_t)a[9 * i + 6] << 12;
 80018ec:	f811 5c03 	ldrb.w	r5, [r1, #-3]
 80018f0:	ea43 3305 	orr.w	r3, r3, r5, lsl #12
        r->coeffs[4 * i + 2] &= 0x3FFFF;
 80018f4:	f3c3 0311 	ubfx	r3, r3, #0, #18
 80018f8:	f840 3c08 	str.w	r3, [r0, #-8]

        r->coeffs[4 * i + 3]  = a[9 * i + 6] >> 6;
 80018fc:	f811 5c03 	ldrb.w	r5, [r1, #-3]
 8001900:	09ad      	lsrs	r5, r5, #6
 8001902:	f840 5c04 	str.w	r5, [r0, #-4]
        r->coeffs[4 * i + 3] |= (uint32_t)a[9 * i + 7] << 2;
 8001906:	f811 ec02 	ldrb.w	lr, [r1, #-2]
 800190a:	ea45 058e 	orr.w	r5, r5, lr, lsl #2
 800190e:	f840 5c04 	str.w	r5, [r0, #-4]
        r->coeffs[4 * i + 3] |= (uint32_t)a[9 * i + 8] << 10;
 8001912:	f811 ec01 	ldrb.w	lr, [r1, #-1]
 8001916:	ea45 258e 	orr.w	r5, r5, lr, lsl #10
        r->coeffs[4 * i + 3] &= 0x3FFFF;

        r->coeffs[4 * i + 0] = GAMMA1 - r->coeffs[4 * i + 0];
 800191a:	f5c4 3400 	rsb	r4, r4, #131072	; 0x20000
        r->coeffs[4 * i + 1] = GAMMA1 - r->coeffs[4 * i + 1];
 800191e:	f5c2 3200 	rsb	r2, r2, #131072	; 0x20000
        r->coeffs[4 * i + 2] = GAMMA1 - r->coeffs[4 * i + 2];
 8001922:	f5c3 3300 	rsb	r3, r3, #131072	; 0x20000
        r->coeffs[4 * i + 3] = GAMMA1 - r->coeffs[4 * i + 3];
 8001926:	f5c5 3500 	rsb	r5, r5, #131072	; 0x20000
    for (i = 0; i < N / 4; ++i) {
 800192a:	458c      	cmp	ip, r1
        r->coeffs[4 * i + 2] = GAMMA1 - r->coeffs[4 * i + 2];
 800192c:	e940 2303 	strd	r2, r3, [r0, #-12]
        r->coeffs[4 * i + 0] = GAMMA1 - r->coeffs[4 * i + 0];
 8001930:	f840 4c10 	str.w	r4, [r0, #-16]
        r->coeffs[4 * i + 3] = GAMMA1 - r->coeffs[4 * i + 3];
 8001934:	f840 5c04 	str.w	r5, [r0, #-4]
    for (i = 0; i < N / 4; ++i) {
 8001938:	d1b3      	bne.n	80018a2 <PQCLEAN_MLDSA44_CLEAN_polyz_unpack+0x6>
    }

    DBENCH_STOP(*tpack);
}
 800193a:	bd30      	pop	{r4, r5, pc}

0800193c <PQCLEAN_MLDSA44_CLEAN_poly_uniform_gamma1>:
        uint16_t nonce) {
 800193c:	b510      	push	{r4, lr}
 800193e:	f5ad 7d2c 	sub.w	sp, sp, #688	; 0x2b0
 8001942:	4604      	mov	r4, r0
    stream256_init(&state, seed, nonce);
 8001944:	a801      	add	r0, sp, #4
 8001946:	f000 fa0b 	bl	8001d60 <PQCLEAN_MLDSA44_CLEAN_dilithium_shake256_stream_init>
    stream256_squeezeblocks(buf, POLY_UNIFORM_GAMMA1_NBLOCKS, &state);
 800194a:	aa01      	add	r2, sp, #4
 800194c:	f44f 712a 	mov.w	r1, #680	; 0x2a8
 8001950:	a802      	add	r0, sp, #8
 8001952:	f001 fcfb 	bl	800334c <shake256_inc_squeeze>
    stream256_release(&state);
 8001956:	a801      	add	r0, sp, #4
 8001958:	f001 fd74 	bl	8003444 <shake256_inc_ctx_release>
    PQCLEAN_MLDSA44_CLEAN_polyz_unpack(a, buf);
 800195c:	a902      	add	r1, sp, #8
 800195e:	4620      	mov	r0, r4
 8001960:	f7ff ff9c 	bl	800189c <PQCLEAN_MLDSA44_CLEAN_polyz_unpack>
}
 8001964:	f50d 7d2c 	add.w	sp, sp, #688	; 0x2b0
 8001968:	bd10      	pop	{r4, pc}
 800196a:	bf00      	nop

0800196c <PQCLEAN_MLDSA44_CLEAN_polyvec_matrix_expand>:
*              sampling on the output stream of SHAKE128(rho|j|i)
*
* Arguments:   - polyvecl mat[K]: output matrix
*              - const uint8_t rho[]: byte array containing seed rho
**************************************************/
void PQCLEAN_MLDSA44_CLEAN_polyvec_matrix_expand(polyvecl mat[K], const uint8_t rho[SEEDBYTES]) {
 800196c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001970:	4688      	mov	r8, r1
 8001972:	f500 5680 	add.w	r6, r0, #4096	; 0x1000
 8001976:	2700      	movs	r7, #0
    unsigned int i, j;

    for (i = 0; i < K; ++i) {
        for (j = 0; j < L; ++j) {
 8001978:	f5a6 5580 	sub.w	r5, r6, #4096	; 0x1000
void PQCLEAN_MLDSA44_CLEAN_polyvec_matrix_expand(polyvecl mat[K], const uint8_t rho[SEEDBYTES]) {
 800197c:	463c      	mov	r4, r7
            PQCLEAN_MLDSA44_CLEAN_poly_uniform(&mat[i].vec[j], rho, (uint16_t) ((i << 8) + j));
 800197e:	4622      	mov	r2, r4
 8001980:	4628      	mov	r0, r5
 8001982:	4641      	mov	r1, r8
        for (j = 0; j < L; ++j) {
 8001984:	f505 6580 	add.w	r5, r5, #1024	; 0x400
            PQCLEAN_MLDSA44_CLEAN_poly_uniform(&mat[i].vec[j], rho, (uint16_t) ((i << 8) + j));
 8001988:	f7ff fd66 	bl	8001458 <PQCLEAN_MLDSA44_CLEAN_poly_uniform>
        for (j = 0; j < L; ++j) {
 800198c:	3401      	adds	r4, #1
 800198e:	42ae      	cmp	r6, r5
 8001990:	b2a4      	uxth	r4, r4
 8001992:	d1f4      	bne.n	800197e <PQCLEAN_MLDSA44_CLEAN_polyvec_matrix_expand+0x12>
    for (i = 0; i < K; ++i) {
 8001994:	f507 7780 	add.w	r7, r7, #256	; 0x100
 8001998:	b2bf      	uxth	r7, r7
 800199a:	f5b7 6f80 	cmp.w	r7, #1024	; 0x400
 800199e:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
 80019a2:	d1e9      	bne.n	8001978 <PQCLEAN_MLDSA44_CLEAN_polyvec_matrix_expand+0xc>
        }
    }
}
 80019a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080019a8 <PQCLEAN_MLDSA44_CLEAN_polyvecl_uniform_eta>:

/**************************************************************/
/************ Vectors of polynomials of length L **************/
/**************************************************************/

void PQCLEAN_MLDSA44_CLEAN_polyvecl_uniform_eta(polyvecl *v, const uint8_t seed[CRHBYTES], uint16_t nonce) {
 80019a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80019aa:	4605      	mov	r5, r0
 80019ac:	460e      	mov	r6, r1
 80019ae:	4614      	mov	r4, r2
    unsigned int i;

    for (i = 0; i < L; ++i) {
 80019b0:	f500 5780 	add.w	r7, r0, #4096	; 0x1000
        PQCLEAN_MLDSA44_CLEAN_poly_uniform_eta(&v->vec[i], seed, nonce++);
 80019b4:	4622      	mov	r2, r4
 80019b6:	4628      	mov	r0, r5
 80019b8:	4631      	mov	r1, r6
    for (i = 0; i < L; ++i) {
 80019ba:	f505 6580 	add.w	r5, r5, #1024	; 0x400
        PQCLEAN_MLDSA44_CLEAN_poly_uniform_eta(&v->vec[i], seed, nonce++);
 80019be:	f7ff fda7 	bl	8001510 <PQCLEAN_MLDSA44_CLEAN_poly_uniform_eta>
 80019c2:	3401      	adds	r4, #1
    for (i = 0; i < L; ++i) {
 80019c4:	42bd      	cmp	r5, r7
        PQCLEAN_MLDSA44_CLEAN_poly_uniform_eta(&v->vec[i], seed, nonce++);
 80019c6:	b2a4      	uxth	r4, r4
    for (i = 0; i < L; ++i) {
 80019c8:	d1f4      	bne.n	80019b4 <PQCLEAN_MLDSA44_CLEAN_polyvecl_uniform_eta+0xc>
    }
}
 80019ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080019cc <PQCLEAN_MLDSA44_CLEAN_polyvecl_uniform_gamma1>:

void PQCLEAN_MLDSA44_CLEAN_polyvecl_uniform_gamma1(polyvecl *v, const uint8_t seed[CRHBYTES], uint16_t nonce) {
    unsigned int i;

    for (i = 0; i < L; ++i) {
        PQCLEAN_MLDSA44_CLEAN_poly_uniform_gamma1(&v->vec[i], seed, (uint16_t) (L * nonce + i));
 80019cc:	0092      	lsls	r2, r2, #2
void PQCLEAN_MLDSA44_CLEAN_polyvecl_uniform_gamma1(polyvecl *v, const uint8_t seed[CRHBYTES], uint16_t nonce) {
 80019ce:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80019d0:	4605      	mov	r5, r0
 80019d2:	460e      	mov	r6, r1
        PQCLEAN_MLDSA44_CLEAN_poly_uniform_gamma1(&v->vec[i], seed, (uint16_t) (L * nonce + i));
 80019d4:	b294      	uxth	r4, r2
 80019d6:	f500 5780 	add.w	r7, r0, #4096	; 0x1000
 80019da:	4622      	mov	r2, r4
 80019dc:	4628      	mov	r0, r5
 80019de:	4631      	mov	r1, r6
    for (i = 0; i < L; ++i) {
 80019e0:	f505 6580 	add.w	r5, r5, #1024	; 0x400
        PQCLEAN_MLDSA44_CLEAN_poly_uniform_gamma1(&v->vec[i], seed, (uint16_t) (L * nonce + i));
 80019e4:	f7ff ffaa 	bl	800193c <PQCLEAN_MLDSA44_CLEAN_poly_uniform_gamma1>
    for (i = 0; i < L; ++i) {
 80019e8:	3401      	adds	r4, #1
 80019ea:	42bd      	cmp	r5, r7
 80019ec:	b2a4      	uxth	r4, r4
 80019ee:	d1f4      	bne.n	80019da <PQCLEAN_MLDSA44_CLEAN_polyvecl_uniform_gamma1+0xe>
    }
}
 80019f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80019f2:	bf00      	nop

080019f4 <PQCLEAN_MLDSA44_CLEAN_polyvecl_reduce>:

void PQCLEAN_MLDSA44_CLEAN_polyvecl_reduce(polyvecl *v) {
 80019f4:	b510      	push	{r4, lr}
 80019f6:	4604      	mov	r4, r0
    unsigned int i;

    for (i = 0; i < L; ++i) {
        PQCLEAN_MLDSA44_CLEAN_poly_reduce(&v->vec[i]);
 80019f8:	f7ff fcd8 	bl	80013ac <PQCLEAN_MLDSA44_CLEAN_poly_reduce>
 80019fc:	f504 6080 	add.w	r0, r4, #1024	; 0x400
 8001a00:	f7ff fcd4 	bl	80013ac <PQCLEAN_MLDSA44_CLEAN_poly_reduce>
 8001a04:	f504 6000 	add.w	r0, r4, #2048	; 0x800
 8001a08:	f7ff fcd0 	bl	80013ac <PQCLEAN_MLDSA44_CLEAN_poly_reduce>
 8001a0c:	f504 6040 	add.w	r0, r4, #3072	; 0xc00
    }
}
 8001a10:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        PQCLEAN_MLDSA44_CLEAN_poly_reduce(&v->vec[i]);
 8001a14:	f7ff bcca 	b.w	80013ac <PQCLEAN_MLDSA44_CLEAN_poly_reduce>

08001a18 <PQCLEAN_MLDSA44_CLEAN_polyvecl_add>:
*
* Arguments:   - polyvecl *w: pointer to output vector
*              - const polyvecl *u: pointer to first summand
*              - const polyvecl *v: pointer to second summand
**************************************************/
void PQCLEAN_MLDSA44_CLEAN_polyvecl_add(polyvecl *w, const polyvecl *u, const polyvecl *v) {
 8001a18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001a1a:	4607      	mov	r7, r0
 8001a1c:	460e      	mov	r6, r1
 8001a1e:	4615      	mov	r5, r2
 8001a20:	2400      	movs	r4, #0
    unsigned int i;

    for (i = 0; i < L; ++i) {
        PQCLEAN_MLDSA44_CLEAN_poly_add(&w->vec[i], &u->vec[i], &v->vec[i]);
 8001a22:	192a      	adds	r2, r5, r4
 8001a24:	1931      	adds	r1, r6, r4
 8001a26:	1938      	adds	r0, r7, r4
    for (i = 0; i < L; ++i) {
 8001a28:	f504 6480 	add.w	r4, r4, #1024	; 0x400
        PQCLEAN_MLDSA44_CLEAN_poly_add(&w->vec[i], &u->vec[i], &v->vec[i]);
 8001a2c:	f7ff fcd6 	bl	80013dc <PQCLEAN_MLDSA44_CLEAN_poly_add>
    for (i = 0; i < L; ++i) {
 8001a30:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
 8001a34:	d1f5      	bne.n	8001a22 <PQCLEAN_MLDSA44_CLEAN_polyvecl_add+0xa>
    }
}
 8001a36:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08001a38 <PQCLEAN_MLDSA44_CLEAN_polyvecl_ntt>:
* Description: Forward NTT of all polynomials in vector of length L. Output
*              coefficients can be up to 16*Q larger than input coefficients.
*
* Arguments:   - polyvecl *v: pointer to input/output vector
**************************************************/
void PQCLEAN_MLDSA44_CLEAN_polyvecl_ntt(polyvecl *v) {
 8001a38:	b510      	push	{r4, lr}
 8001a3a:	4604      	mov	r4, r0
    unsigned int i;

    for (i = 0; i < L; ++i) {
        PQCLEAN_MLDSA44_CLEAN_poly_ntt(&v->vec[i]);
 8001a3c:	f7ff fce2 	bl	8001404 <PQCLEAN_MLDSA44_CLEAN_poly_ntt>
 8001a40:	f504 6080 	add.w	r0, r4, #1024	; 0x400
 8001a44:	f7ff fcde 	bl	8001404 <PQCLEAN_MLDSA44_CLEAN_poly_ntt>
 8001a48:	f504 6000 	add.w	r0, r4, #2048	; 0x800
 8001a4c:	f7ff fcda 	bl	8001404 <PQCLEAN_MLDSA44_CLEAN_poly_ntt>
 8001a50:	f504 6040 	add.w	r0, r4, #3072	; 0xc00
    }
}
 8001a54:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        PQCLEAN_MLDSA44_CLEAN_poly_ntt(&v->vec[i]);
 8001a58:	f7ff bcd4 	b.w	8001404 <PQCLEAN_MLDSA44_CLEAN_poly_ntt>

08001a5c <PQCLEAN_MLDSA44_CLEAN_polyvecl_invntt_tomont>:

void PQCLEAN_MLDSA44_CLEAN_polyvecl_invntt_tomont(polyvecl *v) {
 8001a5c:	b510      	push	{r4, lr}
 8001a5e:	4604      	mov	r4, r0
    unsigned int i;

    for (i = 0; i < L; ++i) {
        PQCLEAN_MLDSA44_CLEAN_poly_invntt_tomont(&v->vec[i]);
 8001a60:	f7ff fcd2 	bl	8001408 <PQCLEAN_MLDSA44_CLEAN_poly_invntt_tomont>
 8001a64:	f504 6080 	add.w	r0, r4, #1024	; 0x400
 8001a68:	f7ff fcce 	bl	8001408 <PQCLEAN_MLDSA44_CLEAN_poly_invntt_tomont>
 8001a6c:	f504 6000 	add.w	r0, r4, #2048	; 0x800
 8001a70:	f7ff fcca 	bl	8001408 <PQCLEAN_MLDSA44_CLEAN_poly_invntt_tomont>
 8001a74:	f504 6040 	add.w	r0, r4, #3072	; 0xc00
    }
}
 8001a78:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        PQCLEAN_MLDSA44_CLEAN_poly_invntt_tomont(&v->vec[i]);
 8001a7c:	f7ff bcc4 	b.w	8001408 <PQCLEAN_MLDSA44_CLEAN_poly_invntt_tomont>

08001a80 <PQCLEAN_MLDSA44_CLEAN_polyvecl_pointwise_poly_montgomery>:

void PQCLEAN_MLDSA44_CLEAN_polyvecl_pointwise_poly_montgomery(polyvecl *r, const poly *a, const polyvecl *v) {
 8001a80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001a82:	4607      	mov	r7, r0
 8001a84:	460e      	mov	r6, r1
 8001a86:	4615      	mov	r5, r2
 8001a88:	2400      	movs	r4, #0
    unsigned int i;

    for (i = 0; i < L; ++i) {
        PQCLEAN_MLDSA44_CLEAN_poly_pointwise_montgomery(&r->vec[i], a, &v->vec[i]);
 8001a8a:	192a      	adds	r2, r5, r4
 8001a8c:	1938      	adds	r0, r7, r4
 8001a8e:	4631      	mov	r1, r6
    for (i = 0; i < L; ++i) {
 8001a90:	f504 6480 	add.w	r4, r4, #1024	; 0x400
        PQCLEAN_MLDSA44_CLEAN_poly_pointwise_montgomery(&r->vec[i], a, &v->vec[i]);
 8001a94:	f7ff fcba 	bl	800140c <PQCLEAN_MLDSA44_CLEAN_poly_pointwise_montgomery>
    for (i = 0; i < L; ++i) {
 8001a98:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
 8001a9c:	d1f5      	bne.n	8001a8a <PQCLEAN_MLDSA44_CLEAN_polyvecl_pointwise_poly_montgomery+0xa>
    }
}
 8001a9e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08001aa0 <PQCLEAN_MLDSA44_CLEAN_polyvecl_pointwise_acc_montgomery>:
*              - const polyvecl *u: pointer to first input vector
*              - const polyvecl *v: pointer to second input vector
**************************************************/
void PQCLEAN_MLDSA44_CLEAN_polyvecl_pointwise_acc_montgomery(poly *w,
        const polyvecl *u,
        const polyvecl *v) {
 8001aa0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001aa2:	f2ad 4d04 	subw	sp, sp, #1028	; 0x404
 8001aa6:	4605      	mov	r5, r0
 8001aa8:	460f      	mov	r7, r1
 8001aaa:	4616      	mov	r6, r2
    unsigned int i;
    poly t;

    PQCLEAN_MLDSA44_CLEAN_poly_pointwise_montgomery(w, &u->vec[0], &v->vec[0]);
 8001aac:	f7ff fcae 	bl	800140c <PQCLEAN_MLDSA44_CLEAN_poly_pointwise_montgomery>
 8001ab0:	f44f 6480 	mov.w	r4, #1024	; 0x400
    for (i = 1; i < L; ++i) {
        PQCLEAN_MLDSA44_CLEAN_poly_pointwise_montgomery(&t, &u->vec[i], &v->vec[i]);
 8001ab4:	1932      	adds	r2, r6, r4
 8001ab6:	1939      	adds	r1, r7, r4
 8001ab8:	4668      	mov	r0, sp
 8001aba:	f7ff fca7 	bl	800140c <PQCLEAN_MLDSA44_CLEAN_poly_pointwise_montgomery>
    for (i = 1; i < L; ++i) {
 8001abe:	f504 6480 	add.w	r4, r4, #1024	; 0x400
        PQCLEAN_MLDSA44_CLEAN_poly_add(w, w, &t);
 8001ac2:	466a      	mov	r2, sp
 8001ac4:	4629      	mov	r1, r5
 8001ac6:	4628      	mov	r0, r5
 8001ac8:	f7ff fc88 	bl	80013dc <PQCLEAN_MLDSA44_CLEAN_poly_add>
    for (i = 1; i < L; ++i) {
 8001acc:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
 8001ad0:	d1f0      	bne.n	8001ab4 <PQCLEAN_MLDSA44_CLEAN_polyvecl_pointwise_acc_montgomery+0x14>
    }
}
 8001ad2:	f20d 4d04 	addw	sp, sp, #1028	; 0x404
 8001ad6:	bdf0      	pop	{r4, r5, r6, r7, pc}

08001ad8 <PQCLEAN_MLDSA44_CLEAN_polyvec_matrix_pointwise_montgomery>:
void PQCLEAN_MLDSA44_CLEAN_polyvec_matrix_pointwise_montgomery(polyveck *t, const polyvecl mat[K], const polyvecl *v) {
 8001ad8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001ada:	4604      	mov	r4, r0
 8001adc:	4616      	mov	r6, r2
 8001ade:	460d      	mov	r5, r1
 8001ae0:	f500 5780 	add.w	r7, r0, #4096	; 0x1000
        PQCLEAN_MLDSA44_CLEAN_polyvecl_pointwise_acc_montgomery(&t->vec[i], &mat[i], v);
 8001ae4:	4629      	mov	r1, r5
 8001ae6:	4620      	mov	r0, r4
 8001ae8:	4632      	mov	r2, r6
    for (i = 0; i < K; ++i) {
 8001aea:	f504 6480 	add.w	r4, r4, #1024	; 0x400
        PQCLEAN_MLDSA44_CLEAN_polyvecl_pointwise_acc_montgomery(&t->vec[i], &mat[i], v);
 8001aee:	f7ff ffd7 	bl	8001aa0 <PQCLEAN_MLDSA44_CLEAN_polyvecl_pointwise_acc_montgomery>
    for (i = 0; i < K; ++i) {
 8001af2:	42bc      	cmp	r4, r7
 8001af4:	f505 5580 	add.w	r5, r5, #4096	; 0x1000
 8001af8:	d1f4      	bne.n	8001ae4 <PQCLEAN_MLDSA44_CLEAN_polyvec_matrix_pointwise_montgomery+0xc>
}
 8001afa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08001afc <PQCLEAN_MLDSA44_CLEAN_polyveck_uniform_eta>:

/**************************************************************/
/************ Vectors of polynomials of length K **************/
/**************************************************************/

void PQCLEAN_MLDSA44_CLEAN_polyveck_uniform_eta(polyveck *v, const uint8_t seed[CRHBYTES], uint16_t nonce) {
 8001afc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001afe:	4605      	mov	r5, r0
 8001b00:	460e      	mov	r6, r1
 8001b02:	4614      	mov	r4, r2
    unsigned int i;

    for (i = 0; i < K; ++i) {
 8001b04:	f500 5780 	add.w	r7, r0, #4096	; 0x1000
        PQCLEAN_MLDSA44_CLEAN_poly_uniform_eta(&v->vec[i], seed, nonce++);
 8001b08:	4622      	mov	r2, r4
 8001b0a:	4628      	mov	r0, r5
 8001b0c:	4631      	mov	r1, r6
    for (i = 0; i < K; ++i) {
 8001b0e:	f505 6580 	add.w	r5, r5, #1024	; 0x400
        PQCLEAN_MLDSA44_CLEAN_poly_uniform_eta(&v->vec[i], seed, nonce++);
 8001b12:	f7ff fcfd 	bl	8001510 <PQCLEAN_MLDSA44_CLEAN_poly_uniform_eta>
 8001b16:	3401      	adds	r4, #1
    for (i = 0; i < K; ++i) {
 8001b18:	42bd      	cmp	r5, r7
        PQCLEAN_MLDSA44_CLEAN_poly_uniform_eta(&v->vec[i], seed, nonce++);
 8001b1a:	b2a4      	uxth	r4, r4
    for (i = 0; i < K; ++i) {
 8001b1c:	d1f4      	bne.n	8001b08 <PQCLEAN_MLDSA44_CLEAN_polyveck_uniform_eta+0xc>
    }
}
 8001b1e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08001b20 <PQCLEAN_MLDSA44_CLEAN_polyveck_reduce>:
* Description: Reduce coefficients of polynomials in vector of length K
*              to representatives in [-6283008,6283008].
*
* Arguments:   - polyveck *v: pointer to input/output vector
**************************************************/
void PQCLEAN_MLDSA44_CLEAN_polyveck_reduce(polyveck *v) {
 8001b20:	b510      	push	{r4, lr}
 8001b22:	4604      	mov	r4, r0
    unsigned int i;

    for (i = 0; i < K; ++i) {
        PQCLEAN_MLDSA44_CLEAN_poly_reduce(&v->vec[i]);
 8001b24:	f7ff fc42 	bl	80013ac <PQCLEAN_MLDSA44_CLEAN_poly_reduce>
 8001b28:	f504 6080 	add.w	r0, r4, #1024	; 0x400
 8001b2c:	f7ff fc3e 	bl	80013ac <PQCLEAN_MLDSA44_CLEAN_poly_reduce>
 8001b30:	f504 6000 	add.w	r0, r4, #2048	; 0x800
 8001b34:	f7ff fc3a 	bl	80013ac <PQCLEAN_MLDSA44_CLEAN_poly_reduce>
 8001b38:	f504 6040 	add.w	r0, r4, #3072	; 0xc00
    }
}
 8001b3c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        PQCLEAN_MLDSA44_CLEAN_poly_reduce(&v->vec[i]);
 8001b40:	f7ff bc34 	b.w	80013ac <PQCLEAN_MLDSA44_CLEAN_poly_reduce>

08001b44 <PQCLEAN_MLDSA44_CLEAN_polyveck_caddq>:
* Description: For all coefficients of polynomials in vector of length K
*              add Q if coefficient is negative.
*
* Arguments:   - polyveck *v: pointer to input/output vector
**************************************************/
void PQCLEAN_MLDSA44_CLEAN_polyveck_caddq(polyveck *v) {
 8001b44:	b510      	push	{r4, lr}
 8001b46:	4604      	mov	r4, r0
    unsigned int i;

    for (i = 0; i < K; ++i) {
        PQCLEAN_MLDSA44_CLEAN_poly_caddq(&v->vec[i]);
 8001b48:	f7ff fc3c 	bl	80013c4 <PQCLEAN_MLDSA44_CLEAN_poly_caddq>
 8001b4c:	f504 6080 	add.w	r0, r4, #1024	; 0x400
 8001b50:	f7ff fc38 	bl	80013c4 <PQCLEAN_MLDSA44_CLEAN_poly_caddq>
 8001b54:	f504 6000 	add.w	r0, r4, #2048	; 0x800
 8001b58:	f7ff fc34 	bl	80013c4 <PQCLEAN_MLDSA44_CLEAN_poly_caddq>
 8001b5c:	f504 6040 	add.w	r0, r4, #3072	; 0xc00
    }
}
 8001b60:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        PQCLEAN_MLDSA44_CLEAN_poly_caddq(&v->vec[i]);
 8001b64:	f7ff bc2e 	b.w	80013c4 <PQCLEAN_MLDSA44_CLEAN_poly_caddq>

08001b68 <PQCLEAN_MLDSA44_CLEAN_polyveck_add>:
*
* Arguments:   - polyveck *w: pointer to output vector
*              - const polyveck *u: pointer to first summand
*              - const polyveck *v: pointer to second summand
**************************************************/
void PQCLEAN_MLDSA44_CLEAN_polyveck_add(polyveck *w, const polyveck *u, const polyveck *v) {
 8001b68:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001b6a:	4607      	mov	r7, r0
 8001b6c:	460e      	mov	r6, r1
 8001b6e:	4615      	mov	r5, r2
 8001b70:	2400      	movs	r4, #0
    unsigned int i;

    for (i = 0; i < K; ++i) {
        PQCLEAN_MLDSA44_CLEAN_poly_add(&w->vec[i], &u->vec[i], &v->vec[i]);
 8001b72:	192a      	adds	r2, r5, r4
 8001b74:	1931      	adds	r1, r6, r4
 8001b76:	1938      	adds	r0, r7, r4
    for (i = 0; i < K; ++i) {
 8001b78:	f504 6480 	add.w	r4, r4, #1024	; 0x400
        PQCLEAN_MLDSA44_CLEAN_poly_add(&w->vec[i], &u->vec[i], &v->vec[i]);
 8001b7c:	f7ff fc2e 	bl	80013dc <PQCLEAN_MLDSA44_CLEAN_poly_add>
    for (i = 0; i < K; ++i) {
 8001b80:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
 8001b84:	d1f5      	bne.n	8001b72 <PQCLEAN_MLDSA44_CLEAN_polyveck_add+0xa>
    }
}
 8001b86:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08001b88 <PQCLEAN_MLDSA44_CLEAN_polyveck_invntt_tomont>:
*              in vector of length K. Input coefficients need to be less
*              than 2*Q.
*
* Arguments:   - polyveck *v: pointer to input/output vector
**************************************************/
void PQCLEAN_MLDSA44_CLEAN_polyveck_invntt_tomont(polyveck *v) {
 8001b88:	b510      	push	{r4, lr}
 8001b8a:	4604      	mov	r4, r0
    unsigned int i;

    for (i = 0; i < K; ++i) {
        PQCLEAN_MLDSA44_CLEAN_poly_invntt_tomont(&v->vec[i]);
 8001b8c:	f7ff fc3c 	bl	8001408 <PQCLEAN_MLDSA44_CLEAN_poly_invntt_tomont>
 8001b90:	f504 6080 	add.w	r0, r4, #1024	; 0x400
 8001b94:	f7ff fc38 	bl	8001408 <PQCLEAN_MLDSA44_CLEAN_poly_invntt_tomont>
 8001b98:	f504 6000 	add.w	r0, r4, #2048	; 0x800
 8001b9c:	f7ff fc34 	bl	8001408 <PQCLEAN_MLDSA44_CLEAN_poly_invntt_tomont>
 8001ba0:	f504 6040 	add.w	r0, r4, #3072	; 0xc00
    }
}
 8001ba4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        PQCLEAN_MLDSA44_CLEAN_poly_invntt_tomont(&v->vec[i]);
 8001ba8:	f7ff bc2e 	b.w	8001408 <PQCLEAN_MLDSA44_CLEAN_poly_invntt_tomont>

08001bac <PQCLEAN_MLDSA44_CLEAN_polyveck_power2round>:
*                              coefficients a1
*              - polyveck *v0: pointer to output vector of polynomials with
*                              coefficients a0
*              - const polyveck *v: pointer to input vector
**************************************************/
void PQCLEAN_MLDSA44_CLEAN_polyveck_power2round(polyveck *v1, polyveck *v0, const polyveck *v) {
 8001bac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001bae:	4607      	mov	r7, r0
 8001bb0:	460e      	mov	r6, r1
 8001bb2:	4615      	mov	r5, r2
 8001bb4:	2400      	movs	r4, #0
    unsigned int i;

    for (i = 0; i < K; ++i) {
        PQCLEAN_MLDSA44_CLEAN_poly_power2round(&v1->vec[i], &v0->vec[i], &v->vec[i]);
 8001bb6:	192a      	adds	r2, r5, r4
 8001bb8:	1931      	adds	r1, r6, r4
 8001bba:	1938      	adds	r0, r7, r4
    for (i = 0; i < K; ++i) {
 8001bbc:	f504 6480 	add.w	r4, r4, #1024	; 0x400
        PQCLEAN_MLDSA44_CLEAN_poly_power2round(&v1->vec[i], &v0->vec[i], &v->vec[i]);
 8001bc0:	f7ff fc38 	bl	8001434 <PQCLEAN_MLDSA44_CLEAN_poly_power2round>
    for (i = 0; i < K; ++i) {
 8001bc4:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
 8001bc8:	d1f5      	bne.n	8001bb6 <PQCLEAN_MLDSA44_CLEAN_polyveck_power2round+0xa>
    }
}
 8001bca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08001bcc <PQCLEAN_MLDSA44_CLEAN_montgomery_reduce>:
* Returns r.
**************************************************/
int32_t PQCLEAN_MLDSA44_CLEAN_montgomery_reduce(int64_t a) {
    int32_t t;

    t = (int32_t)((uint64_t)a * (uint64_t)QINV);
 8001bcc:	ebc0 02c0 	rsb	r2, r0, r0, lsl #3
int32_t PQCLEAN_MLDSA44_CLEAN_montgomery_reduce(int64_t a) {
 8001bd0:	4603      	mov	r3, r0
 8001bd2:	b410      	push	{r4}
    t = (int32_t)((uint64_t)a * (uint64_t)QINV);
 8001bd4:	eb00 2282 	add.w	r2, r0, r2, lsl #10
    t = (a - (int64_t)t * Q) >> 32;
 8001bd8:	4c03      	ldr	r4, [pc, #12]	; (8001be8 <PQCLEAN_MLDSA44_CLEAN_montgomery_reduce+0x1c>)
int32_t PQCLEAN_MLDSA44_CLEAN_montgomery_reduce(int64_t a) {
 8001bda:	4608      	mov	r0, r1
    t = (int32_t)((uint64_t)a * (uint64_t)QINV);
 8001bdc:	eb03 3242 	add.w	r2, r3, r2, lsl #13
    return t;
}
 8001be0:	fbc2 3004 	smlal	r3, r0, r2, r4
 8001be4:	bc10      	pop	{r4}
 8001be6:	4770      	bx	lr
 8001be8:	ff801fff 	.word	0xff801fff

08001bec <PQCLEAN_MLDSA44_CLEAN_reduce32>:
* Returns r.
**************************************************/
int32_t PQCLEAN_MLDSA44_CLEAN_reduce32(int32_t a) {
    int32_t t;

    t = (a + (1 << 22)) >> 23;
 8001bec:	f500 0380 	add.w	r3, r0, #4194304	; 0x400000
 8001bf0:	15db      	asrs	r3, r3, #23
    t = a - t * Q;
 8001bf2:	ebc3 2243 	rsb	r2, r3, r3, lsl #9
 8001bf6:	eb03 2282 	add.w	r2, r3, r2, lsl #10
 8001bfa:	ebc3 3342 	rsb	r3, r3, r2, lsl #13
    return t;
}
 8001bfe:	4418      	add	r0, r3
 8001c00:	4770      	bx	lr
 8001c02:	bf00      	nop

08001c04 <PQCLEAN_MLDSA44_CLEAN_caddq>:
* Arguments:   - int32_t: finite field element a
*
* Returns r.
**************************************************/
int32_t PQCLEAN_MLDSA44_CLEAN_caddq(int32_t a) {
    a += (a >> 31) & Q;
 8001c04:	4b02      	ldr	r3, [pc, #8]	; (8001c10 <PQCLEAN_MLDSA44_CLEAN_caddq+0xc>)
 8001c06:	ea03 73e0 	and.w	r3, r3, r0, asr #31
    return a;
}
 8001c0a:	4418      	add	r0, r3
 8001c0c:	4770      	bx	lr
 8001c0e:	bf00      	nop
 8001c10:	007fe001 	.word	0x007fe001

08001c14 <PQCLEAN_MLDSA44_CLEAN_power2round>:
* Returns a1.
**************************************************/
int32_t PQCLEAN_MLDSA44_CLEAN_power2round(int32_t *a0, int32_t a)  {
    int32_t a1;

    a1 = (a + (1 << (D - 1)) - 1) >> D;
 8001c14:	f601 72ff 	addw	r2, r1, #4095	; 0xfff
    *a0 = a - (a1 << D);
 8001c18:	f422 53ff 	bic.w	r3, r2, #8160	; 0x1fe0
 8001c1c:	f023 031f 	bic.w	r3, r3, #31
 8001c20:	1ac9      	subs	r1, r1, r3
 8001c22:	6001      	str	r1, [r0, #0]
    return a1;
}
 8001c24:	1350      	asrs	r0, r2, #13
 8001c26:	4770      	bx	lr

08001c28 <PQCLEAN_MLDSA44_CLEAN_crypto_sign_keypair>:
*              - uint8_t *sk: pointer to output private key (allocated
*                             array of PQCLEAN_MLDSA44_CLEAN_CRYPTO_SECRETKEYBYTES bytes)
*
* Returns 0 (success)
**************************************************/
int PQCLEAN_MLDSA44_CLEAN_crypto_sign_keypair(uint8_t *pk, uint8_t *sk) {
 8001c28:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001c2c:	f5ad 4d10 	sub.w	sp, sp, #36864	; 0x9000
 8001c30:	b0b4      	sub	sp, #208	; 0xd0
    polyvecl mat[K];
    polyvecl s1, s1hat;
    polyveck s2, t1, t0;

    /* Get randomness for rho, rhoprime and key */
    randombytes(seedbuf, SEEDBYTES);
 8001c32:	ac34      	add	r4, sp, #208	; 0xd0
    seedbuf[SEEDBYTES + 0] = K;
 8001c34:	4626      	mov	r6, r4
int PQCLEAN_MLDSA44_CLEAN_crypto_sign_keypair(uint8_t *pk, uint8_t *sk) {
 8001c36:	4605      	mov	r5, r0
 8001c38:	460f      	mov	r7, r1
    randombytes(seedbuf, SEEDBYTES);
 8001c3a:	a814      	add	r0, sp, #80	; 0x50
 8001c3c:	2120      	movs	r1, #32
 8001c3e:	f001 fcab 	bl	8003598 <PQCLEAN_randombytes>
    seedbuf[SEEDBYTES + 1] = L;
    shake256(seedbuf, 2 * SEEDBYTES + CRHBYTES, seedbuf, SEEDBYTES + 2);
 8001c42:	aa14      	add	r2, sp, #80	; 0x50
    seedbuf[SEEDBYTES + 0] = K;
 8001c44:	f240 4304 	movw	r3, #1028	; 0x404
 8001c48:	f826 3d60 	strh.w	r3, [r6, #-96]!
    shake256(seedbuf, 2 * SEEDBYTES + CRHBYTES, seedbuf, SEEDBYTES + 2);
 8001c4c:	4610      	mov	r0, r2
 8001c4e:	2322      	movs	r3, #34	; 0x22
 8001c50:	2180      	movs	r1, #128	; 0x80
 8001c52:	f001 fbfb 	bl	800344c <shake256>
    rho = seedbuf;
    rhoprime = rho + SEEDBYTES;
    key = rhoprime + CRHBYTES;

    /* Expand matrix */
    PQCLEAN_MLDSA44_CLEAN_polyvec_matrix_expand(mat, rho);
 8001c56:	f50d 40a1 	add.w	r0, sp, #20608	; 0x5080
 8001c5a:	a914      	add	r1, sp, #80	; 0x50
 8001c5c:	3050      	adds	r0, #80	; 0x50

    /* Sample short vectors s1 and s2 */
    PQCLEAN_MLDSA44_CLEAN_polyvecl_uniform_eta(&s1, rhoprime, 0);
    PQCLEAN_MLDSA44_CLEAN_polyveck_uniform_eta(&s2, rhoprime, L);
 8001c5e:	f50d 5803 	add.w	r8, sp, #8384	; 0x20c0
    PQCLEAN_MLDSA44_CLEAN_polyvec_matrix_expand(mat, rho);
 8001c62:	f7ff fe83 	bl	800196c <PQCLEAN_MLDSA44_CLEAN_polyvec_matrix_expand>
    PQCLEAN_MLDSA44_CLEAN_polyveck_uniform_eta(&s2, rhoprime, L);
 8001c66:	f108 0810 	add.w	r8, r8, #16
    PQCLEAN_MLDSA44_CLEAN_polyvecl_uniform_eta(&s1, rhoprime, 0);
 8001c6a:	4631      	mov	r1, r6
 8001c6c:	4620      	mov	r0, r4
 8001c6e:	2200      	movs	r2, #0
 8001c70:	f7ff fe9a 	bl	80019a8 <PQCLEAN_MLDSA44_CLEAN_polyvecl_uniform_eta>
    PQCLEAN_MLDSA44_CLEAN_polyveck_uniform_eta(&s2, rhoprime, L);
 8001c74:	4631      	mov	r1, r6
 8001c76:	4640      	mov	r0, r8
 8001c78:	2204      	movs	r2, #4
 8001c7a:	f7ff ff3f 	bl	8001afc <PQCLEAN_MLDSA44_CLEAN_polyveck_uniform_eta>

    /* Matrix-vector multiplication */
    s1hat = s1;
 8001c7e:	f50d 5086 	add.w	r0, sp, #4288	; 0x10c0
 8001c82:	4621      	mov	r1, r4
 8001c84:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8001c88:	3010      	adds	r0, #16
 8001c8a:	f7fe fdd1 	bl	8000830 <memcpy>
    PQCLEAN_MLDSA44_CLEAN_polyvecl_ntt(&s1hat);
 8001c8e:	f50d 5086 	add.w	r0, sp, #4288	; 0x10c0
 8001c92:	3010      	adds	r0, #16
 8001c94:	f7ff fed0 	bl	8001a38 <PQCLEAN_MLDSA44_CLEAN_polyvecl_ntt>
    PQCLEAN_MLDSA44_CLEAN_polyvec_matrix_pointwise_montgomery(&t1, mat, &s1hat);
 8001c98:	f50d 5286 	add.w	r2, sp, #4288	; 0x10c0
 8001c9c:	f50d 41a1 	add.w	r1, sp, #20608	; 0x5080
 8001ca0:	f50d 5043 	add.w	r0, sp, #12480	; 0x30c0
 8001ca4:	3210      	adds	r2, #16
 8001ca6:	3150      	adds	r1, #80	; 0x50
 8001ca8:	3010      	adds	r0, #16
 8001caa:	f7ff ff15 	bl	8001ad8 <PQCLEAN_MLDSA44_CLEAN_polyvec_matrix_pointwise_montgomery>
    PQCLEAN_MLDSA44_CLEAN_polyveck_reduce(&t1);
 8001cae:	f50d 5043 	add.w	r0, sp, #12480	; 0x30c0
 8001cb2:	3010      	adds	r0, #16
 8001cb4:	f7ff ff34 	bl	8001b20 <PQCLEAN_MLDSA44_CLEAN_polyveck_reduce>
    PQCLEAN_MLDSA44_CLEAN_polyveck_invntt_tomont(&t1);
 8001cb8:	f50d 5043 	add.w	r0, sp, #12480	; 0x30c0
 8001cbc:	3010      	adds	r0, #16
 8001cbe:	f7ff ff63 	bl	8001b88 <PQCLEAN_MLDSA44_CLEAN_polyveck_invntt_tomont>

    /* Add error vector s2 */
    PQCLEAN_MLDSA44_CLEAN_polyveck_add(&t1, &t1, &s2);
 8001cc2:	f50d 5143 	add.w	r1, sp, #12480	; 0x30c0
 8001cc6:	3110      	adds	r1, #16
 8001cc8:	4642      	mov	r2, r8
 8001cca:	4608      	mov	r0, r1
 8001ccc:	f7ff ff4c 	bl	8001b68 <PQCLEAN_MLDSA44_CLEAN_polyveck_add>

    /* Extract t1 and write public key */
    PQCLEAN_MLDSA44_CLEAN_polyveck_caddq(&t1);
 8001cd0:	f50d 5043 	add.w	r0, sp, #12480	; 0x30c0
 8001cd4:	3010      	adds	r0, #16
 8001cd6:	f7ff ff35 	bl	8001b44 <PQCLEAN_MLDSA44_CLEAN_polyveck_caddq>
    PQCLEAN_MLDSA44_CLEAN_polyveck_power2round(&t1, &t0, &t1);
 8001cda:	f50d 4681 	add.w	r6, sp, #16512	; 0x4080
 8001cde:	f50d 5243 	add.w	r2, sp, #12480	; 0x30c0
 8001ce2:	3650      	adds	r6, #80	; 0x50
 8001ce4:	3210      	adds	r2, #16
 8001ce6:	4631      	mov	r1, r6
 8001ce8:	4610      	mov	r0, r2
 8001cea:	f7ff ff5f 	bl	8001bac <PQCLEAN_MLDSA44_CLEAN_polyveck_power2round>
    PQCLEAN_MLDSA44_CLEAN_pack_pk(pk, rho, &t1);
 8001cee:	f50d 5243 	add.w	r2, sp, #12480	; 0x30c0
 8001cf2:	a914      	add	r1, sp, #80	; 0x50
 8001cf4:	4628      	mov	r0, r5
 8001cf6:	3210      	adds	r2, #16
 8001cf8:	f7ff fa8c 	bl	8001214 <PQCLEAN_MLDSA44_CLEAN_pack_pk>

    /* Compute H(rho, t1) and write secret key */
    shake256(tr, TRBYTES, pk, PQCLEAN_MLDSA44_CLEAN_CRYPTO_PUBLICKEYBYTES);
 8001cfc:	462a      	mov	r2, r5
 8001cfe:	a804      	add	r0, sp, #16
 8001d00:	f44f 63a4 	mov.w	r3, #1312	; 0x520
 8001d04:	2140      	movs	r1, #64	; 0x40
 8001d06:	f001 fba1 	bl	800344c <shake256>
    PQCLEAN_MLDSA44_CLEAN_pack_sk(sk, rho, tr, key, &t0, &s1, &s2);
 8001d0a:	4638      	mov	r0, r7
 8001d0c:	e9cd 6400 	strd	r6, r4, [sp]
 8001d10:	f8cd 8008 	str.w	r8, [sp, #8]
 8001d14:	ab2c      	add	r3, sp, #176	; 0xb0
 8001d16:	aa04      	add	r2, sp, #16
 8001d18:	a914      	add	r1, sp, #80	; 0x50
 8001d1a:	f7ff faab 	bl	8001274 <PQCLEAN_MLDSA44_CLEAN_pack_sk>

    return 0;
}
 8001d1e:	2000      	movs	r0, #0
 8001d20:	f50d 4d10 	add.w	sp, sp, #36864	; 0x9000
 8001d24:	b034      	add	sp, #208	; 0xd0
 8001d26:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001d2a:	bf00      	nop

08001d2c <PQCLEAN_MLDSA44_CLEAN_dilithium_shake128_stream_init>:
#include "fips202.h"
#include "params.h"
#include "symmetric.h"
#include <stdint.h>

void PQCLEAN_MLDSA44_CLEAN_dilithium_shake128_stream_init(shake128incctx *state, const uint8_t seed[SEEDBYTES], uint16_t nonce) {
 8001d2c:	b530      	push	{r4, r5, lr}
 8001d2e:	b083      	sub	sp, #12
    uint8_t t[2];
    t[0] = (uint8_t) nonce;
    t[1] = (uint8_t) (nonce >> 8);
 8001d30:	0a13      	lsrs	r3, r2, #8
void PQCLEAN_MLDSA44_CLEAN_dilithium_shake128_stream_init(shake128incctx *state, const uint8_t seed[SEEDBYTES], uint16_t nonce) {
 8001d32:	4604      	mov	r4, r0
 8001d34:	460d      	mov	r5, r1
    t[1] = (uint8_t) (nonce >> 8);
 8001d36:	f88d 3005 	strb.w	r3, [sp, #5]
    t[0] = (uint8_t) nonce;
 8001d3a:	f88d 2004 	strb.w	r2, [sp, #4]

    shake128_inc_init(state);
 8001d3e:	f001 f9f5 	bl	800312c <shake128_inc_init>
    shake128_inc_absorb(state, seed, SEEDBYTES);
 8001d42:	4629      	mov	r1, r5
 8001d44:	4620      	mov	r0, r4
 8001d46:	2220      	movs	r2, #32
 8001d48:	f001 fa04 	bl	8003154 <shake128_inc_absorb>
    shake128_inc_absorb(state, t, 2);
 8001d4c:	2202      	movs	r2, #2
 8001d4e:	a901      	add	r1, sp, #4
 8001d50:	4620      	mov	r0, r4
 8001d52:	f001 f9ff 	bl	8003154 <shake128_inc_absorb>
    shake128_inc_finalize(state);
 8001d56:	4620      	mov	r0, r4
 8001d58:	f001 fa02 	bl	8003160 <shake128_inc_finalize>
}
 8001d5c:	b003      	add	sp, #12
 8001d5e:	bd30      	pop	{r4, r5, pc}

08001d60 <PQCLEAN_MLDSA44_CLEAN_dilithium_shake256_stream_init>:

void PQCLEAN_MLDSA44_CLEAN_dilithium_shake256_stream_init(shake256incctx *state, const uint8_t seed[CRHBYTES], uint16_t nonce) {
 8001d60:	b530      	push	{r4, r5, lr}
 8001d62:	b083      	sub	sp, #12
    uint8_t t[2];
    t[0] = (uint8_t) nonce;
    t[1] = (uint8_t) (nonce >> 8);
 8001d64:	0a13      	lsrs	r3, r2, #8
void PQCLEAN_MLDSA44_CLEAN_dilithium_shake256_stream_init(shake256incctx *state, const uint8_t seed[CRHBYTES], uint16_t nonce) {
 8001d66:	4604      	mov	r4, r0
 8001d68:	460d      	mov	r5, r1
    t[1] = (uint8_t) (nonce >> 8);
 8001d6a:	f88d 3005 	strb.w	r3, [sp, #5]
    t[0] = (uint8_t) nonce;
 8001d6e:	f88d 2004 	strb.w	r2, [sp, #4]

    shake256_inc_init(state);
 8001d72:	f001 faa3 	bl	80032bc <shake256_inc_init>
    shake256_inc_absorb(state, seed, CRHBYTES);
 8001d76:	4629      	mov	r1, r5
 8001d78:	4620      	mov	r0, r4
 8001d7a:	2240      	movs	r2, #64	; 0x40
 8001d7c:	f001 fab2 	bl	80032e4 <shake256_inc_absorb>
    shake256_inc_absorb(state, t, 2);
 8001d80:	2202      	movs	r2, #2
 8001d82:	a901      	add	r1, sp, #4
 8001d84:	4620      	mov	r0, r4
 8001d86:	f001 faad 	bl	80032e4 <shake256_inc_absorb>
    shake256_inc_finalize(state);
 8001d8a:	4620      	mov	r0, r4
 8001d8c:	f001 fab0 	bl	80032f0 <shake256_inc_finalize>
}
 8001d90:	b003      	add	sp, #12
 8001d92:	bd30      	pop	{r4, r5, pc}

08001d94 <KeccakF1600_StatePermute>:
 *
 * Description: The Keccak F1600 Permutation
 *
 * Arguments:   - uint64_t *state: pointer to input/output Keccak state
 **************************************************/
static void KeccakF1600_StatePermute(uint64_t *state) {
 8001d94:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001d98:	b0c1      	sub	sp, #260	; 0x104
    uint64_t Eka, Eke, Eki, Eko, Eku;
    uint64_t Ema, Eme, Emi, Emo, Emu;
    uint64_t Esa, Ese, Esi, Eso, Esu;

    // copyFromState(A, state)
    Aba = state[0];
 8001d9a:	6802      	ldr	r2, [r0, #0]
 8001d9c:	9201      	str	r2, [sp, #4]
 8001d9e:	6842      	ldr	r2, [r0, #4]
 8001da0:	9202      	str	r2, [sp, #8]
    Abe = state[1];
 8001da2:	6882      	ldr	r2, [r0, #8]
 8001da4:	9203      	str	r2, [sp, #12]
 8001da6:	68c2      	ldr	r2, [r0, #12]
 8001da8:	9204      	str	r2, [sp, #16]
    Abi = state[2];
 8001daa:	4a35      	ldr	r2, [pc, #212]	; (8001e80 <KeccakF1600_StatePermute+0xec>)
 8001dac:	9200      	str	r2, [sp, #0]
 8001dae:	6902      	ldr	r2, [r0, #16]
 8001db0:	9205      	str	r2, [sp, #20]
 8001db2:	6942      	ldr	r2, [r0, #20]
 8001db4:	9206      	str	r2, [sp, #24]
    Abo = state[3];
 8001db6:	6982      	ldr	r2, [r0, #24]
 8001db8:	9207      	str	r2, [sp, #28]
 8001dba:	69c2      	ldr	r2, [r0, #28]
 8001dbc:	9208      	str	r2, [sp, #32]
    Abu = state[4];
 8001dbe:	6a02      	ldr	r2, [r0, #32]
 8001dc0:	9209      	str	r2, [sp, #36]	; 0x24
 8001dc2:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8001dc4:	920a      	str	r2, [sp, #40]	; 0x28
    Aga = state[5];
 8001dc6:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8001dc8:	920b      	str	r2, [sp, #44]	; 0x2c
 8001dca:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8001dcc:	920c      	str	r2, [sp, #48]	; 0x30
    Age = state[6];
 8001dce:	6b02      	ldr	r2, [r0, #48]	; 0x30
 8001dd0:	920d      	str	r2, [sp, #52]	; 0x34
 8001dd2:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8001dd4:	920e      	str	r2, [sp, #56]	; 0x38
    Agi = state[7];
 8001dd6:	6b82      	ldr	r2, [r0, #56]	; 0x38
static void KeccakF1600_StatePermute(uint64_t *state) {
 8001dd8:	903f      	str	r0, [sp, #252]	; 0xfc
    Agi = state[7];
 8001dda:	920f      	str	r2, [sp, #60]	; 0x3c
 8001ddc:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
 8001dde:	9210      	str	r2, [sp, #64]	; 0x40
    Ago = state[8];
 8001de0:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8001de2:	9211      	str	r2, [sp, #68]	; 0x44
 8001de4:	6c42      	ldr	r2, [r0, #68]	; 0x44
 8001de6:	9212      	str	r2, [sp, #72]	; 0x48
    Agu = state[9];
 8001de8:	6c82      	ldr	r2, [r0, #72]	; 0x48
 8001dea:	9213      	str	r2, [sp, #76]	; 0x4c
 8001dec:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
 8001dee:	9214      	str	r2, [sp, #80]	; 0x50
    Aka = state[10];
 8001df0:	6d02      	ldr	r2, [r0, #80]	; 0x50
 8001df2:	9215      	str	r2, [sp, #84]	; 0x54
 8001df4:	6d42      	ldr	r2, [r0, #84]	; 0x54
 8001df6:	922f      	str	r2, [sp, #188]	; 0xbc
    Ake = state[11];
 8001df8:	6d82      	ldr	r2, [r0, #88]	; 0x58
 8001dfa:	9216      	str	r2, [sp, #88]	; 0x58
 8001dfc:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
 8001dfe:	9217      	str	r2, [sp, #92]	; 0x5c
    Aki = state[12];
 8001e00:	6e02      	ldr	r2, [r0, #96]	; 0x60
 8001e02:	9218      	str	r2, [sp, #96]	; 0x60
 8001e04:	6e42      	ldr	r2, [r0, #100]	; 0x64
 8001e06:	9219      	str	r2, [sp, #100]	; 0x64
    Ako = state[13];
 8001e08:	6e82      	ldr	r2, [r0, #104]	; 0x68
 8001e0a:	921a      	str	r2, [sp, #104]	; 0x68
 8001e0c:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 8001e0e:	921b      	str	r2, [sp, #108]	; 0x6c
    Aku = state[14];
 8001e10:	6f02      	ldr	r2, [r0, #112]	; 0x70
 8001e12:	921c      	str	r2, [sp, #112]	; 0x70
 8001e14:	6f42      	ldr	r2, [r0, #116]	; 0x74
 8001e16:	921d      	str	r2, [sp, #116]	; 0x74
    Ama = state[15];
 8001e18:	6f82      	ldr	r2, [r0, #120]	; 0x78
 8001e1a:	921e      	str	r2, [sp, #120]	; 0x78
    Ame = state[16];
 8001e1c:	e9d0 921f 	ldrd	r9, r2, [r0, #124]	; 0x7c
 8001e20:	921f      	str	r2, [sp, #124]	; 0x7c
 8001e22:	f8d0 2084 	ldr.w	r2, [r0, #132]	; 0x84
 8001e26:	9220      	str	r2, [sp, #128]	; 0x80
    Ami = state[17];
 8001e28:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8001e2c:	9221      	str	r2, [sp, #132]	; 0x84
 8001e2e:	f8d0 208c 	ldr.w	r2, [r0, #140]	; 0x8c
 8001e32:	9222      	str	r2, [sp, #136]	; 0x88
    Amo = state[18];
 8001e34:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
 8001e38:	9223      	str	r2, [sp, #140]	; 0x8c
 8001e3a:	f8d0 2094 	ldr.w	r2, [r0, #148]	; 0x94
 8001e3e:	9224      	str	r2, [sp, #144]	; 0x90
    Amu = state[19];
 8001e40:	f8d0 2098 	ldr.w	r2, [r0, #152]	; 0x98
 8001e44:	9225      	str	r2, [sp, #148]	; 0x94
 8001e46:	f8d0 209c 	ldr.w	r2, [r0, #156]	; 0x9c
 8001e4a:	9226      	str	r2, [sp, #152]	; 0x98
    Asa = state[20];
    Ase = state[21];
 8001e4c:	f8d0 20a8 	ldr.w	r2, [r0, #168]	; 0xa8
 8001e50:	9227      	str	r2, [sp, #156]	; 0x9c
    Asi = state[22];
 8001e52:	e9d0 a22b 	ldrd	sl, r2, [r0, #172]	; 0xac
 8001e56:	9228      	str	r2, [sp, #160]	; 0xa0
 8001e58:	f8d0 20b4 	ldr.w	r2, [r0, #180]	; 0xb4
 8001e5c:	9229      	str	r2, [sp, #164]	; 0xa4
    Aso = state[23];
 8001e5e:	f8d0 20b8 	ldr.w	r2, [r0, #184]	; 0xb8
 8001e62:	922a      	str	r2, [sp, #168]	; 0xa8
    Asa = state[20];
 8001e64:	e9d0 c728 	ldrd	ip, r7, [r0, #160]	; 0xa0
    Aso = state[23];
 8001e68:	f8d0 20bc 	ldr.w	r2, [r0, #188]	; 0xbc
 8001e6c:	922b      	str	r2, [sp, #172]	; 0xac
    Asu = state[24];
 8001e6e:	f8d0 20c0 	ldr.w	r2, [r0, #192]	; 0xc0
 8001e72:	922c      	str	r2, [sp, #176]	; 0xb0
 8001e74:	f8d0 30c4 	ldr.w	r3, [r0, #196]	; 0xc4
 8001e78:	932d      	str	r3, [sp, #180]	; 0xb4

    for (round = 0; round < NROUNDS; round += 2) {
 8001e7a:	464a      	mov	r2, r9
 8001e7c:	46bb      	mov	fp, r7
 8001e7e:	e001      	b.n	8001e84 <KeccakF1600_StatePermute+0xf0>
 8001e80:	08004e48 	.word	0x08004e48
        //    prepareTheta
        BCa = Aba ^ Aga ^ Aka ^ Ama ^ Asa;
 8001e84:	9b01      	ldr	r3, [sp, #4]
 8001e86:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8001e88:	9802      	ldr	r0, [sp, #8]
 8001e8a:	9c0c      	ldr	r4, [sp, #48]	; 0x30
        BCe = Abe ^ Age ^ Ake ^ Ame ^ Ase;
 8001e8c:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 8001e8e:	f8dd e010 	ldr.w	lr, [sp, #16]
 8001e92:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
        BCa = Aba ^ Aga ^ Aka ^ Ama ^ Asa;
 8001e96:	ea83 0701 	eor.w	r7, r3, r1
 8001e9a:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8001e9c:	991e      	ldr	r1, [sp, #120]	; 0x78
 8001e9e:	405f      	eors	r7, r3
 8001ea0:	404f      	eors	r7, r1
 8001ea2:	ea87 030c 	eor.w	r3, r7, ip
 8001ea6:	9f2f      	ldr	r7, [sp, #188]	; 0xbc
 8001ea8:	932e      	str	r3, [sp, #184]	; 0xb8
 8001eaa:	ea80 0304 	eor.w	r3, r0, r4
 8001eae:	407b      	eors	r3, r7
 8001eb0:	4053      	eors	r3, r2
 8001eb2:	ea83 050b 	eor.w	r5, r3, fp
        BCi = Abi ^ Agi ^ Aki ^ Ami ^ Asi;
 8001eb6:	990f      	ldr	r1, [sp, #60]	; 0x3c
 8001eb8:	9b05      	ldr	r3, [sp, #20]
        BCa = Aba ^ Aga ^ Aka ^ Ama ^ Asa;
 8001eba:	952f      	str	r5, [sp, #188]	; 0xbc
        BCe = Abe ^ Age ^ Ake ^ Ame ^ Ase;
 8001ebc:	9d03      	ldr	r5, [sp, #12]
 8001ebe:	9c16      	ldr	r4, [sp, #88]	; 0x58
 8001ec0:	ea85 0006 	eor.w	r0, r5, r6
        BCi = Abi ^ Agi ^ Aki ^ Ami ^ Asi;
 8001ec4:	404b      	eors	r3, r1
        BCe = Abe ^ Age ^ Ake ^ Ame ^ Ase;
 8001ec6:	9d1f      	ldr	r5, [sp, #124]	; 0x7c
        BCi = Abi ^ Agi ^ Aki ^ Ami ^ Asi;
 8001ec8:	9918      	ldr	r1, [sp, #96]	; 0x60
        BCe = Abe ^ Age ^ Ake ^ Ame ^ Ase;
 8001eca:	9e27      	ldr	r6, [sp, #156]	; 0x9c
 8001ecc:	ea8e 0908 	eor.w	r9, lr, r8
 8001ed0:	4060      	eors	r0, r4
 8001ed2:	f8dd e05c 	ldr.w	lr, [sp, #92]	; 0x5c
        BCi = Abi ^ Agi ^ Aki ^ Ami ^ Asi;
 8001ed6:	9c21      	ldr	r4, [sp, #132]	; 0x84
        BCe = Abe ^ Age ^ Ake ^ Ame ^ Ase;
 8001ed8:	f8dd 8080 	ldr.w	r8, [sp, #128]	; 0x80
 8001edc:	4068      	eors	r0, r5
        BCi = Abi ^ Agi ^ Aki ^ Ami ^ Asi;
 8001ede:	404b      	eors	r3, r1
 8001ee0:	9d28      	ldr	r5, [sp, #160]	; 0xa0
        BCe = Abe ^ Age ^ Ake ^ Ame ^ Ase;
 8001ee2:	4070      	eors	r0, r6
        BCi = Abi ^ Agi ^ Aki ^ Ami ^ Asi;
 8001ee4:	4063      	eors	r3, r4
 8001ee6:	9e06      	ldr	r6, [sp, #24]
        BCo = Abo ^ Ago ^ Ako ^ Amo ^ Aso;
 8001ee8:	9c07      	ldr	r4, [sp, #28]
        BCe = Abe ^ Age ^ Ake ^ Ame ^ Ase;
 8001eea:	ea89 090e 	eor.w	r9, r9, lr
        BCi = Abi ^ Agi ^ Aki ^ Ami ^ Asi;
 8001eee:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
        BCe = Abe ^ Age ^ Ake ^ Ame ^ Ase;
 8001ef2:	ea89 0908 	eor.w	r9, r9, r8
        BCi = Abi ^ Agi ^ Aki ^ Ami ^ Asi;
 8001ef6:	ea83 0805 	eor.w	r8, r3, r5
 8001efa:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8001efc:	9d22      	ldr	r5, [sp, #136]	; 0x88
 8001efe:	ea86 010e 	eor.w	r1, r6, lr
        BCo = Abo ^ Ago ^ Ako ^ Amo ^ Aso;
 8001f02:	f8dd e044 	ldr.w	lr, [sp, #68]	; 0x44
        BCi = Abi ^ Agi ^ Aki ^ Ami ^ Asi;
 8001f06:	9e29      	ldr	r6, [sp, #164]	; 0xa4
 8001f08:	4059      	eors	r1, r3
        BCo = Abo ^ Ago ^ Ako ^ Amo ^ Aso;
 8001f0a:	9b1a      	ldr	r3, [sp, #104]	; 0x68
        BCi = Abi ^ Agi ^ Aki ^ Ami ^ Asi;
 8001f0c:	4069      	eors	r1, r5
        BCo = Abo ^ Ago ^ Ako ^ Amo ^ Aso;
 8001f0e:	ea84 050e 	eor.w	r5, r4, lr
 8001f12:	9c23      	ldr	r4, [sp, #140]	; 0x8c
        BCi = Abi ^ Agi ^ Aki ^ Ami ^ Asi;
 8001f14:	4071      	eors	r1, r6
        BCo = Abo ^ Ago ^ Ako ^ Amo ^ Aso;
 8001f16:	405d      	eors	r5, r3
 8001f18:	9e2a      	ldr	r6, [sp, #168]	; 0xa8
 8001f1a:	9b08      	ldr	r3, [sp, #32]
 8001f1c:	4065      	eors	r5, r4
 8001f1e:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8001f20:	4075      	eors	r5, r6
 8001f22:	9e1b      	ldr	r6, [sp, #108]	; 0x6c
 8001f24:	ea83 0e04 	eor.w	lr, r3, r4
 8001f28:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8001f2a:	9c2b      	ldr	r4, [sp, #172]	; 0xac
 8001f2c:	ea8e 0e06 	eor.w	lr, lr, r6
 8001f30:	ea8e 0e03 	eor.w	lr, lr, r3
 8001f34:	ea8e 0604 	eor.w	r6, lr, r4
        BCu = Abu ^ Agu ^ Aku ^ Amu ^ Asu;
 8001f38:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8001f3a:	f8dd e024 	ldr.w	lr, [sp, #36]	; 0x24
 8001f3e:	ea8e 0403 	eor.w	r4, lr, r3
 8001f42:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8001f44:	f8dd e028 	ldr.w	lr, [sp, #40]	; 0x28
 8001f48:	405c      	eors	r4, r3
 8001f4a:	9b25      	ldr	r3, [sp, #148]	; 0x94
 8001f4c:	405c      	eors	r4, r3
 8001f4e:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
 8001f50:	405c      	eors	r4, r3
 8001f52:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8001f54:	ea8e 0e03 	eor.w	lr, lr, r3
 8001f58:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8001f5a:	ea8e 0e03 	eor.w	lr, lr, r3
 8001f5e:	9b26      	ldr	r3, [sp, #152]	; 0x98
 8001f60:	ea8e 0e03 	eor.w	lr, lr, r3
 8001f64:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
        BCe = Abe ^ Age ^ Ake ^ Ame ^ Ase;
 8001f66:	ea89 090a 	eor.w	r9, r9, sl
        BCu = Abu ^ Agu ^ Aku ^ Amu ^ Asu;
 8001f6a:	ea8e 0e03 	eor.w	lr, lr, r3

        // thetaRhoPiChiIotaPrepareTheta(round  , A, E)
        Da = BCu ^ ROL(BCe, 1);
 8001f6e:	ea4f 0349 	mov.w	r3, r9, lsl #1
 8001f72:	ea43 73d0 	orr.w	r3, r3, r0, lsr #31
 8001f76:	ea83 030e 	eor.w	r3, r3, lr
        BCe = ROL(Agi, 6);
        Ako ^= Do;
        BCi = ROL(Ako, 25);
        Amu ^= Du;
        BCo = ROL(Amu, 8);
        Asa ^= Da;
 8001f7a:	ea83 0b0b 	eor.w	fp, r3, fp
 8001f7e:	f8cd b0cc 	str.w	fp, [sp, #204]	; 0xcc
        Aba ^= Da;
 8001f82:	f8dd b008 	ldr.w	fp, [sp, #8]
 8001f86:	ea83 0b0b 	eor.w	fp, r3, fp
 8001f8a:	f8cd b0c0 	str.w	fp, [sp, #192]	; 0xc0
        Eko = BCo ^ ((~BCu) & BCa);
        Eku = BCu ^ ((~BCa) & BCe);

        Abu ^= Du;
        BCa = ROL(Abu, 27);
        Aga ^= Da;
 8001f8e:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 8001f92:	ea83 0b0b 	eor.w	fp, r3, fp
        Aka ^= Da;
 8001f96:	405f      	eors	r7, r3
        Aga ^= Da;
 8001f98:	f8cd b0d4 	str.w	fp, [sp, #212]	; 0xd4
        BCa = ROL(Abi, 62);
        Ago ^= Do;
        BCe = ROL(Ago, 55);
        Aku ^= Du;
        BCi = ROL(Aku, 39);
        Ama ^= Da;
 8001f9c:	ea83 0b02 	eor.w	fp, r3, r2
        Da = BCu ^ ROL(BCe, 1);
 8001fa0:	0043      	lsls	r3, r0, #1
 8001fa2:	ea43 73d9 	orr.w	r3, r3, r9, lsr #31
 8001fa6:	4063      	eors	r3, r4
        Asa ^= Da;
 8001fa8:	ea83 0c0c 	eor.w	ip, r3, ip
        Aka ^= Da;
 8001fac:	9731      	str	r7, [sp, #196]	; 0xc4
 8001fae:	9f15      	ldr	r7, [sp, #84]	; 0x54
        Asa ^= Da;
 8001fb0:	f8cd c0c8 	str.w	ip, [sp, #200]	; 0xc8
        Aba ^= Da;
 8001fb4:	f8dd c004 	ldr.w	ip, [sp, #4]
        Aga ^= Da;
 8001fb8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
        Ama ^= Da;
 8001fba:	f8cd b0f0 	str.w	fp, [sp, #240]	; 0xf0
        Aka ^= Da;
 8001fbe:	ea83 0b07 	eor.w	fp, r3, r7
        Ama ^= Da;
 8001fc2:	9f1e      	ldr	r7, [sp, #120]	; 0x78
        Aka ^= Da;
 8001fc4:	f8cd b030 	str.w	fp, [sp, #48]	; 0x30
        Aba ^= Da;
 8001fc8:	ea83 0c0c 	eor.w	ip, r3, ip
        Ama ^= Da;
 8001fcc:	405f      	eors	r7, r3
        Aba ^= Da;
 8001fce:	f8cd c008 	str.w	ip, [sp, #8]
        Aga ^= Da;
 8001fd2:	ea83 0c02 	eor.w	ip, r3, r2
 8001fd6:	f8cd c0d0 	str.w	ip, [sp, #208]	; 0xd0
        Ama ^= Da;
 8001fda:	973b      	str	r7, [sp, #236]	; 0xec
        De = BCa ^ ROL(BCi, 1);
 8001fdc:	004b      	lsls	r3, r1, #1
 8001fde:	9a2f      	ldr	r2, [sp, #188]	; 0xbc
        Abe ^= De;
 8001fe0:	f8dd c010 	ldr.w	ip, [sp, #16]
        Age ^= De;
 8001fe4:	f8dd b038 	ldr.w	fp, [sp, #56]	; 0x38
        Ame ^= De;
 8001fe8:	9f1f      	ldr	r7, [sp, #124]	; 0x7c
        De = BCa ^ ROL(BCi, 1);
 8001fea:	ea43 73d8 	orr.w	r3, r3, r8, lsr #31
 8001fee:	4053      	eors	r3, r2
        Abe ^= De;
 8001ff0:	ea83 0c0c 	eor.w	ip, r3, ip
        Ame ^= De;
 8001ff4:	9a20      	ldr	r2, [sp, #128]	; 0x80
        Abe ^= De;
 8001ff6:	f8cd c078 	str.w	ip, [sp, #120]	; 0x78
        Ake ^= De;
 8001ffa:	f8dd c05c 	ldr.w	ip, [sp, #92]	; 0x5c
        Ame ^= De;
 8001ffe:	405a      	eors	r2, r3
        Age ^= De;
 8002000:	ea83 0b0b 	eor.w	fp, r3, fp
        Ake ^= De;
 8002004:	ea83 0c0c 	eor.w	ip, r3, ip
        BCo = ROL(Ama, 41);
        Ase ^= De;
 8002008:	ea83 0a0a 	eor.w	sl, r3, sl
        Ame ^= De;
 800200c:	9215      	str	r2, [sp, #84]	; 0x54
        De = BCa ^ ROL(BCi, 1);
 800200e:	ea4f 0348 	mov.w	r3, r8, lsl #1
 8002012:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
        Ase ^= De;
 8002014:	f8cd a0f8 	str.w	sl, [sp, #248]	; 0xf8
        De = BCa ^ ROL(BCi, 1);
 8002018:	ea43 73d1 	orr.w	r3, r3, r1, lsr #31
 800201c:	4053      	eors	r3, r2
        Ame ^= De;
 800201e:	405f      	eors	r7, r3
        Abe ^= De;
 8002020:	9a03      	ldr	r2, [sp, #12]
        Age ^= De;
 8002022:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
        Ame ^= De;
 8002026:	970d      	str	r7, [sp, #52]	; 0x34
        Ake ^= De;
 8002028:	9f16      	ldr	r7, [sp, #88]	; 0x58
 800202a:	f8cd c0dc 	str.w	ip, [sp, #220]	; 0xdc
        Abe ^= De;
 800202e:	405a      	eors	r2, r3
 8002030:	9201      	str	r2, [sp, #4]
        Ake ^= De;
 8002032:	ea83 0207 	eor.w	r2, r3, r7
        Ase ^= De;
 8002036:	9f27      	ldr	r7, [sp, #156]	; 0x9c
        Ake ^= De;
 8002038:	9236      	str	r2, [sp, #216]	; 0xd8
        Di = BCe ^ ROL(BCo, 1);
 800203a:	0072      	lsls	r2, r6, #1
        Ase ^= De;
 800203c:	ea83 0c07 	eor.w	ip, r3, r7
        Di = BCe ^ ROL(BCo, 1);
 8002040:	ea42 72d5 	orr.w	r2, r2, r5, lsr #31
        Asi ^= Di;
 8002044:	9f29      	ldr	r7, [sp, #164]	; 0xa4
        Ase ^= De;
 8002046:	f8cd c0f4 	str.w	ip, [sp, #244]	; 0xf4
        Di = BCe ^ ROL(BCo, 1);
 800204a:	ea82 0209 	eor.w	r2, r2, r9
        Asi ^= Di;
 800204e:	ea82 0c07 	eor.w	ip, r2, r7
 8002052:	f8cd c05c 	str.w	ip, [sp, #92]	; 0x5c
        Agi ^= Di;
 8002056:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
        Ami ^= Di;
 800205a:	9f22      	ldr	r7, [sp, #136]	; 0x88
        Aki ^= Di;
 800205c:	f8dd 9064 	ldr.w	r9, [sp, #100]	; 0x64
        Agi ^= Di;
 8002060:	ea82 0c0c 	eor.w	ip, r2, ip
 8002064:	f8cd c064 	str.w	ip, [sp, #100]	; 0x64
        Ami ^= Di;
 8002068:	ea82 0c07 	eor.w	ip, r2, r7
 800206c:	f8cd c0a4 	str.w	ip, [sp, #164]	; 0xa4
        Abi ^= Di;
 8002070:	f8dd c018 	ldr.w	ip, [sp, #24]
        Aki ^= Di;
 8002074:	9f18      	ldr	r7, [sp, #96]	; 0x60
 8002076:	ea82 0909 	eor.w	r9, r2, r9
        Abi ^= Di;
 800207a:	ea82 0c0c 	eor.w	ip, r2, ip
        Di = BCe ^ ROL(BCo, 1);
 800207e:	006a      	lsls	r2, r5, #1
 8002080:	ea42 72d6 	orr.w	r2, r2, r6, lsr #31
 8002084:	4050      	eors	r0, r2
        Asi ^= Di;
 8002086:	9a28      	ldr	r2, [sp, #160]	; 0xa0
        Abi ^= Di;
 8002088:	f8cd c0e4 	str.w	ip, [sp, #228]	; 0xe4
        Asi ^= Di;
 800208c:	4042      	eors	r2, r0
 800208e:	9216      	str	r2, [sp, #88]	; 0x58
        Agi ^= Di;
 8002090:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8002092:	4042      	eors	r2, r0
 8002094:	9204      	str	r2, [sp, #16]
        Aki ^= Di;
 8002096:	ea80 0c07 	eor.w	ip, r0, r7
        Ami ^= Di;
 800209a:	9f21      	ldr	r7, [sp, #132]	; 0x84
 800209c:	ea80 0207 	eor.w	r2, r0, r7
 80020a0:	9227      	str	r2, [sp, #156]	; 0x9c
        Abi ^= Di;
 80020a2:	9a05      	ldr	r2, [sp, #20]
        Aso ^= Do;
 80020a4:	9f2a      	ldr	r7, [sp, #168]	; 0xa8
        Abi ^= Di;
 80020a6:	4050      	eors	r0, r2
        Do = BCi ^ ROL(BCu, 1);
 80020a8:	ea4f 024e 	mov.w	r2, lr, lsl #1
 80020ac:	ea42 72d4 	orr.w	r2, r2, r4, lsr #31
 80020b0:	0064      	lsls	r4, r4, #1
 80020b2:	404a      	eors	r2, r1
 80020b4:	ea44 74de 	orr.w	r4, r4, lr, lsr #31
        Abo ^= Do;
 80020b8:	9907      	ldr	r1, [sp, #28]
        Ako ^= Do;
 80020ba:	f8dd e068 	ldr.w	lr, [sp, #104]	; 0x68
        Abi ^= Di;
 80020be:	9038      	str	r0, [sp, #224]	; 0xe0
        Age ^= De;
 80020c0:	ea83 0a0a 	eor.w	sl, r3, sl
        Do = BCi ^ ROL(BCu, 1);
 80020c4:	ea84 0308 	eor.w	r3, r4, r8
        Abo ^= Do;
 80020c8:	4059      	eors	r1, r3
        Ako ^= Do;
 80020ca:	ea83 0e0e 	eor.w	lr, r3, lr
        Abo ^= Do;
 80020ce:	910b      	str	r1, [sp, #44]	; 0x2c
        Ako ^= Do;
 80020d0:	f8cd e060 	str.w	lr, [sp, #96]	; 0x60
        Abo ^= Do;
 80020d4:	9908      	ldr	r1, [sp, #32]
        Amo ^= Do;
 80020d6:	f8dd 808c 	ldr.w	r8, [sp, #140]	; 0x8c
        Aso ^= Do;
 80020da:	ea83 0e07 	eor.w	lr, r3, r7
 80020de:	f8cd e0a0 	str.w	lr, [sp, #160]	; 0xa0
        Ago ^= Do;
 80020e2:	f8dd e044 	ldr.w	lr, [sp, #68]	; 0x44
        Abo ^= Do;
 80020e6:	ea82 0401 	eor.w	r4, r2, r1
        Ako ^= Do;
 80020ea:	991b      	ldr	r1, [sp, #108]	; 0x6c
        Ago ^= Do;
 80020ec:	ea83 0e0e 	eor.w	lr, r3, lr
        Ako ^= Do;
 80020f0:	4051      	eors	r1, r2
        Ago ^= Do;
 80020f2:	f8cd e0e8 	str.w	lr, [sp, #232]	; 0xe8
        Aso ^= Do;
 80020f6:	f8dd e0ac 	ldr.w	lr, [sp, #172]	; 0xac
        Ako ^= Do;
 80020fa:	9105      	str	r1, [sp, #20]
        Amo ^= Do;
 80020fc:	ea83 0008 	eor.w	r0, r3, r8
        Ago ^= Do;
 8002100:	9912      	ldr	r1, [sp, #72]	; 0x48
        Amo ^= Do;
 8002102:	f8dd 8090 	ldr.w	r8, [sp, #144]	; 0x90
        Aso ^= Do;
 8002106:	ea82 0e0e 	eor.w	lr, r2, lr
        Amo ^= Do;
 800210a:	ea82 0808 	eor.w	r8, r2, r8
        Aso ^= Do;
 800210e:	f8cd e0a8 	str.w	lr, [sp, #168]	; 0xa8
        Ago ^= Do;
 8002112:	ea82 0e01 	eor.w	lr, r2, r1
        Du = BCo ^ ROL(BCa, 1);
 8002116:	992f      	ldr	r1, [sp, #188]	; 0xbc
 8002118:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
        Ago ^= Do;
 800211a:	f8cd e0ac 	str.w	lr, [sp, #172]	; 0xac
        Du = BCo ^ ROL(BCa, 1);
 800211e:	0057      	lsls	r7, r2, #1
 8002120:	ea4f 0e41 	mov.w	lr, r1, lsl #1
 8002124:	ea4e 7ed2 	orr.w	lr, lr, r2, lsr #31
 8002128:	ea47 77d1 	orr.w	r7, r7, r1, lsr #31
        Agu ^= Du;
 800212c:	9914      	ldr	r1, [sp, #80]	; 0x50
 800212e:	9a13      	ldr	r2, [sp, #76]	; 0x4c
        Du = BCo ^ ROL(BCa, 1);
 8002130:	ea8e 0e06 	eor.w	lr, lr, r6
        Agu ^= Du;
 8002134:	ea8e 0301 	eor.w	r3, lr, r1
        Amu ^= Du;
 8002138:	9925      	ldr	r1, [sp, #148]	; 0x94
        Asu ^= Du;
 800213a:	9e2c      	ldr	r6, [sp, #176]	; 0xb0
        Du = BCo ^ ROL(BCa, 1);
 800213c:	406f      	eors	r7, r5
        Amu ^= Du;
 800213e:	4079      	eors	r1, r7
 8002140:	9112      	str	r1, [sp, #72]	; 0x48
 8002142:	9926      	ldr	r1, [sp, #152]	; 0x98
        Asu ^= Du;
 8002144:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
        Amu ^= Du;
 8002146:	ea8e 0101 	eor.w	r1, lr, r1
 800214a:	9114      	str	r1, [sp, #80]	; 0x50
        Abu ^= Du;
 800214c:	9909      	ldr	r1, [sp, #36]	; 0x24
 800214e:	4079      	eors	r1, r7
 8002150:	9122      	str	r1, [sp, #136]	; 0x88
        Aku ^= Du;
 8002152:	991c      	ldr	r1, [sp, #112]	; 0x70
        Asu ^= Du;
 8002154:	407e      	eors	r6, r7
        Agu ^= Du;
 8002156:	407a      	eors	r2, r7
        Aku ^= Du;
 8002158:	404f      	eors	r7, r1
        Abu ^= Du;
 800215a:	990a      	ldr	r1, [sp, #40]	; 0x28
        Aku ^= Du;
 800215c:	9725      	str	r7, [sp, #148]	; 0x94
        Abu ^= Du;
 800215e:	ea8e 0701 	eor.w	r7, lr, r1
        Aku ^= Du;
 8002162:	991d      	ldr	r1, [sp, #116]	; 0x74
        Abu ^= Du;
 8002164:	9724      	str	r7, [sp, #144]	; 0x90
        Asu ^= Du;
 8002166:	ea8e 0505 	eor.w	r5, lr, r5
        Aku ^= Du;
 800216a:	ea8e 0e01 	eor.w	lr, lr, r1
 800216e:	f8cd e098 	str.w	lr, [sp, #152]	; 0x98
        Eba ^= KeccakF_RoundConstants[round];
 8002172:	f8dd e000 	ldr.w	lr, [sp]
 8002176:	9902      	ldr	r1, [sp, #8]
 8002178:	f8de 7000 	ldr.w	r7, [lr]
 800217c:	4079      	eors	r1, r7
 800217e:	f8de 7004 	ldr.w	r7, [lr, #4]
 8002182:	f8dd e0c0 	ldr.w	lr, [sp, #192]	; 0xc0
 8002186:	9107      	str	r1, [sp, #28]
 8002188:	ea8e 0107 	eor.w	r1, lr, r7
        BCe = ROL(Age, 44);
 800218c:	ea4f 5e1a 	mov.w	lr, sl, lsr #20
 8002190:	ea4f 571b 	mov.w	r7, fp, lsr #20
 8002194:	ea4e 3e0b 	orr.w	lr, lr, fp, lsl #12
 8002198:	ea47 3b0a 	orr.w	fp, r7, sl, lsl #12
        BCi = ROL(Aki, 43);
 800219c:	ea4f 5a5c 	mov.w	sl, ip, lsr #21
 80021a0:	ea4a 2ac9 	orr.w	sl, sl, r9, lsl #11
 80021a4:	ea4f 5959 	mov.w	r9, r9, lsr #21
 80021a8:	ea49 2ccc 	orr.w	ip, r9, ip, lsl #11
        BCu = ROL(Asu, 14);
 80021ac:	ea4f 3985 	mov.w	r9, r5, lsl #14
 80021b0:	ea49 4996 	orr.w	r9, r9, r6, lsr #18
        Eba ^= KeccakF_RoundConstants[round];
 80021b4:	9108      	str	r1, [sp, #32]
        BCu = ROL(Asu, 14);
 80021b6:	03b6      	lsls	r6, r6, #14
        BCa = ROL(Abo, 28);
 80021b8:	990b      	ldr	r1, [sp, #44]	; 0x2c
        BCi = ROL(Aki, 43);
 80021ba:	f8cd c018 	str.w	ip, [sp, #24]
        BCu = ROL(Asu, 14);
 80021be:	ea46 4695 	orr.w	r6, r6, r5, lsr #18
        BCa = ROL(Abo, 28);
 80021c2:	0725      	lsls	r5, r4, #28
 80021c4:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
        BCo = ROL(Amo, 21);
 80021c8:	ea4f 5c48 	mov.w	ip, r8, lsl #21
        BCa = ROL(Abo, 28);
 80021cc:	0709      	lsls	r1, r1, #28
        BCo = ROL(Amo, 21);
 80021ce:	ea4c 2cd0 	orr.w	ip, ip, r0, lsr #11
        BCa = ROL(Abo, 28);
 80021d2:	ea41 1114 	orr.w	r1, r1, r4, lsr #4
        BCo = ROL(Amo, 21);
 80021d6:	0540      	lsls	r0, r0, #21
        BCe = ROL(Agu, 20);
 80021d8:	051c      	lsls	r4, r3, #20
        BCi = ROL(Aka, 3);
 80021da:	9f0c      	ldr	r7, [sp, #48]	; 0x30
        BCa = ROL(Abo, 28);
 80021dc:	950f      	str	r5, [sp, #60]	; 0x3c
        BCo = ROL(Amo, 21);
 80021de:	ea40 20d8 	orr.w	r0, r0, r8, lsr #11
        BCe = ROL(Agu, 20);
 80021e2:	ea44 3812 	orr.w	r8, r4, r2, lsr #12
        BCi = ROL(Aka, 3);
 80021e6:	9c31      	ldr	r4, [sp, #196]	; 0xc4
        BCe = ROL(Agu, 20);
 80021e8:	f8cd 8040 	str.w	r8, [sp, #64]	; 0x40
 80021ec:	0512      	lsls	r2, r2, #20
 80021ee:	ea42 3213 	orr.w	r2, r2, r3, lsr #12
        BCi = ROL(Aka, 3);
 80021f2:	00fd      	lsls	r5, r7, #3
 80021f4:	00e3      	lsls	r3, r4, #3
 80021f6:	ea43 7857 	orr.w	r8, r3, r7, lsr #29
 80021fa:	ea45 7354 	orr.w	r3, r5, r4, lsr #29
        BCo = ROL(Ame, 45);
 80021fe:	9c0d      	ldr	r4, [sp, #52]	; 0x34
        BCi = ROL(Aka, 3);
 8002200:	930e      	str	r3, [sp, #56]	; 0x38
        BCo = ROL(Ame, 45);
 8002202:	9b15      	ldr	r3, [sp, #84]	; 0x54
        BCu = ROL(Asi, 61);
 8002204:	9d16      	ldr	r5, [sp, #88]	; 0x58
        BCi = ROL(Aka, 3);
 8002206:	f8cd 8044 	str.w	r8, [sp, #68]	; 0x44
        BCo = ROL(Ame, 45);
 800220a:	0ce7      	lsrs	r7, r4, #19
 800220c:	ea47 3743 	orr.w	r7, r7, r3, lsl #13
 8002210:	0cdb      	lsrs	r3, r3, #19
 8002212:	ea43 3344 	orr.w	r3, r3, r4, lsl #13
        BCu = ROL(Asi, 61);
 8002216:	9c17      	ldr	r4, [sp, #92]	; 0x5c
        BCe = ROL(Age, 44);
 8002218:	f8cd b00c 	str.w	fp, [sp, #12]
        BCu = ROL(Asi, 61);
 800221c:	ea4f 08d5 	mov.w	r8, r5, lsr #3
 8002220:	ea48 7844 	orr.w	r8, r8, r4, lsl #29
 8002224:	08e4      	lsrs	r4, r4, #3
 8002226:	ea44 7445 	orr.w	r4, r4, r5, lsl #29
 800222a:	9413      	str	r4, [sp, #76]	; 0x4c
        BCa = ROL(Abe, 1);
 800222c:	9c1e      	ldr	r4, [sp, #120]	; 0x78
 800222e:	9d01      	ldr	r5, [sp, #4]
 8002230:	ea4f 0b44 	mov.w	fp, r4, lsl #1
 8002234:	ea4b 75d5 	orr.w	r5, fp, r5, lsr #31
 8002238:	951b      	str	r5, [sp, #108]	; 0x6c
 800223a:	9d01      	ldr	r5, [sp, #4]
 800223c:	ea4f 0b45 	mov.w	fp, r5, lsl #1
 8002240:	ea4b 7bd4 	orr.w	fp, fp, r4, lsr #31
 8002244:	f8cd b068 	str.w	fp, [sp, #104]	; 0x68
        BCe = ROL(Agi, 6);
 8002248:	9c19      	ldr	r4, [sp, #100]	; 0x64
 800224a:	9d04      	ldr	r5, [sp, #16]
 800224c:	ea4f 1b84 	mov.w	fp, r4, lsl #6
 8002250:	ea4b 6595 	orr.w	r5, fp, r5, lsr #26
 8002254:	951c      	str	r5, [sp, #112]	; 0x70
 8002256:	9d04      	ldr	r5, [sp, #16]
 8002258:	ea4f 1b85 	mov.w	fp, r5, lsl #6
 800225c:	ea4b 6594 	orr.w	r5, fp, r4, lsr #26
        BCi = ROL(Ako, 25);
 8002260:	9c05      	ldr	r4, [sp, #20]
        BCe = ROL(Agi, 6);
 8002262:	9501      	str	r5, [sp, #4]
        BCi = ROL(Ako, 25);
 8002264:	ea4f 6b44 	mov.w	fp, r4, lsl #25
 8002268:	9c18      	ldr	r4, [sp, #96]	; 0x60
 800226a:	ea4b 15d4 	orr.w	r5, fp, r4, lsr #7
 800226e:	ea4f 6b44 	mov.w	fp, r4, lsl #25
 8002272:	9c05      	ldr	r4, [sp, #20]
 8002274:	951f      	str	r5, [sp, #124]	; 0x7c
        BCo = ROL(Amu, 8);
 8002276:	9d14      	ldr	r5, [sp, #80]	; 0x50
        BCi = ROL(Ako, 25);
 8002278:	ea4b 1bd4 	orr.w	fp, fp, r4, lsr #7
        BCo = ROL(Amu, 8);
 800227c:	9c12      	ldr	r4, [sp, #72]	; 0x48
        BCi = ROL(Ako, 25);
 800227e:	f8cd b074 	str.w	fp, [sp, #116]	; 0x74
        BCo = ROL(Amu, 8);
 8002282:	ea4f 2b05 	mov.w	fp, r5, lsl #8
 8002286:	ea4b 6b14 	orr.w	fp, fp, r4, lsr #24
 800228a:	f8cd b08c 	str.w	fp, [sp, #140]	; 0x8c
 800228e:	ea4f 2b04 	mov.w	fp, r4, lsl #8
 8002292:	ea4b 6b15 	orr.w	fp, fp, r5, lsr #24
        BCu = ROL(Asa, 18);
 8002296:	9d33      	ldr	r5, [sp, #204]	; 0xcc
 8002298:	9c32      	ldr	r4, [sp, #200]	; 0xc8
        BCo = ROL(Amu, 8);
 800229a:	f8cd b078 	str.w	fp, [sp, #120]	; 0x78
        BCu = ROL(Asa, 18);
 800229e:	ea4f 4b85 	mov.w	fp, r5, lsl #18
 80022a2:	ea4b 3b94 	orr.w	fp, fp, r4, lsr #14
 80022a6:	f8cd b064 	str.w	fp, [sp, #100]	; 0x64
 80022aa:	ea4f 4b84 	mov.w	fp, r4, lsl #18
        Eba ^= KeccakF_RoundConstants[round];
 80022ae:	9c07      	ldr	r4, [sp, #28]
        BCu = ROL(Asa, 18);
 80022b0:	ea4b 3595 	orr.w	r5, fp, r5, lsr #14
        Eba = BCa ^ ((~BCe) & BCi);
 80022b4:	ea2a 0b0e 	bic.w	fp, sl, lr
        Eba ^= KeccakF_RoundConstants[round];
 80022b8:	ea84 040b 	eor.w	r4, r4, fp
        BCu = ROL(Asa, 18);
 80022bc:	9518      	str	r5, [sp, #96]	; 0x60
        Eba = BCa ^ ((~BCe) & BCi);
 80022be:	f8dd b00c 	ldr.w	fp, [sp, #12]
 80022c2:	9d06      	ldr	r5, [sp, #24]
        Eba ^= KeccakF_RoundConstants[round];
 80022c4:	9404      	str	r4, [sp, #16]
 80022c6:	9c08      	ldr	r4, [sp, #32]
        Eba = BCa ^ ((~BCe) & BCi);
 80022c8:	ea25 0b0b 	bic.w	fp, r5, fp
        Eba ^= KeccakF_RoundConstants[round];
 80022cc:	ea84 040b 	eor.w	r4, r4, fp
        Ebe = BCe ^ ((~BCi) & BCo);
 80022d0:	ea20 0b0a 	bic.w	fp, r0, sl
        Eba ^= KeccakF_RoundConstants[round];
 80022d4:	9405      	str	r4, [sp, #20]
        Ebe = BCe ^ ((~BCi) & BCo);
 80022d6:	ea8b 040e 	eor.w	r4, fp, lr
        Ebu = BCu ^ ((~BCa) & BCe);
 80022da:	f8dd b008 	ldr.w	fp, [sp, #8]
        Ebe = BCe ^ ((~BCi) & BCo);
 80022de:	9406      	str	r4, [sp, #24]
        Ebu = BCu ^ ((~BCa) & BCe);
 80022e0:	ea2e 0e0b 	bic.w	lr, lr, fp
        Ebo = BCo ^ ((~BCu) & BCa);
 80022e4:	ea2b 0b06 	bic.w	fp, fp, r6
 80022e8:	ea8b 0400 	eor.w	r4, fp, r0
        Ebi = BCi ^ ((~BCo) & BCu);
 80022ec:	ea26 0000 	bic.w	r0, r6, r0
        Ebe = BCe ^ ((~BCi) & BCo);
 80022f0:	f8dd b00c 	ldr.w	fp, [sp, #12]
        Ebo = BCo ^ ((~BCu) & BCa);
 80022f4:	940a      	str	r4, [sp, #40]	; 0x28
        Ebi = BCi ^ ((~BCo) & BCu);
 80022f6:	ea80 000a 	eor.w	r0, r0, sl
 80022fa:	9008      	str	r0, [sp, #32]
        Ebu = BCu ^ ((~BCa) & BCe);
 80022fc:	ea8e 0a06 	eor.w	sl, lr, r6
        Ebe = BCe ^ ((~BCi) & BCo);
 8002300:	ea2c 0005 	bic.w	r0, ip, r5
        Ebu = BCu ^ ((~BCa) & BCe);
 8002304:	f8cd a030 	str.w	sl, [sp, #48]	; 0x30
        Ebe = BCe ^ ((~BCi) & BCo);
 8002308:	ea80 0a0b 	eor.w	sl, r0, fp
 800230c:	f8cd a01c 	str.w	sl, [sp, #28]
        Ebu = BCu ^ ((~BCa) & BCe);
 8002310:	f8dd a0c0 	ldr.w	sl, [sp, #192]	; 0xc0
        Ebo = BCo ^ ((~BCu) & BCa);
 8002314:	ea2a 0609 	bic.w	r6, sl, r9
        Ebu = BCu ^ ((~BCa) & BCe);
 8002318:	ea2b 000a 	bic.w	r0, fp, sl
        Ebo = BCo ^ ((~BCu) & BCa);
 800231c:	ea86 0a0c 	eor.w	sl, r6, ip
 8002320:	f8cd a02c 	str.w	sl, [sp, #44]	; 0x2c
        Ega = BCa ^ ((~BCe) & BCi);
 8002324:	9e0e      	ldr	r6, [sp, #56]	; 0x38
        Eku = BCu ^ ((~BCa) & BCe);
 8002326:	f8dd b068 	ldr.w	fp, [sp, #104]	; 0x68
        Ebi = BCi ^ ((~BCo) & BCu);
 800232a:	ea29 0c0c 	bic.w	ip, r9, ip
        Ebu = BCu ^ ((~BCa) & BCe);
 800232e:	ea80 0909 	eor.w	r9, r0, r9
        Ega = BCa ^ ((~BCe) & BCi);
 8002332:	ea26 0002 	bic.w	r0, r6, r2
        Ebu = BCu ^ ((~BCa) & BCe);
 8002336:	f8cd 9034 	str.w	r9, [sp, #52]	; 0x34
        Ega = BCa ^ ((~BCe) & BCi);
 800233a:	ea80 0901 	eor.w	r9, r0, r1
        Ebi = BCi ^ ((~BCo) & BCu);
 800233e:	ea8c 0a05 	eor.w	sl, ip, r5
        Ega = BCa ^ ((~BCe) & BCi);
 8002342:	f8cd 9038 	str.w	r9, [sp, #56]	; 0x38
 8002346:	e9dd c910 	ldrd	ip, r9, [sp, #64]	; 0x40
 800234a:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
        Ebi = BCi ^ ((~BCo) & BCu);
 800234c:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
        Ega = BCa ^ ((~BCe) & BCi);
 8002350:	ea29 000c 	bic.w	r0, r9, ip
 8002354:	4068      	eors	r0, r5
 8002356:	900f      	str	r0, [sp, #60]	; 0x3c
        Ege = BCe ^ ((~BCi) & BCo);
 8002358:	ea27 0006 	bic.w	r0, r7, r6
 800235c:	4050      	eors	r0, r2
 800235e:	9010      	str	r0, [sp, #64]	; 0x40
        Egu = BCu ^ ((~BCa) & BCe);
 8002360:	ea22 0201 	bic.w	r2, r2, r1
        Ego = BCo ^ ((~BCu) & BCa);
 8002364:	9813      	ldr	r0, [sp, #76]	; 0x4c
 8002366:	ea21 0108 	bic.w	r1, r1, r8
 800236a:	4079      	eors	r1, r7
        Egi = BCi ^ ((~BCo) & BCu);
 800236c:	ea28 0707 	bic.w	r7, r8, r7
        Egu = BCu ^ ((~BCa) & BCe);
 8002370:	ea82 0808 	eor.w	r8, r2, r8
        Ege = BCe ^ ((~BCi) & BCo);
 8002374:	ea23 0209 	bic.w	r2, r3, r9
        Ego = BCo ^ ((~BCu) & BCa);
 8002378:	9114      	str	r1, [sp, #80]	; 0x50
        Egu = BCu ^ ((~BCa) & BCe);
 800237a:	f8cd 8058 	str.w	r8, [sp, #88]	; 0x58
        Ego = BCo ^ ((~BCu) & BCa);
 800237e:	ea25 0100 	bic.w	r1, r5, r0
        Ege = BCe ^ ((~BCi) & BCo);
 8002382:	ea82 080c 	eor.w	r8, r2, ip
 8002386:	f8cd 8044 	str.w	r8, [sp, #68]	; 0x44
        Ego = BCo ^ ((~BCu) & BCa);
 800238a:	ea81 0803 	eor.w	r8, r1, r3
        Egi = BCi ^ ((~BCo) & BCu);
 800238e:	ea20 0303 	bic.w	r3, r0, r3
 8002392:	ea83 0909 	eor.w	r9, r3, r9
        Egu = BCu ^ ((~BCa) & BCe);
 8002396:	4603      	mov	r3, r0
        Eku = BCu ^ ((~BCa) & BCe);
 8002398:	9801      	ldr	r0, [sp, #4]
        Ego = BCo ^ ((~BCu) & BCa);
 800239a:	f8cd 8054 	str.w	r8, [sp, #84]	; 0x54
        Eku = BCu ^ ((~BCa) & BCe);
 800239e:	f8dd 8060 	ldr.w	r8, [sp, #96]	; 0x60
        Egi = BCi ^ ((~BCo) & BCu);
 80023a2:	f8cd 904c 	str.w	r9, [sp, #76]	; 0x4c
 80023a6:	ea87 0a06 	eor.w	sl, r7, r6
        Egu = BCu ^ ((~BCa) & BCe);
 80023aa:	ea2c 0205 	bic.w	r2, ip, r5
        Eku = BCu ^ ((~BCa) & BCe);
 80023ae:	9e1c      	ldr	r6, [sp, #112]	; 0x70
 80023b0:	9f1b      	ldr	r7, [sp, #108]	; 0x6c
        Egi = BCi ^ ((~BCo) & BCu);
 80023b2:	f8cd a048 	str.w	sl, [sp, #72]	; 0x48
        Eku = BCu ^ ((~BCa) & BCe);
 80023b6:	ea20 0c0b 	bic.w	ip, r0, fp
 80023ba:	ea8c 0908 	eor.w	r9, ip, r8
 80023be:	f8dd c064 	ldr.w	ip, [sp, #100]	; 0x64
        BCa = ROL(Abu, 27);
 80023c2:	f8dd 8090 	ldr.w	r8, [sp, #144]	; 0x90
        Eku = BCu ^ ((~BCa) & BCe);
 80023c6:	f8cd 9080 	str.w	r9, [sp, #128]	; 0x80
        Egu = BCu ^ ((~BCa) & BCe);
 80023ca:	4053      	eors	r3, r2
        Eku = BCu ^ ((~BCa) & BCe);
 80023cc:	ea26 0207 	bic.w	r2, r6, r7
        Egu = BCu ^ ((~BCa) & BCe);
 80023d0:	9317      	str	r3, [sp, #92]	; 0x5c
        Eku = BCu ^ ((~BCa) & BCe);
 80023d2:	ea82 030c 	eor.w	r3, r2, ip
 80023d6:	9321      	str	r3, [sp, #132]	; 0x84
        BCa = ROL(Abu, 27);
 80023d8:	9b22      	ldr	r3, [sp, #136]	; 0x88
        BCe = ROL(Aga, 36);
 80023da:	f8dd 90d0 	ldr.w	r9, [sp, #208]	; 0xd0
        BCi = ROL(Ake, 10);
 80023de:	9a36      	ldr	r2, [sp, #216]	; 0xd8
 80023e0:	f8dd a0dc 	ldr.w	sl, [sp, #220]	; 0xdc
        BCa = ROL(Abu, 27);
 80023e4:	06d9      	lsls	r1, r3, #27
 80023e6:	ea4f 6ec8 	mov.w	lr, r8, lsl #27
 80023ea:	ea4e 1e53 	orr.w	lr, lr, r3, lsr #5
 80023ee:	ea41 1558 	orr.w	r5, r1, r8, lsr #5
        BCe = ROL(Aga, 36);
 80023f2:	9b35      	ldr	r3, [sp, #212]	; 0xd4
        BCa = ROL(Abu, 27);
 80023f4:	9522      	str	r5, [sp, #136]	; 0x88
        BCe = ROL(Aga, 36);
 80023f6:	ea4f 7819 	mov.w	r8, r9, lsr #28
        BCi = ROL(Ake, 10);
 80023fa:	0295      	lsls	r5, r2, #10
        BCe = ROL(Aga, 36);
 80023fc:	ea48 1803 	orr.w	r8, r8, r3, lsl #4
        BCi = ROL(Ake, 10);
 8002400:	ea45 519a 	orr.w	r1, r5, sl, lsr #22
        BCe = ROL(Aga, 36);
 8002404:	0f1b      	lsrs	r3, r3, #28
        BCi = ROL(Ake, 10);
 8002406:	9102      	str	r1, [sp, #8]
        BCe = ROL(Aga, 36);
 8002408:	ea43 1309 	orr.w	r3, r3, r9, lsl #4
        BCi = ROL(Ake, 10);
 800240c:	ea4f 298a 	mov.w	r9, sl, lsl #10
        BCo = ROL(Ami, 15);
 8002410:	f8dd a0a4 	ldr.w	sl, [sp, #164]	; 0xa4
        BCu = ROL(Aso, 56);
 8002414:	9d28      	ldr	r5, [sp, #160]	; 0xa0
 8002416:	9c2a      	ldr	r4, [sp, #168]	; 0xa8
        BCi = ROL(Ake, 10);
 8002418:	ea49 5992 	orr.w	r9, r9, r2, lsr #22
        BCo = ROL(Ami, 15);
 800241c:	9a27      	ldr	r2, [sp, #156]	; 0x9c
 800241e:	ea4f 3cca 	mov.w	ip, sl, lsl #15
 8002422:	ea4c 4c52 	orr.w	ip, ip, r2, lsr #17
 8002426:	03d2      	lsls	r2, r2, #15
 8002428:	ea42 425a 	orr.w	r2, r2, sl, lsr #17
        BCu = ROL(Aso, 56);
 800242c:	ea4f 2a15 	mov.w	sl, r5, lsr #8
 8002430:	ea4a 6a04 	orr.w	sl, sl, r4, lsl #24
 8002434:	0a24      	lsrs	r4, r4, #8
 8002436:	ea44 6405 	orr.w	r4, r4, r5, lsl #24
        Eka = BCa ^ ((~BCe) & BCi);
 800243a:	9d1d      	ldr	r5, [sp, #116]	; 0x74
 800243c:	ea25 0000 	bic.w	r0, r5, r0
 8002440:	ea80 010b 	eor.w	r1, r0, fp
 8002444:	911a      	str	r1, [sp, #104]	; 0x68
        Eko = BCo ^ ((~BCu) & BCa);
 8002446:	9918      	ldr	r1, [sp, #96]	; 0x60
 8002448:	ea2b 0001 	bic.w	r0, fp, r1
        Eki = BCi ^ ((~BCo) & BCu);
 800244c:	468b      	mov	fp, r1
 800244e:	991e      	ldr	r1, [sp, #120]	; 0x78
 8002450:	ea2b 0b01 	bic.w	fp, fp, r1
 8002454:	ea8b 0b05 	eor.w	fp, fp, r5
 8002458:	f8cd b070 	str.w	fp, [sp, #112]	; 0x70
        Eke = BCe ^ ((~BCi) & BCo);
 800245c:	ea21 0b05 	bic.w	fp, r1, r5
 8002460:	9d01      	ldr	r5, [sp, #4]
 8002462:	ea8b 0505 	eor.w	r5, fp, r5
 8002466:	951b      	str	r5, [sp, #108]	; 0x6c
        Eka = BCa ^ ((~BCe) & BCi);
 8002468:	9d1f      	ldr	r5, [sp, #124]	; 0x7c
        Eko = BCo ^ ((~BCu) & BCa);
 800246a:	ea80 0b01 	eor.w	fp, r0, r1
        Eka = BCa ^ ((~BCe) & BCi);
 800246e:	ea25 0006 	bic.w	r0, r5, r6
        Eko = BCo ^ ((~BCu) & BCa);
 8002472:	f8cd b078 	str.w	fp, [sp, #120]	; 0x78
        Eka = BCa ^ ((~BCe) & BCi);
 8002476:	46bb      	mov	fp, r7
 8002478:	4047      	eors	r7, r0
        Eko = BCo ^ ((~BCu) & BCa);
 800247a:	9919      	ldr	r1, [sp, #100]	; 0x64
        Eka = BCa ^ ((~BCe) & BCi);
 800247c:	9718      	str	r7, [sp, #96]	; 0x60
        Eki = BCi ^ ((~BCo) & BCu);
 800247e:	9f23      	ldr	r7, [sp, #140]	; 0x8c
        Eko = BCo ^ ((~BCu) & BCa);
 8002480:	ea2b 0001 	bic.w	r0, fp, r1
        Eki = BCi ^ ((~BCo) & BCu);
 8002484:	ea21 0b07 	bic.w	fp, r1, r7
 8002488:	ea8b 0b05 	eor.w	fp, fp, r5
 800248c:	f8cd b074 	str.w	fp, [sp, #116]	; 0x74
        Eke = BCe ^ ((~BCi) & BCo);
 8002490:	ea27 0b05 	bic.w	fp, r7, r5
 8002494:	ea8b 0506 	eor.w	r5, fp, r6
        BCa = ROL(Abi, 62);
 8002498:	9e38      	ldr	r6, [sp, #224]	; 0xe0
        Eke = BCe ^ ((~BCi) & BCo);
 800249a:	9519      	str	r5, [sp, #100]	; 0x64
        Eko = BCo ^ ((~BCu) & BCa);
 800249c:	ea80 0507 	eor.w	r5, r0, r7
        BCa = ROL(Abi, 62);
 80024a0:	9f39      	ldr	r7, [sp, #228]	; 0xe4
        BCe = ROL(Ago, 55);
 80024a2:	992b      	ldr	r1, [sp, #172]	; 0xac
        Eko = BCo ^ ((~BCu) & BCa);
 80024a4:	951f      	str	r5, [sp, #124]	; 0x7c
        BCa = ROL(Abi, 62);
 80024a6:	08b0      	lsrs	r0, r6, #2
 80024a8:	ea40 7587 	orr.w	r5, r0, r7, lsl #30
 80024ac:	08b8      	lsrs	r0, r7, #2
 80024ae:	ea40 7b86 	orr.w	fp, r0, r6, lsl #30
        BCe = ROL(Ago, 55);
 80024b2:	983a      	ldr	r0, [sp, #232]	; 0xe8
        BCa = ROL(Abi, 62);
 80024b4:	f8cd b0a4 	str.w	fp, [sp, #164]	; 0xa4
        BCe = ROL(Ago, 55);
 80024b8:	ea4f 2b51 	mov.w	fp, r1, lsr #9
 80024bc:	ea4b 57c0 	orr.w	r7, fp, r0, lsl #23
 80024c0:	972b      	str	r7, [sp, #172]	; 0xac
        BCi = ROL(Aku, 39);
 80024c2:	9f25      	ldr	r7, [sp, #148]	; 0x94
        BCa = ROL(Abi, 62);
 80024c4:	952d      	str	r5, [sp, #180]	; 0xb4
        BCi = ROL(Aku, 39);
 80024c6:	9d26      	ldr	r5, [sp, #152]	; 0x98
        BCe = ROL(Ago, 55);
 80024c8:	0a46      	lsrs	r6, r0, #9
        BCi = ROL(Aku, 39);
 80024ca:	0e78      	lsrs	r0, r7, #25
        BCe = ROL(Ago, 55);
 80024cc:	ea46 56c1 	orr.w	r6, r6, r1, lsl #23
        BCi = ROL(Aku, 39);
 80024d0:	ea40 11c5 	orr.w	r1, r0, r5, lsl #7
 80024d4:	0e68      	lsrs	r0, r5, #25
 80024d6:	ea40 17c7 	orr.w	r7, r0, r7, lsl #7
 80024da:	912e      	str	r1, [sp, #184]	; 0xb8
 80024dc:	9701      	str	r7, [sp, #4]
        BCo = ROL(Ama, 41);
 80024de:	993b      	ldr	r1, [sp, #236]	; 0xec
        BCe = ROL(Ago, 55);
 80024e0:	962a      	str	r6, [sp, #168]	; 0xa8
        BCo = ROL(Ama, 41);
 80024e2:	9e3c      	ldr	r6, [sp, #240]	; 0xf0
        Ema = BCa ^ ((~BCe) & BCi);
 80024e4:	9d22      	ldr	r5, [sp, #136]	; 0x88
        BCo = ROL(Ama, 41);
 80024e6:	0df0      	lsrs	r0, r6, #23
 80024e8:	ea40 2041 	orr.w	r0, r0, r1, lsl #9
 80024ec:	0dcf      	lsrs	r7, r1, #23
        BCu = ROL(Ase, 2);
 80024ee:	993e      	ldr	r1, [sp, #248]	; 0xf8
        BCo = ROL(Ama, 41);
 80024f0:	902c      	str	r0, [sp, #176]	; 0xb0
 80024f2:	ea47 2746 	orr.w	r7, r7, r6, lsl #9
        BCu = ROL(Ase, 2);
 80024f6:	9e3d      	ldr	r6, [sp, #244]	; 0xf4
 80024f8:	0088      	lsls	r0, r1, #2
 80024fa:	ea40 7b96 	orr.w	fp, r0, r6, lsr #30
 80024fe:	00b0      	lsls	r0, r6, #2
 8002500:	ea40 7091 	orr.w	r0, r0, r1, lsr #30
        Ema = BCa ^ ((~BCe) & BCi);
 8002504:	9902      	ldr	r1, [sp, #8]
        BCu = ROL(Ase, 2);
 8002506:	f8cd b00c 	str.w	fp, [sp, #12]
        Ema = BCa ^ ((~BCe) & BCi);
 800250a:	ea21 0b08 	bic.w	fp, r1, r8
 800250e:	ea8b 0505 	eor.w	r5, fp, r5
 8002512:	ea29 0b03 	bic.w	fp, r9, r3
 8002516:	ea8b 060e 	eor.w	r6, fp, lr
        Eme = BCe ^ ((~BCi) & BCo);
 800251a:	ea22 0b01 	bic.w	fp, r2, r1
 800251e:	ea8b 0108 	eor.w	r1, fp, r8
        Emu = BCu ^ ((~BCa) & BCe);
 8002522:	f8dd b088 	ldr.w	fp, [sp, #136]	; 0x88
        Eme = BCe ^ ((~BCi) & BCo);
 8002526:	9123      	str	r1, [sp, #140]	; 0x8c
        Emo = BCo ^ ((~BCu) & BCa);
 8002528:	ea2b 010a 	bic.w	r1, fp, sl
 800252c:	4051      	eors	r1, r2
 800252e:	9125      	str	r1, [sp, #148]	; 0x94
        Emi = BCi ^ ((~BCo) & BCu);
 8002530:	9902      	ldr	r1, [sp, #8]
        Esi = BCi ^ ((~BCo) & BCu);
        Eso = BCo ^ ((~BCu) & BCa);
        Esu = BCu ^ ((~BCa) & BCe);

        //    prepareTheta
        BCa = Eba ^ Ega ^ Eka ^ Ema ^ Esa;
 8002532:	9630      	str	r6, [sp, #192]	; 0xc0
        Emi = BCi ^ ((~BCo) & BCu);
 8002534:	ea2a 0202 	bic.w	r2, sl, r2
        Emu = BCu ^ ((~BCa) & BCe);
 8002538:	ea28 080b 	bic.w	r8, r8, fp
        Emi = BCi ^ ((~BCo) & BCu);
 800253c:	404a      	eors	r2, r1
 800253e:	9222      	str	r2, [sp, #136]	; 0x88
        Emu = BCu ^ ((~BCa) & BCe);
 8002540:	ea88 020a 	eor.w	r2, r8, sl
 8002544:	9227      	str	r2, [sp, #156]	; 0x9c
        Eme = BCe ^ ((~BCi) & BCo);
 8002546:	ea2c 0209 	bic.w	r2, ip, r9
 800254a:	405a      	eors	r2, r3
        Emu = BCu ^ ((~BCa) & BCe);
 800254c:	ea23 030e 	bic.w	r3, r3, lr
        Emo = BCo ^ ((~BCu) & BCa);
 8002550:	ea2e 0e04 	bic.w	lr, lr, r4
 8002554:	ea8e 0e0c 	eor.w	lr, lr, ip
        Emi = BCi ^ ((~BCo) & BCu);
 8002558:	ea24 0c0c 	bic.w	ip, r4, ip
 800255c:	ea8c 0c09 	eor.w	ip, ip, r9
 8002560:	f8cd c090 	str.w	ip, [sp, #144]	; 0x90
        Emu = BCu ^ ((~BCa) & BCe);
 8002564:	ea83 0c04 	eor.w	ip, r3, r4
        BCa = Eba ^ Ega ^ Eka ^ Ema ^ Esa;
 8002568:	f8dd 9038 	ldr.w	r9, [sp, #56]	; 0x38
        Emu = BCu ^ ((~BCa) & BCe);
 800256c:	f8cd c0a0 	str.w	ip, [sp, #160]	; 0xa0
        BCa = Eba ^ Ega ^ Eka ^ Ema ^ Esa;
 8002570:	f8dd c010 	ldr.w	ip, [sp, #16]
 8002574:	f8dd 8014 	ldr.w	r8, [sp, #20]
 8002578:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
        Emo = BCo ^ ((~BCu) & BCa);
 800257a:	f8cd e098 	str.w	lr, [sp, #152]	; 0x98
        Eme = BCe ^ ((~BCi) & BCo);
 800257e:	4693      	mov	fp, r2
        BCa = Eba ^ Ega ^ Eka ^ Ema ^ Esa;
 8002580:	ea8c 0909 	eor.w	r9, ip, r9
 8002584:	9a18      	ldr	r2, [sp, #96]	; 0x60
 8002586:	f8dd c068 	ldr.w	ip, [sp, #104]	; 0x68
        BCe = Ebe ^ Ege ^ Eke ^ Eme ^ Ese;
 800258a:	9907      	ldr	r1, [sp, #28]
        BCa = Eba ^ Ega ^ Eka ^ Ema ^ Esa;
 800258c:	952f      	str	r5, [sp, #188]	; 0xbc
 800258e:	ea88 0e03 	eor.w	lr, r8, r3
 8002592:	ea89 090c 	eor.w	r9, r9, ip
 8002596:	ea8e 0e02 	eor.w	lr, lr, r2
        BCe = Ebe ^ Ege ^ Eke ^ Eme ^ Ese;
 800259a:	f8dd c018 	ldr.w	ip, [sp, #24]
 800259e:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80025a0:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 80025a2:	f8cd b0c4 	str.w	fp, [sp, #196]	; 0xc4
        BCa = Eba ^ Ega ^ Eka ^ Ema ^ Esa;
 80025a6:	ea8e 0e06 	eor.w	lr, lr, r6
        BCe = Ebe ^ Ege ^ Eke ^ Eme ^ Ese;
 80025aa:	9e11      	ldr	r6, [sp, #68]	; 0x44
        BCa = Eba ^ Ega ^ Eka ^ Ema ^ Esa;
 80025ac:	ea89 0905 	eor.w	r9, r9, r5
        BCe = Ebe ^ Ege ^ Eke ^ Eme ^ Ese;
 80025b0:	ea8c 0502 	eor.w	r5, ip, r2
 80025b4:	405d      	eors	r5, r3
 80025b6:	ea81 0306 	eor.w	r3, r1, r6
 80025ba:	9919      	ldr	r1, [sp, #100]	; 0x64
 80025bc:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 80025be:	404b      	eors	r3, r1
 80025c0:	ea83 040b 	eor.w	r4, r3, fp
 80025c4:	9434      	str	r4, [sp, #208]	; 0xd0
        BCi = Ebi ^ Egi ^ Eki ^ Emi ^ Esi;
 80025c6:	f8dd 8020 	ldr.w	r8, [sp, #32]
 80025ca:	f8dd b048 	ldr.w	fp, [sp, #72]	; 0x48
 80025ce:	9e09      	ldr	r6, [sp, #36]	; 0x24
 80025d0:	f8dd a074 	ldr.w	sl, [sp, #116]	; 0x74
 80025d4:	9c1c      	ldr	r4, [sp, #112]	; 0x70
 80025d6:	9b22      	ldr	r3, [sp, #136]	; 0x88
 80025d8:	ea88 010b 	eor.w	r1, r8, fp
 80025dc:	f8dd b04c 	ldr.w	fp, [sp, #76]	; 0x4c
        BCo = Ebo ^ Ego ^ Eko ^ Emo ^ Eso;
 80025e0:	f8dd 8050 	ldr.w	r8, [sp, #80]	; 0x50
        BCe = Ebe ^ Ege ^ Eke ^ Eme ^ Ese;
 80025e4:	4055      	eors	r5, r2
        BCi = Ebi ^ Egi ^ Eki ^ Emi ^ Esi;
 80025e6:	ea86 0b0b 	eor.w	fp, r6, fp
 80025ea:	9a24      	ldr	r2, [sp, #144]	; 0x90
        BCu = Ebu ^ Egu ^ Eku ^ Emu ^ Esu;
 80025ec:	9e17      	ldr	r6, [sp, #92]	; 0x5c
        BCi = Ebi ^ Egi ^ Eki ^ Emi ^ Esi;
 80025ee:	ea8b 0b0a 	eor.w	fp, fp, sl
        BCo = Ebo ^ Ego ^ Eko ^ Emo ^ Eso;
 80025f2:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
        BCi = Ebi ^ Egi ^ Eki ^ Emi ^ Esi;
 80025f6:	ea8b 0b02 	eor.w	fp, fp, r2
        BCo = Ebo ^ Ego ^ Eko ^ Emo ^ Eso;
 80025fa:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 80025fc:	ea8a 0c08 	eor.w	ip, sl, r8
        BCi = Ebi ^ Egi ^ Eki ^ Emi ^ Esi;
 8002600:	4061      	eors	r1, r4
        BCo = Ebo ^ Ego ^ Eko ^ Emo ^ Eso;
 8002602:	9c25      	ldr	r4, [sp, #148]	; 0x94
 8002604:	f8dd a054 	ldr.w	sl, [sp, #84]	; 0x54
 8002608:	ea8c 0c02 	eor.w	ip, ip, r2
 800260c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800260e:	ea8c 0c04 	eor.w	ip, ip, r4
 8002612:	9c1f      	ldr	r4, [sp, #124]	; 0x7c
 8002614:	ea82 020a 	eor.w	r2, r2, sl
        BCi = Ebi ^ Egi ^ Eki ^ Emi ^ Esi;
 8002618:	4059      	eors	r1, r3
        BCu = Ebu ^ Egu ^ Eku ^ Emu ^ Esu;
 800261a:	f8dd a058 	ldr.w	sl, [sp, #88]	; 0x58
        BCo = Ebo ^ Ego ^ Eko ^ Emo ^ Eso;
 800261e:	9b26      	ldr	r3, [sp, #152]	; 0x98
 8002620:	4062      	eors	r2, r4
        BCu = Ebu ^ Egu ^ Eku ^ Emu ^ Esu;
 8002622:	9c20      	ldr	r4, [sp, #128]	; 0x80
        BCo = Ebo ^ Ego ^ Eko ^ Emo ^ Eso;
 8002624:	405a      	eors	r2, r3
        BCu = Ebu ^ Egu ^ Eku ^ Emu ^ Esu;
 8002626:	ea8a 0304 	eor.w	r3, sl, r4
 800262a:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 800262c:	f8dd a084 	ldr.w	sl, [sp, #132]	; 0x84
 8002630:	4063      	eors	r3, r4
 8002632:	9c27      	ldr	r4, [sp, #156]	; 0x9c
 8002634:	4063      	eors	r3, r4
 8002636:	ea86 040a 	eor.w	r4, r6, sl
 800263a:	9e0d      	ldr	r6, [sp, #52]	; 0x34
        Esa = BCa ^ ((~BCe) & BCi);
 800263c:	f8dd a0a8 	ldr.w	sl, [sp, #168]	; 0xa8
        BCu = Ebu ^ Egu ^ Eku ^ Emu ^ Esu;
 8002640:	4074      	eors	r4, r6
 8002642:	9e28      	ldr	r6, [sp, #160]	; 0xa0
 8002644:	4074      	eors	r4, r6
        Esa = BCa ^ ((~BCe) & BCi);
 8002646:	9e2e      	ldr	r6, [sp, #184]	; 0xb8
 8002648:	ea26 080a 	bic.w	r8, r6, sl
 800264c:	f8dd a0b4 	ldr.w	sl, [sp, #180]	; 0xb4
 8002650:	ea88 080a 	eor.w	r8, r8, sl
        BCa = Eba ^ Ega ^ Eka ^ Ema ^ Esa;
 8002654:	f8cd 80c8 	str.w	r8, [sp, #200]	; 0xc8
 8002658:	ea89 0808 	eor.w	r8, r9, r8
 800265c:	f8cd 80b4 	str.w	r8, [sp, #180]	; 0xb4
        Esa = BCa ^ ((~BCe) & BCi);
 8002660:	f8dd 90ac 	ldr.w	r9, [sp, #172]	; 0xac
 8002664:	f8dd 8004 	ldr.w	r8, [sp, #4]
 8002668:	ea28 0909 	bic.w	r9, r8, r9
 800266c:	f8dd 80a4 	ldr.w	r8, [sp, #164]	; 0xa4
 8002670:	ea89 0908 	eor.w	r9, r9, r8
        BCa = Eba ^ Ega ^ Eka ^ Ema ^ Esa;
 8002674:	ea8e 0e09 	eor.w	lr, lr, r9
 8002678:	f8cd e0b8 	str.w	lr, [sp, #184]	; 0xb8
        Ese = BCe ^ ((~BCi) & BCo);
 800267c:	46b0      	mov	r8, r6
 800267e:	ea27 0e06 	bic.w	lr, r7, r6
 8002682:	9e2a      	ldr	r6, [sp, #168]	; 0xa8
 8002684:	ea8e 0e06 	eor.w	lr, lr, r6
        Esu = BCu ^ ((~BCa) & BCe);
 8002688:	ea26 060a 	bic.w	r6, r6, sl
        Eso = BCo ^ ((~BCu) & BCa);
 800268c:	ea2a 0a00 	bic.w	sl, sl, r0
 8002690:	ea8a 0a07 	eor.w	sl, sl, r7
 8002694:	f8cd a0a8 	str.w	sl, [sp, #168]	; 0xa8
        Esi = BCi ^ ((~BCo) & BCu);
 8002698:	ea20 0707 	bic.w	r7, r0, r7
        Esu = BCu ^ ((~BCa) & BCe);
 800269c:	4070      	eors	r0, r6
        Esi = BCi ^ ((~BCo) & BCu);
 800269e:	ea87 0a08 	eor.w	sl, r7, r8
        Esu = BCu ^ ((~BCa) & BCe);
 80026a2:	4607      	mov	r7, r0
        BCo = Ebo ^ Ego ^ Eko ^ Emo ^ Eso;
 80026a4:	982a      	ldr	r0, [sp, #168]	; 0xa8
        BCu = Ebu ^ Egu ^ Eku ^ Emu ^ Esu;
 80026a6:	9733      	str	r7, [sp, #204]	; 0xcc
        BCo = Ebo ^ Ego ^ Eko ^ Emo ^ Eso;
 80026a8:	ea8c 0800 	eor.w	r8, ip, r0
        BCe = Ebe ^ Ege ^ Eke ^ Eme ^ Ese;
 80026ac:	ea85 050e 	eor.w	r5, r5, lr
        Ese = BCe ^ ((~BCi) & BCo);
 80026b0:	982c      	ldr	r0, [sp, #176]	; 0xb0
 80026b2:	f8dd c004 	ldr.w	ip, [sp, #4]
        BCe = Ebe ^ Ege ^ Eke ^ Eme ^ Ese;
 80026b6:	9502      	str	r5, [sp, #8]
        BCu = Ebu ^ Egu ^ Eku ^ Emu ^ Esu;
 80026b8:	407b      	eors	r3, r7
        Esu = BCu ^ ((~BCa) & BCe);
 80026ba:	9d29      	ldr	r5, [sp, #164]	; 0xa4
        Ese = BCe ^ ((~BCi) & BCo);
 80026bc:	9f2b      	ldr	r7, [sp, #172]	; 0xac
 80026be:	ea20 060c 	bic.w	r6, r0, ip
 80026c2:	407e      	eors	r6, r7
        Esu = BCu ^ ((~BCa) & BCe);
 80026c4:	ea27 0c05 	bic.w	ip, r7, r5
        Eso = BCo ^ ((~BCu) & BCa);
 80026c8:	9f03      	ldr	r7, [sp, #12]
 80026ca:	ea25 0007 	bic.w	r0, r5, r7
 80026ce:	9d2c      	ldr	r5, [sp, #176]	; 0xb0
 80026d0:	4068      	eors	r0, r5
 80026d2:	9029      	str	r0, [sp, #164]	; 0xa4
        Esi = BCi ^ ((~BCo) & BCu);
 80026d4:	ea27 0005 	bic.w	r0, r7, r5
 80026d8:	9f01      	ldr	r7, [sp, #4]
        BCo = Ebo ^ Ego ^ Eko ^ Emo ^ Eso;
 80026da:	9d29      	ldr	r5, [sp, #164]	; 0xa4
        Esi = BCi ^ ((~BCo) & BCu);
 80026dc:	4078      	eors	r0, r7
        Esu = BCu ^ ((~BCa) & BCe);
 80026de:	9f03      	ldr	r7, [sp, #12]
 80026e0:	ea8c 0707 	eor.w	r7, ip, r7
 80026e4:	46bc      	mov	ip, r7
        BCe = Ebe ^ Ege ^ Eke ^ Eme ^ Ese;
 80026e6:	9f34      	ldr	r7, [sp, #208]	; 0xd0
        BCu = Ebu ^ Egu ^ Eku ^ Emu ^ Esu;
 80026e8:	f8cd c00c 	str.w	ip, [sp, #12]
        BCo = Ebo ^ Ego ^ Eko ^ Emo ^ Eso;
 80026ec:	406a      	eors	r2, r5
        BCu = Ebu ^ Egu ^ Eku ^ Emu ^ Esu;
 80026ee:	4665      	mov	r5, ip
        BCe = Ebe ^ Ege ^ Eke ^ Eme ^ Ese;
 80026f0:	4077      	eors	r7, r6
        BCu = Ebu ^ Egu ^ Eku ^ Emu ^ Esu;
 80026f2:	406c      	eors	r4, r5

        // thetaRhoPiChiIotaPrepareTheta(round+1, E, A)
        Da = BCu ^ ROL(BCe, 1);
 80026f4:	9d02      	ldr	r5, [sp, #8]
 80026f6:	ea4f 0c47 	mov.w	ip, r7, lsl #1
 80026fa:	ea4c 7cd5 	orr.w	ip, ip, r5, lsr #31

        Ebo ^= Do;
        BCa = ROL(Ebo, 28);
        Egu ^= Du;
        BCe = ROL(Egu, 20);
        Eka ^= Da;
 80026fe:	9d18      	ldr	r5, [sp, #96]	; 0x60
        Da = BCu ^ ROL(BCe, 1);
 8002700:	ea8c 0c04 	eor.w	ip, ip, r4
        Eka ^= Da;
 8002704:	ea85 050c 	eor.w	r5, r5, ip
 8002708:	952b      	str	r5, [sp, #172]	; 0xac
        Ako = BCo ^ ((~BCu) & BCa);
        Aku = BCu ^ ((~BCa) & BCe);

        Ebu ^= Du;
        BCa = ROL(Ebu, 27);
        Ega ^= Da;
 800270a:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
        Esa ^= Da;
 800270c:	ea89 090c 	eor.w	r9, r9, ip
 8002710:	f8cd 90d0 	str.w	r9, [sp, #208]	; 0xd0
        Ega ^= Da;
 8002714:	ea85 090c 	eor.w	r9, r5, ip
 8002718:	f8cd 90d4 	str.w	r9, [sp, #212]	; 0xd4
        BCa = ROL(Ebi, 62);
        Ego ^= Do;
        BCe = ROL(Ego, 55);
        Eku ^= Du;
        BCi = ROL(Eku, 39);
        Ema ^= Da;
 800271c:	f8dd 90c0 	ldr.w	r9, [sp, #192]	; 0xc0
        Da = BCu ^ ROL(BCe, 1);
 8002720:	9d02      	ldr	r5, [sp, #8]
        Ema ^= Da;
 8002722:	ea89 090c 	eor.w	r9, r9, ip
 8002726:	f8cd 90e4 	str.w	r9, [sp, #228]	; 0xe4
        Eba ^= Da;
 800272a:	f8dd 9014 	ldr.w	r9, [sp, #20]
 800272e:	ea89 0c0c 	eor.w	ip, r9, ip
 8002732:	f8cd c03c 	str.w	ip, [sp, #60]	; 0x3c
        Da = BCu ^ ROL(BCe, 1);
 8002736:	ea4f 0c45 	mov.w	ip, r5, lsl #1
        Eka ^= Da;
 800273a:	f8dd 9068 	ldr.w	r9, [sp, #104]	; 0x68
        Da = BCu ^ ROL(BCe, 1);
 800273e:	ea4c 7cd7 	orr.w	ip, ip, r7, lsr #31
 8002742:	ea8c 0c03 	eor.w	ip, ip, r3
        Eka ^= Da;
 8002746:	ea89 090c 	eor.w	r9, r9, ip
 800274a:	f8cd 9060 	str.w	r9, [sp, #96]	; 0x60
        Esa ^= Da;
 800274e:	f8dd 90c8 	ldr.w	r9, [sp, #200]	; 0xc8
 8002752:	ea89 090c 	eor.w	r9, r9, ip
 8002756:	f8cd 90c0 	str.w	r9, [sp, #192]	; 0xc0
        Ega ^= Da;
 800275a:	f8dd 9038 	ldr.w	r9, [sp, #56]	; 0x38
        De = BCa ^ ROL(BCi, 1);
 800275e:	9d2e      	ldr	r5, [sp, #184]	; 0xb8
        Ega ^= Da;
 8002760:	ea89 090c 	eor.w	r9, r9, ip
 8002764:	f8cd 90c8 	str.w	r9, [sp, #200]	; 0xc8
        Ema ^= Da;
 8002768:	f8dd 90bc 	ldr.w	r9, [sp, #188]	; 0xbc
 800276c:	ea89 090c 	eor.w	r9, r9, ip
 8002770:	f8cd 90e0 	str.w	r9, [sp, #224]	; 0xe0
        Eba ^= Da;
 8002774:	f8dd 9010 	ldr.w	r9, [sp, #16]
        BCi = Ebi ^ Egi ^ Eki ^ Emi ^ Esi;
 8002778:	ea8b 0b00 	eor.w	fp, fp, r0
 800277c:	ea81 010a 	eor.w	r1, r1, sl
        Eba ^= Da;
 8002780:	ea89 090c 	eor.w	r9, r9, ip
        De = BCa ^ ROL(BCi, 1);
 8002784:	ea4f 0c4b 	mov.w	ip, fp, lsl #1
 8002788:	ea4c 7cd1 	orr.w	ip, ip, r1, lsr #31
 800278c:	ea8c 0c05 	eor.w	ip, ip, r5
        Ege ^= De;
 8002790:	9d11      	ldr	r5, [sp, #68]	; 0x44
 8002792:	ea85 050c 	eor.w	r5, r5, ip
 8002796:	9504      	str	r5, [sp, #16]
        Eme ^= De;
 8002798:	9d31      	ldr	r5, [sp, #196]	; 0xc4
 800279a:	ea85 050c 	eor.w	r5, r5, ip
 800279e:	951a      	str	r5, [sp, #104]	; 0x68
        Ebe ^= De;
 80027a0:	9d07      	ldr	r5, [sp, #28]
 80027a2:	ea85 050c 	eor.w	r5, r5, ip
 80027a6:	952c      	str	r5, [sp, #176]	; 0xb0
        Eke ^= De;
 80027a8:	9d19      	ldr	r5, [sp, #100]	; 0x64
        BCo = ROL(Ema, 41);
        Ese ^= De;
 80027aa:	ea86 060c 	eor.w	r6, r6, ip
        Eke ^= De;
 80027ae:	ea85 050c 	eor.w	r5, r5, ip
 80027b2:	9531      	str	r5, [sp, #196]	; 0xc4
        Ese ^= De;
 80027b4:	963b      	str	r6, [sp, #236]	; 0xec
        De = BCa ^ ROL(BCi, 1);
 80027b6:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 80027b8:	004e      	lsls	r6, r1, #1
 80027ba:	ea46 76db 	orr.w	r6, r6, fp, lsr #31
 80027be:	406e      	eors	r6, r5
        Ege ^= De;
 80027c0:	9d10      	ldr	r5, [sp, #64]	; 0x40
 80027c2:	ea85 0c06 	eor.w	ip, r5, r6
 80027c6:	f8cd c004 	str.w	ip, [sp, #4]
        Eme ^= De;
 80027ca:	f8dd c08c 	ldr.w	ip, [sp, #140]	; 0x8c
        Egi ^= Di;
 80027ce:	9d13      	ldr	r5, [sp, #76]	; 0x4c
        Eme ^= De;
 80027d0:	ea8c 0c06 	eor.w	ip, ip, r6
 80027d4:	f8cd c040 	str.w	ip, [sp, #64]	; 0x40
        Ebe ^= De;
 80027d8:	f8dd c018 	ldr.w	ip, [sp, #24]
 80027dc:	ea8c 0c06 	eor.w	ip, ip, r6
 80027e0:	f8cd c08c 	str.w	ip, [sp, #140]	; 0x8c
        Eke ^= De;
 80027e4:	f8dd c06c 	ldr.w	ip, [sp, #108]	; 0x6c
 80027e8:	ea8c 0c06 	eor.w	ip, ip, r6
 80027ec:	f8cd c0bc 	str.w	ip, [sp, #188]	; 0xbc
        Ese ^= De;
 80027f0:	ea8e 0c06 	eor.w	ip, lr, r6
 80027f4:	f8cd c0e8 	str.w	ip, [sp, #232]	; 0xe8
        Di = BCe ^ ROL(BCo, 1);
 80027f8:	ea4f 0c42 	mov.w	ip, r2, lsl #1
 80027fc:	ea4c 7cd8 	orr.w	ip, ip, r8, lsr #31
 8002800:	ea8c 0707 	eor.w	r7, ip, r7
        Esi ^= Di;
 8002804:	4078      	eors	r0, r7
        Ebi ^= Di;
 8002806:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
        Eki ^= Di;
 800280a:	f8dd e074 	ldr.w	lr, [sp, #116]	; 0x74
        Esi ^= Di;
 800280e:	9019      	str	r0, [sp, #100]	; 0x64
        Egi ^= Di;
 8002810:	ea85 0007 	eor.w	r0, r5, r7
        Emi ^= Di;
 8002814:	9d24      	ldr	r5, [sp, #144]	; 0x90
        Egi ^= Di;
 8002816:	901b      	str	r0, [sp, #108]	; 0x6c
        Eki ^= Di;
 8002818:	ea8e 0e07 	eor.w	lr, lr, r7
        Emi ^= Di;
 800281c:	407d      	eors	r5, r7
        Ebi ^= Di;
 800281e:	ea8c 0707 	eor.w	r7, ip, r7
        Emi ^= Di;
 8002822:	9524      	str	r5, [sp, #144]	; 0x90
        Di = BCe ^ ROL(BCo, 1);
 8002824:	ea4f 0048 	mov.w	r0, r8, lsl #1
        Ebi ^= Di;
 8002828:	9737      	str	r7, [sp, #220]	; 0xdc
        Di = BCe ^ ROL(BCo, 1);
 800282a:	9d02      	ldr	r5, [sp, #8]
        Eki ^= Di;
 800282c:	9f1c      	ldr	r7, [sp, #112]	; 0x70
        Ebi ^= Di;
 800282e:	f8dd c020 	ldr.w	ip, [sp, #32]
        Di = BCe ^ ROL(BCo, 1);
 8002832:	ea40 70d2 	orr.w	r0, r0, r2, lsr #31
 8002836:	4045      	eors	r5, r0
        Eki ^= Di;
 8002838:	406f      	eors	r7, r5
        Do = BCi ^ ROL(BCu, 1);
 800283a:	0060      	lsls	r0, r4, #1
 800283c:	ea40 70d3 	orr.w	r0, r0, r3, lsr #31
        Eki ^= Di;
 8002840:	9706      	str	r7, [sp, #24]
        Do = BCi ^ ROL(BCu, 1);
 8002842:	005b      	lsls	r3, r3, #1
        Esi ^= Di;
 8002844:	ea8a 0705 	eor.w	r7, sl, r5
 8002848:	9713      	str	r7, [sp, #76]	; 0x4c
        Emi ^= Di;
 800284a:	f8dd a088 	ldr.w	sl, [sp, #136]	; 0x88
        Egi ^= Di;
 800284e:	9f12      	ldr	r7, [sp, #72]	; 0x48
        Do = BCi ^ ROL(BCu, 1);
 8002850:	ea43 74d4 	orr.w	r4, r3, r4, lsr #31
        Ebo ^= Do;
 8002854:	9b0a      	ldr	r3, [sp, #40]	; 0x28
        Do = BCi ^ ROL(BCu, 1);
 8002856:	404c      	eors	r4, r1
        Emo ^= Do;
 8002858:	9925      	ldr	r1, [sp, #148]	; 0x94
        Ebi ^= Di;
 800285a:	ea8c 0605 	eor.w	r6, ip, r5
        Egi ^= Di;
 800285e:	406f      	eors	r7, r5
        Emi ^= Di;
 8002860:	ea8a 0a05 	eor.w	sl, sl, r5
        Ebo ^= Do;
 8002864:	ea83 0504 	eor.w	r5, r3, r4
 8002868:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
        Eko ^= Do;
 800286a:	f8dd c078 	ldr.w	ip, [sp, #120]	; 0x78
        Ebi ^= Di;
 800286e:	9636      	str	r6, [sp, #216]	; 0xd8
        Do = BCi ^ ROL(BCu, 1);
 8002870:	ea80 0b0b 	eor.w	fp, r0, fp
        Emo ^= Do;
 8002874:	4061      	eors	r1, r4
        Ebo ^= Do;
 8002876:	ea83 030b 	eor.w	r3, r3, fp
        Emo ^= Do;
 800287a:	9107      	str	r1, [sp, #28]
 800287c:	9926      	ldr	r1, [sp, #152]	; 0x98
        Ebo ^= Do;
 800287e:	930b      	str	r3, [sp, #44]	; 0x2c
        Eko ^= Do;
 8002880:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
        Emo ^= Do;
 8002882:	ea81 000b 	eor.w	r0, r1, fp
        Eko ^= Do;
 8002886:	ea8c 0104 	eor.w	r1, ip, r4
        Eso ^= Do;
 800288a:	f8dd c0a8 	ldr.w	ip, [sp, #168]	; 0xa8
        Eko ^= Do;
 800288e:	911c      	str	r1, [sp, #112]	; 0x70
 8002890:	ea83 030b 	eor.w	r3, r3, fp
 8002894:	931d      	str	r3, [sp, #116]	; 0x74
        Eso ^= Do;
 8002896:	ea8c 0304 	eor.w	r3, ip, r4
 800289a:	9325      	str	r3, [sp, #148]	; 0x94
        Ego ^= Do;
 800289c:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800289e:	ea83 0104 	eor.w	r1, r3, r4
        Eso ^= Do;
 80028a2:	9c29      	ldr	r4, [sp, #164]	; 0xa4
        Ego ^= Do;
 80028a4:	912a      	str	r1, [sp, #168]	; 0xa8
        Eso ^= Do;
 80028a6:	ea84 030b 	eor.w	r3, r4, fp
 80028aa:	9326      	str	r3, [sp, #152]	; 0x98
        Ego ^= Do;
 80028ac:	9b15      	ldr	r3, [sp, #84]	; 0x54
        Du = BCo ^ ROL(BCa, 1);
 80028ae:	9c2e      	ldr	r4, [sp, #184]	; 0xb8
        Ego ^= Do;
 80028b0:	ea83 0b0b 	eor.w	fp, r3, fp
 80028b4:	f8cd b0a4 	str.w	fp, [sp, #164]	; 0xa4
        Du = BCo ^ ROL(BCa, 1);
 80028b8:	f8dd b0b4 	ldr.w	fp, [sp, #180]	; 0xb4
 80028bc:	ea4f 0c4b 	mov.w	ip, fp, lsl #1
 80028c0:	ea4c 7cd4 	orr.w	ip, ip, r4, lsr #31
 80028c4:	ea8c 0c08 	eor.w	ip, ip, r8
 80028c8:	0063      	lsls	r3, r4, #1
        Egu ^= Du;
 80028ca:	f8dd 8058 	ldr.w	r8, [sp, #88]	; 0x58
        Du = BCo ^ ROL(BCa, 1);
 80028ce:	ea43 73db 	orr.w	r3, r3, fp, lsr #31
 80028d2:	405a      	eors	r2, r3
        Esu ^= Du;
 80028d4:	f8dd b0cc 	ldr.w	fp, [sp, #204]	; 0xcc
        Egu ^= Du;
 80028d8:	ea88 030c 	eor.w	r3, r8, ip
 80028dc:	f8dd 805c 	ldr.w	r8, [sp, #92]	; 0x5c
        Esu ^= Du;
 80028e0:	ea8b 060c 	eor.w	r6, fp, ip
        Egu ^= Du;
 80028e4:	ea88 0402 	eor.w	r4, r8, r2
        Esu ^= Du;
 80028e8:	f8dd b00c 	ldr.w	fp, [sp, #12]
        Emu ^= Du;
 80028ec:	f8dd 809c 	ldr.w	r8, [sp, #156]	; 0x9c
 80028f0:	9928      	ldr	r1, [sp, #160]	; 0xa0
        Aba ^= KeccakF_RoundConstants[round + 1];
 80028f2:	f8cd 9014 	str.w	r9, [sp, #20]
        Emu ^= Du;
 80028f6:	4051      	eors	r1, r2
 80028f8:	911e      	str	r1, [sp, #120]	; 0x78
        Ebu ^= Du;
 80028fa:	990c      	ldr	r1, [sp, #48]	; 0x30
 80028fc:	ea81 010c 	eor.w	r1, r1, ip
 8002900:	911f      	str	r1, [sp, #124]	; 0x7c
        Eku ^= Du;
 8002902:	9920      	ldr	r1, [sp, #128]	; 0x80
 8002904:	ea81 010c 	eor.w	r1, r1, ip
        Emu ^= Du;
 8002908:	ea88 080c 	eor.w	r8, r8, ip
        Eku ^= Du;
 800290c:	912d      	str	r1, [sp, #180]	; 0xb4
        Ebu ^= Du;
 800290e:	f8dd c034 	ldr.w	ip, [sp, #52]	; 0x34
        Eku ^= Du;
 8002912:	9921      	ldr	r1, [sp, #132]	; 0x84
        Esu ^= Du;
 8002914:	ea8b 0b02 	eor.w	fp, fp, r2
        Ebu ^= Du;
 8002918:	ea8c 0c02 	eor.w	ip, ip, r2
        Eku ^= Du;
 800291c:	4051      	eors	r1, r2
        Aba ^= KeccakF_RoundConstants[round + 1];
 800291e:	9a00      	ldr	r2, [sp, #0]
        Eku ^= Du;
 8002920:	912e      	str	r1, [sp, #184]	; 0xb8
        Aba ^= KeccakF_RoundConstants[round + 1];
 8002922:	6892      	ldr	r2, [r2, #8]
 8002924:	ea89 0102 	eor.w	r1, r9, r2
 8002928:	f8dd 9000 	ldr.w	r9, [sp]
 800292c:	9109      	str	r1, [sp, #36]	; 0x24
 800292e:	f8d9 200c 	ldr.w	r2, [r9, #12]
    for (round = 0; round < NROUNDS; round += 2) {
 8002932:	f109 0110 	add.w	r1, r9, #16
        Aba ^= KeccakF_RoundConstants[round + 1];
 8002936:	f8dd 903c 	ldr.w	r9, [sp, #60]	; 0x3c
    for (round = 0; round < NROUNDS; round += 2) {
 800293a:	9100      	str	r1, [sp, #0]
        Aba ^= KeccakF_RoundConstants[round + 1];
 800293c:	ea89 0202 	eor.w	r2, r9, r2
 8002940:	9211      	str	r2, [sp, #68]	; 0x44
        BCe = ROL(Ege, 44);
 8002942:	9a01      	ldr	r2, [sp, #4]
 8002944:	9904      	ldr	r1, [sp, #16]
 8002946:	0d12      	lsrs	r2, r2, #20
 8002948:	ea42 3901 	orr.w	r9, r2, r1, lsl #12
 800294c:	0d0a      	lsrs	r2, r1, #20
 800294e:	9901      	ldr	r1, [sp, #4]
 8002950:	f8cd 9008 	str.w	r9, [sp, #8]
 8002954:	ea42 3901 	orr.w	r9, r2, r1, lsl #12
        BCi = ROL(Eki, 43);
 8002958:	9906      	ldr	r1, [sp, #24]
        BCe = ROL(Ege, 44);
 800295a:	f8cd 9010 	str.w	r9, [sp, #16]
        BCi = ROL(Eki, 43);
 800295e:	0d4a      	lsrs	r2, r1, #21
 8002960:	ea42 29ce 	orr.w	r9, r2, lr, lsl #11
 8002964:	ea4f 5e5e 	mov.w	lr, lr, lsr #21
 8002968:	ea4e 2ec1 	orr.w	lr, lr, r1, lsl #11
        BCo = ROL(Emo, 21);
 800296c:	9907      	ldr	r1, [sp, #28]
        BCi = ROL(Eki, 43);
 800296e:	f8cd e018 	str.w	lr, [sp, #24]
        BCo = ROL(Emo, 21);
 8002972:	0542      	lsls	r2, r0, #21
 8002974:	ea42 2ed1 	orr.w	lr, r2, r1, lsr #11
 8002978:	0549      	lsls	r1, r1, #21
 800297a:	ea41 21d0 	orr.w	r1, r1, r0, lsr #11
        BCa = ROL(Ebo, 28);
 800297e:	980b      	ldr	r0, [sp, #44]	; 0x2c
        BCo = ROL(Emo, 21);
 8002980:	f8cd e020 	str.w	lr, [sp, #32]
        BCu = ROL(Esu, 14);
 8002984:	ea4f 328b 	mov.w	r2, fp, lsl #14
 8002988:	ea42 4e96 	orr.w	lr, r2, r6, lsr #18
        BCa = ROL(Ebo, 28);
 800298c:	0702      	lsls	r2, r0, #28
        BCu = ROL(Esu, 14);
 800298e:	f8cd e028 	str.w	lr, [sp, #40]	; 0x28
        BCa = ROL(Ebo, 28);
 8002992:	ea42 1e15 	orr.w	lr, r2, r5, lsr #4
 8002996:	072d      	lsls	r5, r5, #28
 8002998:	ea45 1510 	orr.w	r5, r5, r0, lsr #4
        BCe = ROL(Egu, 20);
 800299c:	0522      	lsls	r2, r4, #20
        BCi = ROL(Eki, 43);
 800299e:	f8cd 900c 	str.w	r9, [sp, #12]
        BCa = ROL(Ebo, 28);
 80029a2:	f8cd e030 	str.w	lr, [sp, #48]	; 0x30
 80029a6:	950b      	str	r5, [sp, #44]	; 0x2c
        BCe = ROL(Egu, 20);
 80029a8:	ea42 3513 	orr.w	r5, r2, r3, lsr #12
        BCi = ROL(Eka, 3);
 80029ac:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 80029ae:	f8dd e060 	ldr.w	lr, [sp, #96]	; 0x60
        BCo = ROL(Eme, 45);
 80029b2:	9810      	ldr	r0, [sp, #64]	; 0x40
        BCe = ROL(Egu, 20);
 80029b4:	950d      	str	r5, [sp, #52]	; 0x34
 80029b6:	051b      	lsls	r3, r3, #20
 80029b8:	ea43 3414 	orr.w	r4, r3, r4, lsr #12
        BCi = ROL(Eka, 3);
 80029bc:	00d3      	lsls	r3, r2, #3
 80029be:	ea43 755e 	orr.w	r5, r3, lr, lsr #29
 80029c2:	4673      	mov	r3, lr
        BCo = ROL(Eme, 45);
 80029c4:	f8dd e068 	ldr.w	lr, [sp, #104]	; 0x68
        BCi = ROL(Eka, 3);
 80029c8:	950e      	str	r5, [sp, #56]	; 0x38
 80029ca:	00dd      	lsls	r5, r3, #3
 80029cc:	ea45 7552 	orr.w	r5, r5, r2, lsr #29
        BCo = ROL(Eme, 45);
 80029d0:	0cc3      	lsrs	r3, r0, #19
 80029d2:	4672      	mov	r2, lr
 80029d4:	ea43 334e 	orr.w	r3, r3, lr, lsl #13
 80029d8:	0cd2      	lsrs	r2, r2, #19
 80029da:	9310      	str	r3, [sp, #64]	; 0x40
 80029dc:	ea42 3340 	orr.w	r3, r2, r0, lsl #13
        BCu = ROL(Esi, 61);
 80029e0:	f8dd e04c 	ldr.w	lr, [sp, #76]	; 0x4c
        BCo = ROL(Eme, 45);
 80029e4:	9312      	str	r3, [sp, #72]	; 0x48
        BCu = ROL(Esi, 61);
 80029e6:	9b19      	ldr	r3, [sp, #100]	; 0x64
        BCu = ROL(Esu, 14);
 80029e8:	03b6      	lsls	r6, r6, #14
 80029ea:	ea46 4b9b 	orr.w	fp, r6, fp, lsr #18
        BCu = ROL(Esi, 61);
 80029ee:	ea4f 09de 	mov.w	r9, lr, lsr #3
        BCa = ROL(Ebe, 1);
 80029f2:	9e2c      	ldr	r6, [sp, #176]	; 0xb0
        BCu = ROL(Esi, 61);
 80029f4:	08d8      	lsrs	r0, r3, #3
 80029f6:	ea49 7943 	orr.w	r9, r9, r3, lsl #29
 80029fa:	ea40 734e 	orr.w	r3, r0, lr, lsl #29
        BCa = ROL(Ebe, 1);
 80029fe:	f8dd e08c 	ldr.w	lr, [sp, #140]	; 0x8c
        BCu = ROL(Esi, 61);
 8002a02:	9314      	str	r3, [sp, #80]	; 0x50
        BCa = ROL(Ebe, 1);
 8002a04:	0072      	lsls	r2, r6, #1
 8002a06:	ea42 73de 	orr.w	r3, r2, lr, lsr #31
 8002a0a:	4672      	mov	r2, lr
 8002a0c:	0050      	lsls	r0, r2, #1
 8002a0e:	ea40 7ed6 	orr.w	lr, r0, r6, lsr #31
        BCe = ROL(Egi, 6);
 8002a12:	981b      	ldr	r0, [sp, #108]	; 0x6c
        BCa = ROL(Ebe, 1);
 8002a14:	f8cd e054 	str.w	lr, [sp, #84]	; 0x54
        BCe = ROL(Egi, 6);
 8002a18:	0182      	lsls	r2, r0, #6
 8002a1a:	ea42 6697 	orr.w	r6, r2, r7, lsr #26
 8002a1e:	9618      	str	r6, [sp, #96]	; 0x60
        BCi = ROL(Eko, 25);
 8002a20:	9e1d      	ldr	r6, [sp, #116]	; 0x74
 8002a22:	f8dd e070 	ldr.w	lr, [sp, #112]	; 0x70
        BCa = ROL(Ebe, 1);
 8002a26:	9316      	str	r3, [sp, #88]	; 0x58
        BCe = ROL(Egi, 6);
 8002a28:	01bf      	lsls	r7, r7, #6
 8002a2a:	ea47 6790 	orr.w	r7, r7, r0, lsr #26
        BCi = ROL(Eko, 25);
 8002a2e:	0672      	lsls	r2, r6, #25
        BCe = ROL(Egi, 6);
 8002a30:	9717      	str	r7, [sp, #92]	; 0x5c
        BCi = ROL(Eko, 25);
 8002a32:	ea42 17de 	orr.w	r7, r2, lr, lsr #7
 8002a36:	971a      	str	r7, [sp, #104]	; 0x68
 8002a38:	4677      	mov	r7, lr
 8002a3a:	0678      	lsls	r0, r7, #25
 8002a3c:	ea40 17d6 	orr.w	r7, r0, r6, lsr #7
        BCo = ROL(Emu, 8);
 8002a40:	981e      	ldr	r0, [sp, #120]	; 0x78
        BCi = ROL(Eko, 25);
 8002a42:	9719      	str	r7, [sp, #100]	; 0x64
        BCo = ROL(Emu, 8);
 8002a44:	0202      	lsls	r2, r0, #8
 8002a46:	ea42 6718 	orr.w	r7, r2, r8, lsr #24
        BCu = ROL(Esa, 18);
 8002a4a:	9a34      	ldr	r2, [sp, #208]	; 0xd0
        BCo = ROL(Emu, 8);
 8002a4c:	971b      	str	r7, [sp, #108]	; 0x6c
 8002a4e:	ea4f 2808 	mov.w	r8, r8, lsl #8
        BCu = ROL(Esa, 18);
 8002a52:	9f30      	ldr	r7, [sp, #192]	; 0xc0
        BCo = ROL(Emu, 8);
 8002a54:	ea48 6810 	orr.w	r8, r8, r0, lsr #24
        BCu = ROL(Esa, 18);
 8002a58:	0490      	lsls	r0, r2, #18
 8002a5a:	ea40 3697 	orr.w	r6, r0, r7, lsr #14
 8002a5e:	04bf      	lsls	r7, r7, #18
 8002a60:	ea47 3792 	orr.w	r7, r7, r2, lsr #14
        BCa = ROL(Ebu, 27);
 8002a64:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
        BCu = ROL(Esa, 18);
 8002a66:	961d      	str	r6, [sp, #116]	; 0x74
        BCa = ROL(Ebu, 27);
 8002a68:	ea4f 60cc 	mov.w	r0, ip, lsl #27
 8002a6c:	ea40 1e52 	orr.w	lr, r0, r2, lsr #5
        BCe = ROL(Ega, 36);
 8002a70:	9e32      	ldr	r6, [sp, #200]	; 0xc8
        BCa = ROL(Ebu, 27);
 8002a72:	f8cd e07c 	str.w	lr, [sp, #124]	; 0x7c
 8002a76:	ea4f 6ec2 	mov.w	lr, r2, lsl #27
 8002a7a:	ea4e 1c5c 	orr.w	ip, lr, ip, lsr #5
        BCe = ROL(Ega, 36);
 8002a7e:	f8dd e0d4 	ldr.w	lr, [sp, #212]	; 0xd4
        BCa = ROL(Ebu, 27);
 8002a82:	f8cd c078 	str.w	ip, [sp, #120]	; 0x78
        BCe = ROL(Ega, 36);
 8002a86:	0f32      	lsrs	r2, r6, #28
 8002a88:	ea42 1c0e 	orr.w	ip, r2, lr, lsl #4
 8002a8c:	4672      	mov	r2, lr
 8002a8e:	0f10      	lsrs	r0, r2, #28
 8002a90:	f8cd c080 	str.w	ip, [sp, #128]	; 0x80
 8002a94:	ea40 1c06 	orr.w	ip, r0, r6, lsl #4
        BCi = ROL(Eke, 10);
 8002a98:	9831      	ldr	r0, [sp, #196]	; 0xc4
 8002a9a:	9e2f      	ldr	r6, [sp, #188]	; 0xbc
        BCe = ROL(Ega, 36);
 8002a9c:	f8cd c084 	str.w	ip, [sp, #132]	; 0x84
        BCi = ROL(Eke, 10);
 8002aa0:	0282      	lsls	r2, r0, #10
 8002aa2:	ea42 5c96 	orr.w	ip, r2, r6, lsr #22
 8002aa6:	02b2      	lsls	r2, r6, #10
 8002aa8:	ea42 5690 	orr.w	r6, r2, r0, lsr #22
        BCo = ROL(Emi, 15);
 8002aac:	9824      	ldr	r0, [sp, #144]	; 0x90
        BCi = ROL(Eke, 10);
 8002aae:	f8cd c08c 	str.w	ip, [sp, #140]	; 0x8c
        BCo = ROL(Emi, 15);
 8002ab2:	03c2      	lsls	r2, r0, #15
 8002ab4:	ea42 4c5a 	orr.w	ip, r2, sl, lsr #17
        BCu = ROL(Eso, 56);
 8002ab8:	9a26      	ldr	r2, [sp, #152]	; 0x98
 8002aba:	f8dd e094 	ldr.w	lr, [sp, #148]	; 0x94
        BCi = ROL(Eke, 10);
 8002abe:	9622      	str	r6, [sp, #136]	; 0x88
        BCo = ROL(Emi, 15);
 8002ac0:	ea4f 3aca 	mov.w	sl, sl, lsl #15
 8002ac4:	ea4a 4a50 	orr.w	sl, sl, r0, lsr #17
        BCu = ROL(Eso, 56);
 8002ac8:	0a10      	lsrs	r0, r2, #8
 8002aca:	ea40 660e 	orr.w	r6, r0, lr, lsl #24
 8002ace:	9626      	str	r6, [sp, #152]	; 0x98
        BCa = ROL(Ebi, 62);
 8002ad0:	9e36      	ldr	r6, [sp, #216]	; 0xd8
 8002ad2:	9b37      	ldr	r3, [sp, #220]	; 0xdc
        BCo = ROL(Emi, 15);
 8002ad4:	f8cd c090 	str.w	ip, [sp, #144]	; 0x90
        BCu = ROL(Eso, 56);
 8002ad8:	ea4f 2c1e 	mov.w	ip, lr, lsr #8
 8002adc:	ea4c 6c02 	orr.w	ip, ip, r2, lsl #24
        BCa = ROL(Ebi, 62);
 8002ae0:	08b2      	lsrs	r2, r6, #2
 8002ae2:	ea42 7e83 	orr.w	lr, r2, r3, lsl #30
 8002ae6:	0898      	lsrs	r0, r3, #2
        BCe = ROL(Ego, 55);
 8002ae8:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
        BCa = ROL(Ebi, 62);
 8002aea:	f8cd e09c 	str.w	lr, [sp, #156]	; 0x9c
 8002aee:	ea40 7686 	orr.w	r6, r0, r6, lsl #30
        BCe = ROL(Ego, 55);
 8002af2:	f8dd e0a4 	ldr.w	lr, [sp, #164]	; 0xa4
        BCa = ROL(Ebi, 62);
 8002af6:	9628      	str	r6, [sp, #160]	; 0xa0
        BCe = ROL(Ego, 55);
 8002af8:	0a56      	lsrs	r6, r2, #9
 8002afa:	ea46 50ce 	orr.w	r0, r6, lr, lsl #23
 8002afe:	4676      	mov	r6, lr
 8002b00:	9029      	str	r0, [sp, #164]	; 0xa4
 8002b02:	0a76      	lsrs	r6, r6, #9
        BCi = ROL(Eku, 39);
 8002b04:	982d      	ldr	r0, [sp, #180]	; 0xb4
        Aba ^= KeccakF_RoundConstants[round + 1];
 8002b06:	9b09      	ldr	r3, [sp, #36]	; 0x24
        BCe = ROL(Ego, 55);
 8002b08:	ea46 52c2 	orr.w	r2, r6, r2, lsl #23
        BCi = ROL(Eku, 39);
 8002b0c:	9e2e      	ldr	r6, [sp, #184]	; 0xb8
        BCe = ROL(Ego, 55);
 8002b0e:	922a      	str	r2, [sp, #168]	; 0xa8
        BCi = ROL(Eku, 39);
 8002b10:	0e42      	lsrs	r2, r0, #25
 8002b12:	ea42 12c6 	orr.w	r2, r2, r6, lsl #7
 8002b16:	922b      	str	r2, [sp, #172]	; 0xac
 8002b18:	0e72      	lsrs	r2, r6, #25
 8002b1a:	ea42 16c0 	orr.w	r6, r2, r0, lsl #7
 8002b1e:	962c      	str	r6, [sp, #176]	; 0xb0
        BCo = ROL(Ema, 41);
 8002b20:	9839      	ldr	r0, [sp, #228]	; 0xe4
 8002b22:	9e38      	ldr	r6, [sp, #224]	; 0xe0
 8002b24:	0dc2      	lsrs	r2, r0, #23
 8002b26:	ea4f 5ed6 	mov.w	lr, r6, lsr #23
 8002b2a:	ea4e 2e40 	orr.w	lr, lr, r0, lsl #9
 8002b2e:	ea42 2046 	orr.w	r0, r2, r6, lsl #9
        BCu = ROL(Ese, 2);
 8002b32:	9a3b      	ldr	r2, [sp, #236]	; 0xec
        BCo = ROL(Ema, 41);
 8002b34:	902d      	str	r0, [sp, #180]	; 0xb4
        BCu = ROL(Ese, 2);
 8002b36:	983a      	ldr	r0, [sp, #232]	; 0xe8
 8002b38:	0096      	lsls	r6, r2, #2
 8002b3a:	ea46 7690 	orr.w	r6, r6, r0, lsr #30
 8002b3e:	962e      	str	r6, [sp, #184]	; 0xb8
 8002b40:	0086      	lsls	r6, r0, #2
 8002b42:	ea46 7692 	orr.w	r6, r6, r2, lsr #30
        Aba = BCa ^ ((~BCe) & BCi);
 8002b46:	e9dd 0202 	ldrd	r0, r2, [sp, #8]
 8002b4a:	ea22 0200 	bic.w	r2, r2, r0
        Aba ^= KeccakF_RoundConstants[round + 1];
 8002b4e:	405a      	eors	r2, r3
 8002b50:	9201      	str	r2, [sp, #4]
        Aba = BCa ^ ((~BCe) & BCi);
 8002b52:	9b06      	ldr	r3, [sp, #24]
 8002b54:	9a04      	ldr	r2, [sp, #16]
 8002b56:	ea23 0202 	bic.w	r2, r3, r2
        Aba ^= KeccakF_RoundConstants[round + 1];
 8002b5a:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8002b5c:	405a      	eors	r2, r3
        Abe = BCe ^ ((~BCi) & BCo);
 8002b5e:	9b03      	ldr	r3, [sp, #12]
        Aba ^= KeccakF_RoundConstants[round + 1];
 8002b60:	9202      	str	r2, [sp, #8]
        Abe = BCe ^ ((~BCi) & BCo);
 8002b62:	ea21 0203 	bic.w	r2, r1, r3
 8002b66:	4042      	eors	r2, r0
 8002b68:	9203      	str	r2, [sp, #12]
        Abu = BCu ^ ((~BCa) & BCe);
 8002b6a:	4602      	mov	r2, r0
 8002b6c:	9805      	ldr	r0, [sp, #20]
 8002b6e:	ea22 0200 	bic.w	r2, r2, r0
        Abo = BCo ^ ((~BCu) & BCa);
 8002b72:	ea20 000b 	bic.w	r0, r0, fp
 8002b76:	4048      	eors	r0, r1
        Abi = BCi ^ ((~BCo) & BCu);
 8002b78:	ea2b 0101 	bic.w	r1, fp, r1
        Abo = BCo ^ ((~BCu) & BCa);
 8002b7c:	9007      	str	r0, [sp, #28]
        Abi = BCi ^ ((~BCo) & BCu);
 8002b7e:	ea81 0003 	eor.w	r0, r1, r3
        Abu = BCu ^ ((~BCa) & BCe);
 8002b82:	ea82 0b0b 	eor.w	fp, r2, fp
        Abe = BCe ^ ((~BCi) & BCo);
 8002b86:	9b06      	ldr	r3, [sp, #24]
        Abi = BCi ^ ((~BCo) & BCu);
 8002b88:	9005      	str	r0, [sp, #20]
        Abe = BCe ^ ((~BCi) & BCo);
 8002b8a:	9808      	ldr	r0, [sp, #32]
        Abu = BCu ^ ((~BCa) & BCe);
 8002b8c:	f8cd b024 	str.w	fp, [sp, #36]	; 0x24
        Abe = BCe ^ ((~BCi) & BCo);
 8002b90:	f8dd b010 	ldr.w	fp, [sp, #16]
        Abu = BCu ^ ((~BCa) & BCe);
 8002b94:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
        Abe = BCe ^ ((~BCi) & BCo);
 8002b96:	ea20 0003 	bic.w	r0, r0, r3
 8002b9a:	ea80 000b 	eor.w	r0, r0, fp
 8002b9e:	9004      	str	r0, [sp, #16]
        Abu = BCu ^ ((~BCa) & BCe);
 8002ba0:	ea2b 0002 	bic.w	r0, fp, r2
        Abo = BCo ^ ((~BCu) & BCa);
 8002ba4:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
 8002ba8:	ea22 010b 	bic.w	r1, r2, fp
 8002bac:	9a08      	ldr	r2, [sp, #32]
 8002bae:	4051      	eors	r1, r2
        Abi = BCi ^ ((~BCo) & BCu);
 8002bb0:	ea2b 0202 	bic.w	r2, fp, r2
 8002bb4:	405a      	eors	r2, r3
        Aga = BCa ^ ((~BCe) & BCi);
 8002bb6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
        Abi = BCi ^ ((~BCo) & BCu);
 8002bb8:	9206      	str	r2, [sp, #24]
        Abu = BCu ^ ((~BCa) & BCe);
 8002bba:	ea80 0b0b 	eor.w	fp, r0, fp
        Aga = BCa ^ ((~BCe) & BCi);
 8002bbe:	ea25 0204 	bic.w	r2, r5, r4
        Abu = BCu ^ ((~BCa) & BCe);
 8002bc2:	f8cd b028 	str.w	fp, [sp, #40]	; 0x28
        Aga = BCa ^ ((~BCe) & BCi);
 8002bc6:	ea82 0b03 	eor.w	fp, r2, r3
        Abo = BCo ^ ((~BCu) & BCa);
 8002bca:	9108      	str	r1, [sp, #32]
        Aga = BCa ^ ((~BCe) & BCi);
 8002bcc:	f8cd b02c 	str.w	fp, [sp, #44]	; 0x2c
 8002bd0:	e9dd 1b0d 	ldrd	r1, fp, [sp, #52]	; 0x34
 8002bd4:	980c      	ldr	r0, [sp, #48]	; 0x30
 8002bd6:	ea2b 0201 	bic.w	r2, fp, r1
 8002bda:	ea82 0b00 	eor.w	fp, r2, r0
        Age = BCe ^ ((~BCi) & BCo);
 8002bde:	9a10      	ldr	r2, [sp, #64]	; 0x40
        Aga = BCa ^ ((~BCe) & BCi);
 8002be0:	f8cd b030 	str.w	fp, [sp, #48]	; 0x30
        Age = BCe ^ ((~BCi) & BCo);
 8002be4:	ea22 0205 	bic.w	r2, r2, r5
 8002be8:	ea82 0b04 	eor.w	fp, r2, r4
 8002bec:	f8cd b034 	str.w	fp, [sp, #52]	; 0x34
        Agu = BCu ^ ((~BCa) & BCe);
 8002bf0:	ea24 0403 	bic.w	r4, r4, r3
        Ago = BCo ^ ((~BCu) & BCa);
 8002bf4:	ea23 0b09 	bic.w	fp, r3, r9
 8002bf8:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8002bfa:	ea8b 0b03 	eor.w	fp, fp, r3
        Agi = BCi ^ ((~BCo) & BCu);
 8002bfe:	ea29 0303 	bic.w	r3, r9, r3
        Ago = BCo ^ ((~BCu) & BCa);
 8002c02:	f8cd b044 	str.w	fp, [sp, #68]	; 0x44
        Agi = BCi ^ ((~BCo) & BCu);
 8002c06:	ea83 0b05 	eor.w	fp, r3, r5
 8002c0a:	f8cd b03c 	str.w	fp, [sp, #60]	; 0x3c
        Agu = BCu ^ ((~BCa) & BCe);
 8002c0e:	ea84 0b09 	eor.w	fp, r4, r9
 8002c12:	f8cd b04c 	str.w	fp, [sp, #76]	; 0x4c
        Age = BCe ^ ((~BCi) & BCo);
 8002c16:	9d12      	ldr	r5, [sp, #72]	; 0x48
 8002c18:	9c0e      	ldr	r4, [sp, #56]	; 0x38
        Ago = BCo ^ ((~BCu) & BCa);
 8002c1a:	f8dd 9050 	ldr.w	r9, [sp, #80]	; 0x50
        Age = BCe ^ ((~BCi) & BCo);
 8002c1e:	ea25 0b04 	bic.w	fp, r5, r4
        Ago = BCo ^ ((~BCu) & BCa);
 8002c22:	ea20 0209 	bic.w	r2, r0, r9
        Age = BCe ^ ((~BCi) & BCo);
 8002c26:	ea8b 0b01 	eor.w	fp, fp, r1
 8002c2a:	f8cd b038 	str.w	fp, [sp, #56]	; 0x38
        Ago = BCo ^ ((~BCu) & BCa);
 8002c2e:	ea82 0b05 	eor.w	fp, r2, r5
 8002c32:	f8cd b048 	str.w	fp, [sp, #72]	; 0x48
        Agi = BCi ^ ((~BCo) & BCu);
 8002c36:	ea29 0b05 	bic.w	fp, r9, r5
        Agu = BCu ^ ((~BCa) & BCe);
 8002c3a:	ea21 0300 	bic.w	r3, r1, r0
        Agi = BCi ^ ((~BCo) & BCu);
 8002c3e:	ea8b 0b04 	eor.w	fp, fp, r4
        Aka = BCa ^ ((~BCe) & BCi);
 8002c42:	9919      	ldr	r1, [sp, #100]	; 0x64
 8002c44:	9c17      	ldr	r4, [sp, #92]	; 0x5c
 8002c46:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8002c48:	9818      	ldr	r0, [sp, #96]	; 0x60
        Agi = BCi ^ ((~BCo) & BCu);
 8002c4a:	f8cd b040 	str.w	fp, [sp, #64]	; 0x40
        Agu = BCu ^ ((~BCa) & BCe);
 8002c4e:	ea83 0b09 	eor.w	fp, r3, r9
        Aka = BCa ^ ((~BCe) & BCi);
 8002c52:	f8dd 9068 	ldr.w	r9, [sp, #104]	; 0x68
 8002c56:	9b16      	ldr	r3, [sp, #88]	; 0x58
        Agu = BCu ^ ((~BCa) & BCe);
 8002c58:	f8cd b050 	str.w	fp, [sp, #80]	; 0x50
        Aka = BCa ^ ((~BCe) & BCi);
 8002c5c:	ea21 0504 	bic.w	r5, r1, r4
 8002c60:	ea85 0b02 	eor.w	fp, r5, r2
 8002c64:	ea29 0500 	bic.w	r5, r9, r0
 8002c68:	f8cd b054 	str.w	fp, [sp, #84]	; 0x54
 8002c6c:	ea85 0b03 	eor.w	fp, r5, r3
        Ake = BCe ^ ((~BCi) & BCo);
 8002c70:	ea28 0501 	bic.w	r5, r8, r1
        Aka = BCa ^ ((~BCe) & BCi);
 8002c74:	f8cd b0bc 	str.w	fp, [sp, #188]	; 0xbc
        Ake = BCe ^ ((~BCi) & BCo);
 8002c78:	ea85 0b04 	eor.w	fp, r5, r4
 8002c7c:	f8cd b058 	str.w	fp, [sp, #88]	; 0x58
        Ako = BCo ^ ((~BCu) & BCa);
 8002c80:	ea22 0b07 	bic.w	fp, r2, r7
        Aku = BCu ^ ((~BCa) & BCe);
 8002c84:	ea24 0502 	bic.w	r5, r4, r2
        Ako = BCo ^ ((~BCu) & BCa);
 8002c88:	ea8b 0b08 	eor.w	fp, fp, r8
        Ake = BCe ^ ((~BCi) & BCo);
 8002c8c:	9c1b      	ldr	r4, [sp, #108]	; 0x6c
        Ako = BCo ^ ((~BCu) & BCa);
 8002c8e:	f8cd b068 	str.w	fp, [sp, #104]	; 0x68
        Aki = BCi ^ ((~BCo) & BCu);
 8002c92:	ea27 0808 	bic.w	r8, r7, r8
 8002c96:	ea88 0b01 	eor.w	fp, r8, r1
 8002c9a:	f8cd b060 	str.w	fp, [sp, #96]	; 0x60
        Aku = BCu ^ ((~BCa) & BCe);
 8002c9e:	ea85 0b07 	eor.w	fp, r5, r7
        Ake = BCe ^ ((~BCi) & BCo);
 8002ca2:	ea24 0509 	bic.w	r5, r4, r9
        Aku = BCu ^ ((~BCa) & BCe);
 8002ca6:	f8cd b070 	str.w	fp, [sp, #112]	; 0x70
        Ake = BCe ^ ((~BCi) & BCo);
 8002caa:	ea85 0b00 	eor.w	fp, r5, r0
        Ako = BCo ^ ((~BCu) & BCa);
 8002cae:	9d1d      	ldr	r5, [sp, #116]	; 0x74
        Ake = BCe ^ ((~BCi) & BCo);
 8002cb0:	f8cd b05c 	str.w	fp, [sp, #92]	; 0x5c
        Ako = BCo ^ ((~BCu) & BCa);
 8002cb4:	ea23 0205 	bic.w	r2, r3, r5
 8002cb8:	ea82 0b04 	eor.w	fp, r2, r4
        Aki = BCi ^ ((~BCo) & BCu);
 8002cbc:	ea25 0204 	bic.w	r2, r5, r4
        Aku = BCu ^ ((~BCa) & BCe);
 8002cc0:	ea20 0003 	bic.w	r0, r0, r3
        Ako = BCo ^ ((~BCu) & BCa);
 8002cc4:	f8cd b06c 	str.w	fp, [sp, #108]	; 0x6c
        Aki = BCi ^ ((~BCo) & BCu);
 8002cc8:	ea82 0b09 	eor.w	fp, r2, r9
 8002ccc:	f8cd b064 	str.w	fp, [sp, #100]	; 0x64
        Ama = BCa ^ ((~BCe) & BCi);
 8002cd0:	f8dd 9088 	ldr.w	r9, [sp, #136]	; 0x88
 8002cd4:	9c1e      	ldr	r4, [sp, #120]	; 0x78
 8002cd6:	f8dd 808c 	ldr.w	r8, [sp, #140]	; 0x8c
 8002cda:	9f21      	ldr	r7, [sp, #132]	; 0x84
 8002cdc:	991f      	ldr	r1, [sp, #124]	; 0x7c
        Aku = BCu ^ ((~BCa) & BCe);
 8002cde:	ea80 0b05 	eor.w	fp, r0, r5
        Ama = BCa ^ ((~BCe) & BCi);
 8002ce2:	9d20      	ldr	r5, [sp, #128]	; 0x80
        Aku = BCu ^ ((~BCa) & BCe);
 8002ce4:	f8cd b074 	str.w	fp, [sp, #116]	; 0x74
        Ama = BCa ^ ((~BCe) & BCi);
 8002ce8:	ea29 0005 	bic.w	r0, r9, r5
 8002cec:	ea80 0b04 	eor.w	fp, r0, r4
        Ame = BCe ^ ((~BCi) & BCo);
 8002cf0:	ea2a 0309 	bic.w	r3, sl, r9
        Ama = BCa ^ ((~BCe) & BCi);
 8002cf4:	f8cd b078 	str.w	fp, [sp, #120]	; 0x78
        Ame = BCe ^ ((~BCi) & BCo);
 8002cf8:	ea83 0b05 	eor.w	fp, r3, r5
 8002cfc:	f8cd b07c 	str.w	fp, [sp, #124]	; 0x7c
        Amo = BCo ^ ((~BCu) & BCa);
 8002d00:	ea24 000c 	bic.w	r0, r4, ip
        Amu = BCu ^ ((~BCa) & BCe);
 8002d04:	ea25 0b04 	bic.w	fp, r5, r4
        Ame = BCe ^ ((~BCi) & BCo);
 8002d08:	9d24      	ldr	r5, [sp, #144]	; 0x90
        Amo = BCo ^ ((~BCu) & BCa);
 8002d0a:	ea80 040a 	eor.w	r4, r0, sl
        Ami = BCi ^ ((~BCo) & BCu);
 8002d0e:	ea2c 0a0a 	bic.w	sl, ip, sl
        Ame = BCe ^ ((~BCi) & BCo);
 8002d12:	ea25 0308 	bic.w	r3, r5, r8
        Amo = BCo ^ ((~BCu) & BCa);
 8002d16:	9423      	str	r4, [sp, #140]	; 0x8c
        Ami = BCi ^ ((~BCo) & BCu);
 8002d18:	ea8a 0409 	eor.w	r4, sl, r9
        Ama = BCa ^ ((~BCe) & BCi);
 8002d1c:	ea28 0207 	bic.w	r2, r8, r7
        Ami = BCi ^ ((~BCo) & BCu);
 8002d20:	9421      	str	r4, [sp, #132]	; 0x84
        Amu = BCu ^ ((~BCa) & BCe);
 8002d22:	ea8b 040c 	eor.w	r4, fp, ip
        Ame = BCe ^ ((~BCi) & BCo);
 8002d26:	ea83 0c07 	eor.w	ip, r3, r7
        Amu = BCu ^ ((~BCa) & BCe);
 8002d2a:	ea27 0001 	bic.w	r0, r7, r1
        Ama = BCa ^ ((~BCe) & BCi);
 8002d2e:	404a      	eors	r2, r1
        Ame = BCe ^ ((~BCi) & BCo);
 8002d30:	f8cd c080 	str.w	ip, [sp, #128]	; 0x80
        Amu = BCu ^ ((~BCa) & BCe);
 8002d34:	468c      	mov	ip, r1
        Amo = BCo ^ ((~BCu) & BCa);
 8002d36:	9926      	ldr	r1, [sp, #152]	; 0x98
        Amu = BCu ^ ((~BCa) & BCe);
 8002d38:	9425      	str	r4, [sp, #148]	; 0x94
        Ami = BCi ^ ((~BCo) & BCu);
 8002d3a:	ea21 0305 	bic.w	r3, r1, r5
        Ame = BCe ^ ((~BCi) & BCo);
 8002d3e:	4644      	mov	r4, r8
        Amo = BCo ^ ((~BCu) & BCa);
 8002d40:	ea2c 0801 	bic.w	r8, ip, r1
 8002d44:	ea88 0c05 	eor.w	ip, r8, r5
        Ami = BCi ^ ((~BCo) & BCu);
 8002d48:	405c      	eors	r4, r3
        Asa = BCa ^ ((~BCe) & BCi);
 8002d4a:	f8dd 80ac 	ldr.w	r8, [sp, #172]	; 0xac
 8002d4e:	9b27      	ldr	r3, [sp, #156]	; 0x9c
        Ami = BCi ^ ((~BCo) & BCu);
 8002d50:	9422      	str	r4, [sp, #136]	; 0x88
        Amu = BCu ^ ((~BCa) & BCe);
 8002d52:	ea80 0401 	eor.w	r4, r0, r1
        Asa = BCa ^ ((~BCe) & BCi);
 8002d56:	9929      	ldr	r1, [sp, #164]	; 0xa4
        Amo = BCo ^ ((~BCu) & BCa);
 8002d58:	f8cd c090 	str.w	ip, [sp, #144]	; 0x90
        Ase = BCe ^ ((~BCi) & BCo);
 8002d5c:	ea2e 0008 	bic.w	r0, lr, r8
        Asa = BCa ^ ((~BCe) & BCi);
 8002d60:	ea28 0c01 	bic.w	ip, r8, r1
        Amu = BCu ^ ((~BCa) & BCe);
 8002d64:	9426      	str	r4, [sp, #152]	; 0x98
        Ase = BCe ^ ((~BCi) & BCo);
 8002d66:	ea80 0401 	eor.w	r4, r0, r1
        Asi = BCi ^ ((~BCo) & BCu);
        Aso = BCo ^ ((~BCu) & BCa);
        Asu = BCu ^ ((~BCa) & BCe);
 8002d6a:	4608      	mov	r0, r1
 8002d6c:	4619      	mov	r1, r3
        Ase = BCe ^ ((~BCi) & BCo);
 8002d6e:	9427      	str	r4, [sp, #156]	; 0x9c
        Aso = BCo ^ ((~BCu) & BCa);
 8002d70:	ea21 0406 	bic.w	r4, r1, r6
 8002d74:	ea84 040e 	eor.w	r4, r4, lr
        Asi = BCi ^ ((~BCo) & BCu);
 8002d78:	ea26 0e0e 	bic.w	lr, r6, lr
        Asa = BCa ^ ((~BCe) & BCi);
 8002d7c:	9f2a      	ldr	r7, [sp, #168]	; 0xa8
        Aso = BCo ^ ((~BCu) & BCa);
 8002d7e:	942a      	str	r4, [sp, #168]	; 0xa8
        Asa = BCa ^ ((~BCe) & BCi);
 8002d80:	ea8c 0c03 	eor.w	ip, ip, r3
        Asi = BCi ^ ((~BCo) & BCu);
 8002d84:	ea8e 0408 	eor.w	r4, lr, r8
        Asu = BCu ^ ((~BCa) & BCe);
 8002d88:	ea20 0303 	bic.w	r3, r0, r3
        Asa = BCa ^ ((~BCe) & BCi);
 8002d8c:	9d28      	ldr	r5, [sp, #160]	; 0xa0
        Aso = BCo ^ ((~BCu) & BCa);
 8002d8e:	992e      	ldr	r1, [sp, #184]	; 0xb8
        Asi = BCi ^ ((~BCo) & BCu);
 8002d90:	9428      	str	r4, [sp, #160]	; 0xa0
        Asu = BCu ^ ((~BCa) & BCe);
 8002d92:	ea83 0406 	eor.w	r4, r3, r6
        Ase = BCe ^ ((~BCi) & BCo);
 8002d96:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
        Asa = BCa ^ ((~BCe) & BCi);
 8002d98:	f8dd 90b0 	ldr.w	r9, [sp, #176]	; 0xb0
        Asu = BCu ^ ((~BCa) & BCe);
 8002d9c:	942c      	str	r4, [sp, #176]	; 0xb0
        Aso = BCo ^ ((~BCu) & BCa);
 8002d9e:	ea25 0001 	bic.w	r0, r5, r1
        Asi = BCi ^ ((~BCo) & BCu);
 8002da2:	ea21 0403 	bic.w	r4, r1, r3
        Ase = BCe ^ ((~BCi) & BCo);
 8002da6:	ea23 0a09 	bic.w	sl, r3, r9
        Aso = BCo ^ ((~BCu) & BCa);
 8002daa:	4058      	eors	r0, r3
        Asu = BCu ^ ((~BCa) & BCe);
 8002dac:	ea27 0605 	bic.w	r6, r7, r5
        Asi = BCi ^ ((~BCo) & BCu);
 8002db0:	ea84 0309 	eor.w	r3, r4, r9
 8002db4:	9329      	str	r3, [sp, #164]	; 0xa4
        Asu = BCu ^ ((~BCa) & BCe);
 8002db6:	ea86 0301 	eor.w	r3, r6, r1
 8002dba:	932d      	str	r3, [sp, #180]	; 0xb4
    for (round = 0; round < NROUNDS; round += 2) {
 8002dbc:	9900      	ldr	r1, [sp, #0]
 8002dbe:	4b3e      	ldr	r3, [pc, #248]	; (8002eb8 <KeccakF1600_StatePermute+0x1124>)
        Aso = BCo ^ ((~BCu) & BCa);
 8002dc0:	902b      	str	r0, [sp, #172]	; 0xac
        Asa = BCa ^ ((~BCe) & BCi);
 8002dc2:	ea29 0b07 	bic.w	fp, r9, r7
    for (round = 0; round < NROUNDS; round += 2) {
 8002dc6:	428b      	cmp	r3, r1
        Asa = BCa ^ ((~BCe) & BCi);
 8002dc8:	ea8b 0b05 	eor.w	fp, fp, r5
        Ase = BCe ^ ((~BCi) & BCo);
 8002dcc:	ea8a 0a07 	eor.w	sl, sl, r7
    for (round = 0; round < NROUNDS; round += 2) {
 8002dd0:	f47f a858 	bne.w	8001e84 <KeccakF1600_StatePermute+0xf0>
    }

    // copyToState(state, A)
    state[0] = Aba;
 8002dd4:	9b3f      	ldr	r3, [sp, #252]	; 0xfc
 8002dd6:	4691      	mov	r9, r2
 8002dd8:	9a01      	ldr	r2, [sp, #4]
 8002dda:	601a      	str	r2, [r3, #0]
 8002ddc:	9a02      	ldr	r2, [sp, #8]
 8002dde:	605a      	str	r2, [r3, #4]
    state[1] = Abe;
 8002de0:	9a03      	ldr	r2, [sp, #12]
 8002de2:	609a      	str	r2, [r3, #8]
 8002de4:	9a04      	ldr	r2, [sp, #16]
 8002de6:	60da      	str	r2, [r3, #12]
    state[2] = Abi;
 8002de8:	9a05      	ldr	r2, [sp, #20]
 8002dea:	611a      	str	r2, [r3, #16]
 8002dec:	9a06      	ldr	r2, [sp, #24]
 8002dee:	615a      	str	r2, [r3, #20]
    state[3] = Abo;
 8002df0:	9a07      	ldr	r2, [sp, #28]
 8002df2:	619a      	str	r2, [r3, #24]
 8002df4:	9a08      	ldr	r2, [sp, #32]
 8002df6:	61da      	str	r2, [r3, #28]
    state[4] = Abu;
 8002df8:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8002dfa:	621a      	str	r2, [r3, #32]
 8002dfc:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8002dfe:	625a      	str	r2, [r3, #36]	; 0x24
    state[5] = Aga;
 8002e00:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8002e02:	629a      	str	r2, [r3, #40]	; 0x28
 8002e04:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8002e06:	62da      	str	r2, [r3, #44]	; 0x2c
    state[6] = Age;
 8002e08:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8002e0a:	631a      	str	r2, [r3, #48]	; 0x30
 8002e0c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8002e0e:	635a      	str	r2, [r3, #52]	; 0x34
    state[7] = Agi;
 8002e10:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8002e12:	639a      	str	r2, [r3, #56]	; 0x38
 8002e14:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8002e16:	63da      	str	r2, [r3, #60]	; 0x3c
    state[8] = Ago;
 8002e18:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8002e1a:	641a      	str	r2, [r3, #64]	; 0x40
 8002e1c:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8002e1e:	645a      	str	r2, [r3, #68]	; 0x44
    state[9] = Agu;
 8002e20:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8002e22:	649a      	str	r2, [r3, #72]	; 0x48
 8002e24:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8002e26:	64da      	str	r2, [r3, #76]	; 0x4c
    state[10] = Aka;
 8002e28:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8002e2a:	651a      	str	r2, [r3, #80]	; 0x50
 8002e2c:	9a2f      	ldr	r2, [sp, #188]	; 0xbc
 8002e2e:	655a      	str	r2, [r3, #84]	; 0x54
    state[11] = Ake;
 8002e30:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8002e32:	659a      	str	r2, [r3, #88]	; 0x58
 8002e34:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8002e36:	65da      	str	r2, [r3, #92]	; 0x5c
    state[12] = Aki;
 8002e38:	9a18      	ldr	r2, [sp, #96]	; 0x60
 8002e3a:	661a      	str	r2, [r3, #96]	; 0x60
 8002e3c:	9a19      	ldr	r2, [sp, #100]	; 0x64
 8002e3e:	665a      	str	r2, [r3, #100]	; 0x64
    state[13] = Ako;
 8002e40:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 8002e42:	669a      	str	r2, [r3, #104]	; 0x68
 8002e44:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 8002e46:	66da      	str	r2, [r3, #108]	; 0x6c
    state[14] = Aku;
 8002e48:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 8002e4a:	671a      	str	r2, [r3, #112]	; 0x70
 8002e4c:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 8002e4e:	675a      	str	r2, [r3, #116]	; 0x74
    state[15] = Ama;
 8002e50:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 8002e52:	e9c3 291e 	strd	r2, r9, [r3, #120]	; 0x78
    state[16] = Ame;
 8002e56:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
 8002e58:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
 8002e5c:	9a20      	ldr	r2, [sp, #128]	; 0x80
 8002e5e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    state[17] = Ami;
 8002e62:	9a21      	ldr	r2, [sp, #132]	; 0x84
 8002e64:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
 8002e68:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8002e6a:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    state[18] = Amo;
 8002e6e:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 8002e70:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 8002e74:	9a24      	ldr	r2, [sp, #144]	; 0x90
 8002e76:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    state[19] = Amu;
 8002e7a:	9a25      	ldr	r2, [sp, #148]	; 0x94
 8002e7c:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
 8002e80:	9a26      	ldr	r2, [sp, #152]	; 0x98
    state[20] = Asa;
 8002e82:	f8c3 b0a4 	str.w	fp, [r3, #164]	; 0xa4
 8002e86:	e9c3 2c27 	strd	r2, ip, [r3, #156]	; 0x9c
    state[21] = Ase;
 8002e8a:	9a27      	ldr	r2, [sp, #156]	; 0x9c
    state[22] = Asi;
    state[23] = Aso;
 8002e8c:	f8c3 00bc 	str.w	r0, [r3, #188]	; 0xbc
    state[21] = Ase;
 8002e90:	e9c3 2a2a 	strd	r2, sl, [r3, #168]	; 0xa8
    state[22] = Asi;
 8002e94:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 8002e96:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
 8002e9a:	9a29      	ldr	r2, [sp, #164]	; 0xa4
 8002e9c:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
    state[23] = Aso;
 8002ea0:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
 8002ea2:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
    state[24] = Asu;
 8002ea6:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
 8002ea8:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
 8002eac:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
 8002eae:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
}
 8002eb2:	b041      	add	sp, #260	; 0x104
 8002eb4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002eb8:	08004f08 	.word	0x08004f08

08002ebc <keccak_inc_absorb>:
 *              - uint32_t r: rate in bytes (e.g., 168 for SHAKE128)
 *              - const uint8_t *m: pointer to input to be absorbed into s
 *              - size_t mlen: length of input in bytes
 **************************************************/
static void keccak_inc_absorb(uint64_t *s_inc, uint32_t r, const uint8_t *m,
                              size_t mlen) {
 8002ebc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002ec0:	4604      	mov	r4, r0
    size_t i;

    /* Recall that s_inc[25] is the non-absorbed bytes xored into the state */
    while (mlen + s_inc[25] >= r) {
 8002ec2:	f8d0 00c8 	ldr.w	r0, [r0, #200]	; 0xc8
                              size_t mlen) {
 8002ec6:	461e      	mov	r6, r3
    while (mlen + s_inc[25] >= r) {
 8002ec8:	f8d4 30cc 	ldr.w	r3, [r4, #204]	; 0xcc
                              size_t mlen) {
 8002ecc:	468c      	mov	ip, r1
 8002ece:	4617      	mov	r7, r2
    while (mlen + s_inc[25] >= r) {
 8002ed0:	1982      	adds	r2, r0, r6
 8002ed2:	f143 0100 	adc.w	r1, r3, #0
 8002ed6:	4562      	cmp	r2, ip
 8002ed8:	f171 0500 	sbcs.w	r5, r1, #0
 8002edc:	d34a      	bcc.n	8002f74 <keccak_inc_absorb+0xb8>
 8002ede:	4665      	mov	r5, ip
 8002ee0:	4602      	mov	r2, r0
        for (i = 0; i < r - (uint32_t)s_inc[25]; i++) {
 8002ee2:	4295      	cmp	r5, r2
 8002ee4:	d031      	beq.n	8002f4a <keccak_inc_absorb+0x8e>
 8002ee6:	2100      	movs	r1, #0
 8002ee8:	f107 3eff 	add.w	lr, r7, #4294967295	; 0xffffffff
 8002eec:	468c      	mov	ip, r1
            /* Take the i'th byte from message
               xor with the s_inc[25] + i'th byte of the state; little-endian */
            s_inc[(s_inc[25] + i) >> 3] ^= (uint64_t)m[i] << (8 * ((s_inc[25] + i) & 0x07));
 8002eee:	1852      	adds	r2, r2, r1
 8002ef0:	eb43 030c 	adc.w	r3, r3, ip
 8002ef4:	ea4f 08d2 	mov.w	r8, r2, lsr #3
 8002ef8:	ea48 7843 	orr.w	r8, r8, r3, lsl #29
 8002efc:	f81e 9f01 	ldrb.w	r9, [lr, #1]!
 8002f00:	f854 0038 	ldr.w	r0, [r4, r8, lsl #3]
 8002f04:	f002 0207 	and.w	r2, r2, #7
 8002f08:	00d2      	lsls	r2, r2, #3
 8002f0a:	eb04 0ac8 	add.w	sl, r4, r8, lsl #3
 8002f0e:	f1a2 0320 	sub.w	r3, r2, #32
 8002f12:	f1c2 0b20 	rsb	fp, r2, #32
 8002f16:	fa09 f202 	lsl.w	r2, r9, r2
 8002f1a:	4050      	eors	r0, r2
 8002f1c:	fa09 f303 	lsl.w	r3, r9, r3
 8002f20:	f8da 2004 	ldr.w	r2, [sl, #4]
 8002f24:	f844 0038 	str.w	r0, [r4, r8, lsl #3]
 8002f28:	fa29 fb0b 	lsr.w	fp, r9, fp
 8002f2c:	ea43 030b 	orr.w	r3, r3, fp
 8002f30:	4053      	eors	r3, r2
 8002f32:	f8ca 3004 	str.w	r3, [sl, #4]
        for (i = 0; i < r - (uint32_t)s_inc[25]; i++) {
 8002f36:	e9d4 2332 	ldrd	r2, r3, [r4, #200]	; 0xc8
 8002f3a:	3101      	adds	r1, #1
 8002f3c:	eba5 0002 	sub.w	r0, r5, r2
 8002f40:	f14c 0c00 	adc.w	ip, ip, #0
 8002f44:	4288      	cmp	r0, r1
 8002f46:	d8d2      	bhi.n	8002eee <keccak_inc_absorb+0x32>
        }
        mlen -= (size_t)(r - s_inc[25]);
        m += r - s_inc[25];
 8002f48:	4407      	add	r7, r0
        s_inc[25] = 0;
 8002f4a:	2100      	movs	r1, #0
 8002f4c:	2000      	movs	r0, #0
 8002f4e:	e9c4 0132 	strd	r0, r1, [r4, #200]	; 0xc8
        mlen -= (size_t)(r - s_inc[25]);
 8002f52:	1b52      	subs	r2, r2, r5

        KeccakF1600_StatePermute(s_inc);
 8002f54:	4620      	mov	r0, r4
        mlen -= (size_t)(r - s_inc[25]);
 8002f56:	4416      	add	r6, r2
        KeccakF1600_StatePermute(s_inc);
 8002f58:	f7fe ff1c 	bl	8001d94 <KeccakF1600_StatePermute>
    while (mlen + s_inc[25] >= r) {
 8002f5c:	e9d4 2332 	ldrd	r2, r3, [r4, #200]	; 0xc8
 8002f60:	eb16 0c02 	adds.w	ip, r6, r2
 8002f64:	f143 0100 	adc.w	r1, r3, #0
 8002f68:	45ac      	cmp	ip, r5
 8002f6a:	f171 0000 	sbcs.w	r0, r1, #0
 8002f6e:	d2b8      	bcs.n	8002ee2 <keccak_inc_absorb+0x26>
 8002f70:	4610      	mov	r0, r2
 8002f72:	4662      	mov	r2, ip
    }

    for (i = 0; i < mlen; i++) {
 8002f74:	2e00      	cmp	r6, #0
 8002f76:	d053      	beq.n	8003020 <keccak_inc_absorb+0x164>
        s_inc[(s_inc[25] + i) >> 3] ^= (uint64_t)m[i] << (8 * ((s_inc[25] + i) & 0x07));
 8002f78:	08c1      	lsrs	r1, r0, #3
 8002f7a:	ea41 7143 	orr.w	r1, r1, r3, lsl #29
 8002f7e:	f000 0307 	and.w	r3, r0, #7
 8002f82:	00db      	lsls	r3, r3, #3
 8002f84:	7838      	ldrb	r0, [r7, #0]
 8002f86:	f1a3 0220 	sub.w	r2, r3, #32
 8002f8a:	f1c3 0c20 	rsb	ip, r3, #32
 8002f8e:	eb04 05c1 	add.w	r5, r4, r1, lsl #3
 8002f92:	fa00 f303 	lsl.w	r3, r0, r3
 8002f96:	fa00 f202 	lsl.w	r2, r0, r2
 8002f9a:	fa20 fc0c 	lsr.w	ip, r0, ip
 8002f9e:	f854 0031 	ldr.w	r0, [r4, r1, lsl #3]
 8002fa2:	4058      	eors	r0, r3
 8002fa4:	686b      	ldr	r3, [r5, #4]
 8002fa6:	f844 0031 	str.w	r0, [r4, r1, lsl #3]
 8002faa:	ea42 020c 	orr.w	r2, r2, ip
 8002fae:	405a      	eors	r2, r3
    for (i = 0; i < mlen; i++) {
 8002fb0:	2e01      	cmp	r6, #1
        s_inc[(s_inc[25] + i) >> 3] ^= (uint64_t)m[i] << (8 * ((s_inc[25] + i) & 0x07));
 8002fb2:	606a      	str	r2, [r5, #4]
    for (i = 0; i < mlen; i++) {
 8002fb4:	d02f      	beq.n	8003016 <keccak_inc_absorb+0x15a>
 8002fb6:	f106 3cff 	add.w	ip, r6, #4294967295	; 0xffffffff
 8002fba:	44bc      	add	ip, r7
 8002fbc:	2101      	movs	r1, #1
 8002fbe:	2200      	movs	r2, #0
        s_inc[(s_inc[25] + i) >> 3] ^= (uint64_t)m[i] << (8 * ((s_inc[25] + i) & 0x07));
 8002fc0:	e9d4 3032 	ldrd	r3, r0, [r4, #200]	; 0xc8
 8002fc4:	18cb      	adds	r3, r1, r3
 8002fc6:	eb42 0000 	adc.w	r0, r2, r0
 8002fca:	08dd      	lsrs	r5, r3, #3
 8002fcc:	f003 0307 	and.w	r3, r3, #7
 8002fd0:	f817 ef01 	ldrb.w	lr, [r7, #1]!
 8002fd4:	ea45 7540 	orr.w	r5, r5, r0, lsl #29
 8002fd8:	00db      	lsls	r3, r3, #3
 8002fda:	f1a3 0920 	sub.w	r9, r3, #32
 8002fde:	f1c3 0020 	rsb	r0, r3, #32
 8002fe2:	eb04 08c5 	add.w	r8, r4, r5, lsl #3
 8002fe6:	fa0e f303 	lsl.w	r3, lr, r3
 8002fea:	fa0e f909 	lsl.w	r9, lr, r9
 8002fee:	fa2e f000 	lsr.w	r0, lr, r0
 8002ff2:	f854 e035 	ldr.w	lr, [r4, r5, lsl #3]
 8002ff6:	ea8e 0e03 	eor.w	lr, lr, r3
 8002ffa:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8002ffe:	f844 e035 	str.w	lr, [r4, r5, lsl #3]
    for (i = 0; i < mlen; i++) {
 8003002:	3101      	adds	r1, #1
        s_inc[(s_inc[25] + i) >> 3] ^= (uint64_t)m[i] << (8 * ((s_inc[25] + i) & 0x07));
 8003004:	ea49 0000 	orr.w	r0, r9, r0
    for (i = 0; i < mlen; i++) {
 8003008:	f142 0200 	adc.w	r2, r2, #0
        s_inc[(s_inc[25] + i) >> 3] ^= (uint64_t)m[i] << (8 * ((s_inc[25] + i) & 0x07));
 800300c:	4058      	eors	r0, r3
    for (i = 0; i < mlen; i++) {
 800300e:	4567      	cmp	r7, ip
        s_inc[(s_inc[25] + i) >> 3] ^= (uint64_t)m[i] << (8 * ((s_inc[25] + i) & 0x07));
 8003010:	f8c8 0004 	str.w	r0, [r8, #4]
    for (i = 0; i < mlen; i++) {
 8003014:	d1d4      	bne.n	8002fc0 <keccak_inc_absorb+0x104>
    }
    s_inc[25] += mlen;
 8003016:	e9d4 2132 	ldrd	r2, r1, [r4, #200]	; 0xc8
 800301a:	18b2      	adds	r2, r6, r2
 800301c:	f141 0100 	adc.w	r1, r1, #0
 8003020:	e9c4 2132 	strd	r2, r1, [r4, #200]	; 0xc8
}
 8003024:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

08003028 <keccak_absorb.constprop.2>:
static void keccak_absorb(uint64_t *s, uint32_t r, const uint8_t *m,
 8003028:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800302c:	4615      	mov	r5, r2
 800302e:	b0b3      	sub	sp, #204	; 0xcc
 8003030:	4688      	mov	r8, r1
        s[i] = 0;
 8003032:	22c8      	movs	r2, #200	; 0xc8
 8003034:	2100      	movs	r1, #0
static void keccak_absorb(uint64_t *s, uint32_t r, const uint8_t *m,
 8003036:	4606      	mov	r6, r0
 8003038:	469b      	mov	fp, r3
        s[i] = 0;
 800303a:	f7fd fc93 	bl	8000964 <memset>
    while (mlen >= r) {
 800303e:	2d87      	cmp	r5, #135	; 0x87
 8003040:	f1a6 0408 	sub.w	r4, r6, #8
 8003044:	bf88      	it	hi
 8003046:	f106 0980 	addhi.w	r9, r6, #128	; 0x80
 800304a:	d930      	bls.n	80030ae <keccak_absorb.constprop.2+0x86>
 800304c:	4643      	mov	r3, r8
 800304e:	4620      	mov	r0, r4
        r |= (uint64_t)x[i] << 8 * i;
 8003050:	f893 e005 	ldrb.w	lr, [r3, #5]
 8003054:	7919      	ldrb	r1, [r3, #4]
 8003056:	789a      	ldrb	r2, [r3, #2]
 8003058:	f893 c001 	ldrb.w	ip, [r3, #1]
            s[i] ^= load64(m + 8 * i);
 800305c:	f850 7f08 	ldr.w	r7, [r0, #8]!
        r |= (uint64_t)x[i] << 8 * i;
 8003060:	f893 a000 	ldrb.w	sl, [r3]
 8003064:	ea41 210e 	orr.w	r1, r1, lr, lsl #8
 8003068:	f893 e006 	ldrb.w	lr, [r3, #6]
 800306c:	0412      	lsls	r2, r2, #16
 800306e:	ea41 410e 	orr.w	r1, r1, lr, lsl #16
 8003072:	f893 e007 	ldrb.w	lr, [r3, #7]
 8003076:	ea42 220c 	orr.w	r2, r2, ip, lsl #8
 800307a:	f893 c003 	ldrb.w	ip, [r3, #3]
 800307e:	ea41 6e0e 	orr.w	lr, r1, lr, lsl #24
 8003082:	ea42 020a 	orr.w	r2, r2, sl
            s[i] ^= load64(m + 8 * i);
 8003086:	6841      	ldr	r1, [r0, #4]
        r |= (uint64_t)x[i] << 8 * i;
 8003088:	ea42 620c 	orr.w	r2, r2, ip, lsl #24
            s[i] ^= load64(m + 8 * i);
 800308c:	407a      	eors	r2, r7
 800308e:	ea81 010e 	eor.w	r1, r1, lr
        for (i = 0; i < r / 8; ++i) {
 8003092:	4548      	cmp	r0, r9
            s[i] ^= load64(m + 8 * i);
 8003094:	e9c0 2100 	strd	r2, r1, [r0]
        for (i = 0; i < r / 8; ++i) {
 8003098:	f103 0308 	add.w	r3, r3, #8
 800309c:	d1d8      	bne.n	8003050 <keccak_absorb.constprop.2+0x28>
        KeccakF1600_StatePermute(s);
 800309e:	4630      	mov	r0, r6
        mlen -= r;
 80030a0:	3d88      	subs	r5, #136	; 0x88
        KeccakF1600_StatePermute(s);
 80030a2:	f7fe fe77 	bl	8001d94 <KeccakF1600_StatePermute>
    while (mlen >= r) {
 80030a6:	2d87      	cmp	r5, #135	; 0x87
        m += r;
 80030a8:	f108 0888 	add.w	r8, r8, #136	; 0x88
    while (mlen >= r) {
 80030ac:	d8ce      	bhi.n	800304c <keccak_absorb.constprop.2+0x24>
        t[i] = 0;
 80030ae:	2288      	movs	r2, #136	; 0x88
 80030b0:	2100      	movs	r1, #0
 80030b2:	4668      	mov	r0, sp
 80030b4:	f7fd fc56 	bl	8000964 <memset>
    for (i = 0; i < mlen; ++i) {
 80030b8:	b125      	cbz	r5, 80030c4 <keccak_absorb.constprop.2+0x9c>
        t[i] = m[i];
 80030ba:	4641      	mov	r1, r8
 80030bc:	462a      	mov	r2, r5
 80030be:	4668      	mov	r0, sp
 80030c0:	f7fd fbb6 	bl	8000830 <memcpy>
    t[i] = p;
 80030c4:	f105 03c8 	add.w	r3, r5, #200	; 0xc8
 80030c8:	eb0d 0503 	add.w	r5, sp, r3
 80030cc:	466b      	mov	r3, sp
 80030ce:	f805 bcc8 	strb.w	fp, [r5, #-200]
    t[r - 1] |= 128;
 80030d2:	f89d 2087 	ldrb.w	r2, [sp, #135]	; 0x87
 80030d6:	f062 027f 	orn	r2, r2, #127	; 0x7f
 80030da:	f88d 2087 	strb.w	r2, [sp, #135]	; 0x87
    for (i = 0; i < r / 8; ++i) {
 80030de:	ad22      	add	r5, sp, #136	; 0x88
        r |= (uint64_t)x[i] << 8 * i;
 80030e0:	789a      	ldrb	r2, [r3, #2]
 80030e2:	7958      	ldrb	r0, [r3, #5]
 80030e4:	f893 9001 	ldrb.w	r9, [r3, #1]
 80030e8:	7919      	ldrb	r1, [r3, #4]
        s[i] ^= load64(t + 8 * i);
 80030ea:	f854 6f08 	ldr.w	r6, [r4, #8]!
        r |= (uint64_t)x[i] << 8 * i;
 80030ee:	f893 8000 	ldrb.w	r8, [r3]
 80030f2:	f893 e006 	ldrb.w	lr, [r3, #6]
 80030f6:	f893 c003 	ldrb.w	ip, [r3, #3]
 80030fa:	79df      	ldrb	r7, [r3, #7]
 80030fc:	0412      	lsls	r2, r2, #16
 80030fe:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
 8003102:	ea42 2209 	orr.w	r2, r2, r9, lsl #8
        s[i] ^= load64(t + 8 * i);
 8003106:	6860      	ldr	r0, [r4, #4]
        r |= (uint64_t)x[i] << 8 * i;
 8003108:	ea42 0208 	orr.w	r2, r2, r8
 800310c:	ea41 410e 	orr.w	r1, r1, lr, lsl #16
 8003110:	ea42 620c 	orr.w	r2, r2, ip, lsl #24
 8003114:	ea41 6107 	orr.w	r1, r1, r7, lsl #24
    for (i = 0; i < r / 8; ++i) {
 8003118:	3308      	adds	r3, #8
        s[i] ^= load64(t + 8 * i);
 800311a:	4072      	eors	r2, r6
 800311c:	4041      	eors	r1, r0
    for (i = 0; i < r / 8; ++i) {
 800311e:	42ab      	cmp	r3, r5
        s[i] ^= load64(t + 8 * i);
 8003120:	e9c4 2100 	strd	r2, r1, [r4]
    for (i = 0; i < r / 8; ++i) {
 8003124:	d1dc      	bne.n	80030e0 <keccak_absorb.constprop.2+0xb8>
}
 8003126:	b033      	add	sp, #204	; 0xcc
 8003128:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800312c <shake128_inc_init>:
        outlen -= i;
        s_inc[25] = r - i;
    }
}

void shake128_inc_init(shake128incctx *state) {
 800312c:	b538      	push	{r3, r4, r5, lr}
 800312e:	4605      	mov	r5, r0
    state->ctx = malloc(PQC_SHAKEINCCTX_BYTES);
 8003130:	20d0      	movs	r0, #208	; 0xd0
 8003132:	f7fd f8c3 	bl	80002bc <malloc>
 8003136:	6028      	str	r0, [r5, #0]
    if (state->ctx == NULL) {
 8003138:	b148      	cbz	r0, 800314e <shake128_inc_init+0x22>
        s_inc[i] = 0;
 800313a:	22c8      	movs	r2, #200	; 0xc8
 800313c:	2100      	movs	r1, #0
 800313e:	4604      	mov	r4, r0
 8003140:	f7fd fc10 	bl	8000964 <memset>
    s_inc[25] = 0;
 8003144:	2200      	movs	r2, #0
 8003146:	2300      	movs	r3, #0
 8003148:	e9c4 2332 	strd	r2, r3, [r4, #200]	; 0xc8
        exit(111);
    }
    keccak_inc_init(state->ctx);
}
 800314c:	bd38      	pop	{r3, r4, r5, pc}
        exit(111);
 800314e:	206f      	movs	r0, #111	; 0x6f
 8003150:	f7fd f86a 	bl	8000228 <exit>

08003154 <shake128_inc_absorb>:

void shake128_inc_absorb(shake128incctx *state, const uint8_t *input, size_t inlen) {
 8003154:	4613      	mov	r3, r2
    keccak_inc_absorb(state->ctx, SHAKE128_RATE, input, inlen);
 8003156:	6800      	ldr	r0, [r0, #0]
 8003158:	460a      	mov	r2, r1
 800315a:	21a8      	movs	r1, #168	; 0xa8
 800315c:	f7ff beae 	b.w	8002ebc <keccak_inc_absorb>

08003160 <shake128_inc_finalize>:
}

void shake128_inc_finalize(shake128incctx *state) {
    keccak_inc_finalize(state->ctx, SHAKE128_RATE, 0x1F);
 8003160:	6803      	ldr	r3, [r0, #0]
    s_inc[s_inc[25] >> 3] ^= (uint64_t)p << (8 * (s_inc[25] & 0x07));
 8003162:	e9d3 2132 	ldrd	r2, r1, [r3, #200]	; 0xc8
 8003166:	08d0      	lsrs	r0, r2, #3
 8003168:	ea40 7041 	orr.w	r0, r0, r1, lsl #29
 800316c:	f002 0207 	and.w	r2, r2, #7
void shake128_inc_finalize(shake128incctx *state) {
 8003170:	b530      	push	{r4, r5, lr}
    s_inc[s_inc[25] >> 3] ^= (uint64_t)p << (8 * (s_inc[25] & 0x07));
 8003172:	00d2      	lsls	r2, r2, #3
 8003174:	f853 4030 	ldr.w	r4, [r3, r0, lsl #3]
 8003178:	eb03 05c0 	add.w	r5, r3, r0, lsl #3
 800317c:	f04f 0c1f 	mov.w	ip, #31
 8003180:	f1a2 0120 	sub.w	r1, r2, #32
 8003184:	f1c2 0e20 	rsb	lr, r2, #32
 8003188:	fa0c f202 	lsl.w	r2, ip, r2
 800318c:	4062      	eors	r2, r4
 800318e:	fa0c f101 	lsl.w	r1, ip, r1
 8003192:	686c      	ldr	r4, [r5, #4]
 8003194:	f843 2030 	str.w	r2, [r3, r0, lsl #3]
 8003198:	fa2c fe0e 	lsr.w	lr, ip, lr
 800319c:	ea41 010e 	orr.w	r1, r1, lr
 80031a0:	4061      	eors	r1, r4
 80031a2:	6069      	str	r1, [r5, #4]
    s_inc[(r - 1) >> 3] ^= (uint64_t)128 << (8 * ((r - 1) & 0x07));
 80031a4:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
    s_inc[25] = 0;
 80031a8:	2000      	movs	r0, #0
 80031aa:	2100      	movs	r1, #0
    s_inc[(r - 1) >> 3] ^= (uint64_t)128 << (8 * ((r - 1) & 0x07));
 80031ac:	f102 4200 	add.w	r2, r2, #2147483648	; 0x80000000
    s_inc[25] = 0;
 80031b0:	e9c3 0132 	strd	r0, r1, [r3, #200]	; 0xc8
    s_inc[(r - 1) >> 3] ^= (uint64_t)128 << (8 * ((r - 1) & 0x07));
 80031b4:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
}
 80031b8:	bd30      	pop	{r4, r5, pc}
 80031ba:	bf00      	nop

080031bc <shake128_inc_squeeze>:

void shake128_inc_squeeze(uint8_t *output, size_t outlen, shake128incctx *state) {
 80031bc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    keccak_inc_squeeze(output, outlen, state->ctx, SHAKE128_RATE);
 80031c0:	6816      	ldr	r6, [r2, #0]
    for (i = 0; i < outlen && i < s_inc[25]; i++) {
 80031c2:	2900      	cmp	r1, #0
 80031c4:	d06c      	beq.n	80032a0 <shake128_inc_squeeze+0xe4>
 80031c6:	1e4d      	subs	r5, r1, #1
 80031c8:	2200      	movs	r2, #0
 80031ca:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
 80031ce:	4405      	add	r5, r0
 80031d0:	4617      	mov	r7, r2
 80031d2:	e029      	b.n	8003228 <shake128_inc_squeeze+0x6c>
        h[i] = (uint8_t)(s_inc[(r - s_inc[25] + i) >> 3] >> (8 * ((r - s_inc[25] + i) & 0x07)));
 80031d4:	f1d3 03a8 	rsbs	r3, r3, #168	; 0xa8
 80031d8:	eb6e 0e4e 	sbc.w	lr, lr, lr, lsl #1
 80031dc:	189b      	adds	r3, r3, r2
 80031de:	eb47 0e0e 	adc.w	lr, r7, lr
 80031e2:	08dc      	lsrs	r4, r3, #3
 80031e4:	ea44 744e 	orr.w	r4, r4, lr, lsl #29
 80031e8:	eb06 0ec4 	add.w	lr, r6, r4, lsl #3
 80031ec:	f003 0307 	and.w	r3, r3, #7
 80031f0:	f8de 8004 	ldr.w	r8, [lr, #4]
 80031f4:	f856 4034 	ldr.w	r4, [r6, r4, lsl #3]
 80031f8:	00db      	lsls	r3, r3, #3
 80031fa:	f1c3 0920 	rsb	r9, r3, #32
 80031fe:	f1a3 0e20 	sub.w	lr, r3, #32
 8003202:	fa08 f909 	lsl.w	r9, r8, r9
 8003206:	fa24 f303 	lsr.w	r3, r4, r3
 800320a:	ea43 0309 	orr.w	r3, r3, r9
 800320e:	fa28 fe0e 	lsr.w	lr, r8, lr
 8003212:	ea43 030e 	orr.w	r3, r3, lr
 8003216:	f80c 3f01 	strb.w	r3, [ip, #1]!
    for (i = 0; i < outlen && i < s_inc[25]; i++) {
 800321a:	1c53      	adds	r3, r2, #1
 800321c:	f147 0700 	adc.w	r7, r7, #0
 8003220:	4565      	cmp	r5, ip
 8003222:	461c      	mov	r4, r3
 8003224:	461a      	mov	r2, r3
 8003226:	d040      	beq.n	80032aa <shake128_inc_squeeze+0xee>
 8003228:	e9d6 3e32 	ldrd	r3, lr, [r6, #200]	; 0xc8
 800322c:	429a      	cmp	r2, r3
 800322e:	eb77 080e 	sbcs.w	r8, r7, lr
 8003232:	4614      	mov	r4, r2
 8003234:	d3ce      	bcc.n	80031d4 <shake128_inc_squeeze+0x18>
    s_inc[25] -= i;
 8003236:	1a9b      	subs	r3, r3, r2
 8003238:	eb6e 0707 	sbc.w	r7, lr, r7
    h += i;
 800323c:	1905      	adds	r5, r0, r4
    while (outlen > 0) {
 800323e:	1b0c      	subs	r4, r1, r4
    s_inc[25] -= i;
 8003240:	e9c6 3732 	strd	r3, r7, [r6, #200]	; 0xc8
    while (outlen > 0) {
 8003244:	d02c      	beq.n	80032a0 <shake128_inc_squeeze+0xe4>
        KeccakF1600_StatePermute(s_inc);
 8003246:	4630      	mov	r0, r6
 8003248:	f7fe fda4 	bl	8001d94 <KeccakF1600_StatePermute>
        for (i = 0; i < outlen && i < r; i++) {
 800324c:	1e6f      	subs	r7, r5, #1
 800324e:	2200      	movs	r2, #0
 8003250:	e001      	b.n	8003256 <shake128_inc_squeeze+0x9a>
 8003252:	2aa8      	cmp	r2, #168	; 0xa8
 8003254:	d026      	beq.n	80032a4 <shake128_inc_squeeze+0xe8>
            h[i] = (uint8_t)(s_inc[i >> 3] >> (8 * (i & 0x07)));
 8003256:	f022 0107 	bic.w	r1, r2, #7
 800325a:	ea4f 0cd2 	mov.w	ip, r2, lsr #3
 800325e:	4431      	add	r1, r6
 8003260:	f002 0307 	and.w	r3, r2, #7
 8003264:	6848      	ldr	r0, [r1, #4]
 8003266:	00d9      	lsls	r1, r3, #3
 8003268:	f856 303c 	ldr.w	r3, [r6, ip, lsl #3]
 800326c:	f1c1 0e20 	rsb	lr, r1, #32
 8003270:	f1a1 0c20 	sub.w	ip, r1, #32
 8003274:	40cb      	lsrs	r3, r1
 8003276:	fa00 fe0e 	lsl.w	lr, r0, lr
 800327a:	ea43 030e 	orr.w	r3, r3, lr
 800327e:	fa20 fc0c 	lsr.w	ip, r0, ip
        for (i = 0; i < outlen && i < r; i++) {
 8003282:	3201      	adds	r2, #1
            h[i] = (uint8_t)(s_inc[i >> 3] >> (8 * (i & 0x07)));
 8003284:	ea43 030c 	orr.w	r3, r3, ip
        for (i = 0; i < outlen && i < r; i++) {
 8003288:	42a2      	cmp	r2, r4
            h[i] = (uint8_t)(s_inc[i >> 3] >> (8 * (i & 0x07)));
 800328a:	f807 3f01 	strb.w	r3, [r7, #1]!
        for (i = 0; i < outlen && i < r; i++) {
 800328e:	d3e0      	bcc.n	8003252 <shake128_inc_squeeze+0x96>
        s_inc[25] = r - i;
 8003290:	f1c2 03a8 	rsb	r3, r2, #168	; 0xa8
 8003294:	2100      	movs	r1, #0
    while (outlen > 0) {
 8003296:	1aa4      	subs	r4, r4, r2
        s_inc[25] = r - i;
 8003298:	e9c6 3132 	strd	r3, r1, [r6, #200]	; 0xc8
        h += i;
 800329c:	4415      	add	r5, r2
    while (outlen > 0) {
 800329e:	d1d2      	bne.n	8003246 <shake128_inc_squeeze+0x8a>
}
 80032a0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80032a4:	2300      	movs	r3, #0
 80032a6:	4619      	mov	r1, r3
 80032a8:	e7f5      	b.n	8003296 <shake128_inc_squeeze+0xda>
    s_inc[25] -= i;
 80032aa:	e9d6 3e32 	ldrd	r3, lr, [r6, #200]	; 0xc8
 80032ae:	2700      	movs	r7, #0
 80032b0:	e7c1      	b.n	8003236 <shake128_inc_squeeze+0x7a>
 80032b2:	bf00      	nop

080032b4 <shake128_inc_ctx_release>:
    }
    memcpy(dest->ctx, src->ctx, PQC_SHAKEINCCTX_BYTES);
}

void shake128_inc_ctx_release(shake128incctx *state) {
    free(state->ctx);
 80032b4:	6800      	ldr	r0, [r0, #0]
 80032b6:	f7fd b809 	b.w	80002cc <free>
 80032ba:	bf00      	nop

080032bc <shake256_inc_init>:
}

void shake256_inc_init(shake256incctx *state) {
 80032bc:	b538      	push	{r3, r4, r5, lr}
 80032be:	4605      	mov	r5, r0
    state->ctx = malloc(PQC_SHAKEINCCTX_BYTES);
 80032c0:	20d0      	movs	r0, #208	; 0xd0
 80032c2:	f7fc fffb 	bl	80002bc <malloc>
 80032c6:	6028      	str	r0, [r5, #0]
    if (state->ctx == NULL) {
 80032c8:	b148      	cbz	r0, 80032de <shake256_inc_init+0x22>
        s_inc[i] = 0;
 80032ca:	22c8      	movs	r2, #200	; 0xc8
 80032cc:	2100      	movs	r1, #0
 80032ce:	4604      	mov	r4, r0
 80032d0:	f7fd fb48 	bl	8000964 <memset>
    s_inc[25] = 0;
 80032d4:	2200      	movs	r2, #0
 80032d6:	2300      	movs	r3, #0
 80032d8:	e9c4 2332 	strd	r2, r3, [r4, #200]	; 0xc8
        exit(111);
    }
    keccak_inc_init(state->ctx);
}
 80032dc:	bd38      	pop	{r3, r4, r5, pc}
        exit(111);
 80032de:	206f      	movs	r0, #111	; 0x6f
 80032e0:	f7fc ffa2 	bl	8000228 <exit>

080032e4 <shake256_inc_absorb>:

void shake256_inc_absorb(shake256incctx *state, const uint8_t *input, size_t inlen) {
 80032e4:	4613      	mov	r3, r2
    keccak_inc_absorb(state->ctx, SHAKE256_RATE, input, inlen);
 80032e6:	6800      	ldr	r0, [r0, #0]
 80032e8:	460a      	mov	r2, r1
 80032ea:	2188      	movs	r1, #136	; 0x88
 80032ec:	f7ff bde6 	b.w	8002ebc <keccak_inc_absorb>

080032f0 <shake256_inc_finalize>:
}

void shake256_inc_finalize(shake256incctx *state) {
    keccak_inc_finalize(state->ctx, SHAKE256_RATE, 0x1F);
 80032f0:	6803      	ldr	r3, [r0, #0]
    s_inc[s_inc[25] >> 3] ^= (uint64_t)p << (8 * (s_inc[25] & 0x07));
 80032f2:	e9d3 2132 	ldrd	r2, r1, [r3, #200]	; 0xc8
 80032f6:	08d0      	lsrs	r0, r2, #3
 80032f8:	ea40 7041 	orr.w	r0, r0, r1, lsl #29
 80032fc:	f002 0207 	and.w	r2, r2, #7
void shake256_inc_finalize(shake256incctx *state) {
 8003300:	b530      	push	{r4, r5, lr}
    s_inc[s_inc[25] >> 3] ^= (uint64_t)p << (8 * (s_inc[25] & 0x07));
 8003302:	00d2      	lsls	r2, r2, #3
 8003304:	f853 4030 	ldr.w	r4, [r3, r0, lsl #3]
 8003308:	eb03 05c0 	add.w	r5, r3, r0, lsl #3
 800330c:	f04f 0c1f 	mov.w	ip, #31
 8003310:	f1a2 0120 	sub.w	r1, r2, #32
 8003314:	f1c2 0e20 	rsb	lr, r2, #32
 8003318:	fa0c f202 	lsl.w	r2, ip, r2
 800331c:	4062      	eors	r2, r4
 800331e:	fa0c f101 	lsl.w	r1, ip, r1
 8003322:	686c      	ldr	r4, [r5, #4]
 8003324:	f843 2030 	str.w	r2, [r3, r0, lsl #3]
 8003328:	fa2c fe0e 	lsr.w	lr, ip, lr
 800332c:	ea41 010e 	orr.w	r1, r1, lr
 8003330:	4061      	eors	r1, r4
 8003332:	6069      	str	r1, [r5, #4]
    s_inc[(r - 1) >> 3] ^= (uint64_t)128 << (8 * ((r - 1) & 0x07));
 8003334:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
    s_inc[25] = 0;
 8003338:	2000      	movs	r0, #0
 800333a:	2100      	movs	r1, #0
    s_inc[(r - 1) >> 3] ^= (uint64_t)128 << (8 * ((r - 1) & 0x07));
 800333c:	f102 4200 	add.w	r2, r2, #2147483648	; 0x80000000
    s_inc[25] = 0;
 8003340:	e9c3 0132 	strd	r0, r1, [r3, #200]	; 0xc8
    s_inc[(r - 1) >> 3] ^= (uint64_t)128 << (8 * ((r - 1) & 0x07));
 8003344:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
 8003348:	bd30      	pop	{r4, r5, pc}
 800334a:	bf00      	nop

0800334c <shake256_inc_squeeze>:

void shake256_inc_squeeze(uint8_t *output, size_t outlen, shake256incctx *state) {
 800334c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    keccak_inc_squeeze(output, outlen, state->ctx, SHAKE256_RATE);
 8003350:	6816      	ldr	r6, [r2, #0]
    for (i = 0; i < outlen && i < s_inc[25]; i++) {
 8003352:	2900      	cmp	r1, #0
 8003354:	d06c      	beq.n	8003430 <shake256_inc_squeeze+0xe4>
 8003356:	1e4d      	subs	r5, r1, #1
 8003358:	2200      	movs	r2, #0
 800335a:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
 800335e:	4405      	add	r5, r0
 8003360:	4617      	mov	r7, r2
 8003362:	e029      	b.n	80033b8 <shake256_inc_squeeze+0x6c>
        h[i] = (uint8_t)(s_inc[(r - s_inc[25] + i) >> 3] >> (8 * ((r - s_inc[25] + i) & 0x07)));
 8003364:	f1d3 0388 	rsbs	r3, r3, #136	; 0x88
 8003368:	eb6e 0e4e 	sbc.w	lr, lr, lr, lsl #1
 800336c:	189b      	adds	r3, r3, r2
 800336e:	eb47 0e0e 	adc.w	lr, r7, lr
 8003372:	08dc      	lsrs	r4, r3, #3
 8003374:	ea44 744e 	orr.w	r4, r4, lr, lsl #29
 8003378:	eb06 0ec4 	add.w	lr, r6, r4, lsl #3
 800337c:	f003 0307 	and.w	r3, r3, #7
 8003380:	f8de 8004 	ldr.w	r8, [lr, #4]
 8003384:	f856 4034 	ldr.w	r4, [r6, r4, lsl #3]
 8003388:	00db      	lsls	r3, r3, #3
 800338a:	f1c3 0920 	rsb	r9, r3, #32
 800338e:	f1a3 0e20 	sub.w	lr, r3, #32
 8003392:	fa08 f909 	lsl.w	r9, r8, r9
 8003396:	fa24 f303 	lsr.w	r3, r4, r3
 800339a:	ea43 0309 	orr.w	r3, r3, r9
 800339e:	fa28 fe0e 	lsr.w	lr, r8, lr
 80033a2:	ea43 030e 	orr.w	r3, r3, lr
 80033a6:	f80c 3f01 	strb.w	r3, [ip, #1]!
    for (i = 0; i < outlen && i < s_inc[25]; i++) {
 80033aa:	1c53      	adds	r3, r2, #1
 80033ac:	f147 0700 	adc.w	r7, r7, #0
 80033b0:	4565      	cmp	r5, ip
 80033b2:	461c      	mov	r4, r3
 80033b4:	461a      	mov	r2, r3
 80033b6:	d040      	beq.n	800343a <shake256_inc_squeeze+0xee>
 80033b8:	e9d6 3e32 	ldrd	r3, lr, [r6, #200]	; 0xc8
 80033bc:	429a      	cmp	r2, r3
 80033be:	eb77 080e 	sbcs.w	r8, r7, lr
 80033c2:	4614      	mov	r4, r2
 80033c4:	d3ce      	bcc.n	8003364 <shake256_inc_squeeze+0x18>
    s_inc[25] -= i;
 80033c6:	1a9b      	subs	r3, r3, r2
 80033c8:	eb6e 0707 	sbc.w	r7, lr, r7
    h += i;
 80033cc:	1905      	adds	r5, r0, r4
    while (outlen > 0) {
 80033ce:	1b0c      	subs	r4, r1, r4
    s_inc[25] -= i;
 80033d0:	e9c6 3732 	strd	r3, r7, [r6, #200]	; 0xc8
    while (outlen > 0) {
 80033d4:	d02c      	beq.n	8003430 <shake256_inc_squeeze+0xe4>
        KeccakF1600_StatePermute(s_inc);
 80033d6:	4630      	mov	r0, r6
 80033d8:	f7fe fcdc 	bl	8001d94 <KeccakF1600_StatePermute>
        for (i = 0; i < outlen && i < r; i++) {
 80033dc:	1e6f      	subs	r7, r5, #1
 80033de:	2200      	movs	r2, #0
 80033e0:	e001      	b.n	80033e6 <shake256_inc_squeeze+0x9a>
 80033e2:	2a88      	cmp	r2, #136	; 0x88
 80033e4:	d026      	beq.n	8003434 <shake256_inc_squeeze+0xe8>
            h[i] = (uint8_t)(s_inc[i >> 3] >> (8 * (i & 0x07)));
 80033e6:	f022 0107 	bic.w	r1, r2, #7
 80033ea:	ea4f 0cd2 	mov.w	ip, r2, lsr #3
 80033ee:	4431      	add	r1, r6
 80033f0:	f002 0307 	and.w	r3, r2, #7
 80033f4:	6848      	ldr	r0, [r1, #4]
 80033f6:	00d9      	lsls	r1, r3, #3
 80033f8:	f856 303c 	ldr.w	r3, [r6, ip, lsl #3]
 80033fc:	f1c1 0e20 	rsb	lr, r1, #32
 8003400:	f1a1 0c20 	sub.w	ip, r1, #32
 8003404:	40cb      	lsrs	r3, r1
 8003406:	fa00 fe0e 	lsl.w	lr, r0, lr
 800340a:	ea43 030e 	orr.w	r3, r3, lr
 800340e:	fa20 fc0c 	lsr.w	ip, r0, ip
        for (i = 0; i < outlen && i < r; i++) {
 8003412:	3201      	adds	r2, #1
            h[i] = (uint8_t)(s_inc[i >> 3] >> (8 * (i & 0x07)));
 8003414:	ea43 030c 	orr.w	r3, r3, ip
        for (i = 0; i < outlen && i < r; i++) {
 8003418:	42a2      	cmp	r2, r4
            h[i] = (uint8_t)(s_inc[i >> 3] >> (8 * (i & 0x07)));
 800341a:	f807 3f01 	strb.w	r3, [r7, #1]!
        for (i = 0; i < outlen && i < r; i++) {
 800341e:	d3e0      	bcc.n	80033e2 <shake256_inc_squeeze+0x96>
        s_inc[25] = r - i;
 8003420:	f1c2 0388 	rsb	r3, r2, #136	; 0x88
 8003424:	2100      	movs	r1, #0
    while (outlen > 0) {
 8003426:	1aa4      	subs	r4, r4, r2
        s_inc[25] = r - i;
 8003428:	e9c6 3132 	strd	r3, r1, [r6, #200]	; 0xc8
        h += i;
 800342c:	4415      	add	r5, r2
    while (outlen > 0) {
 800342e:	d1d2      	bne.n	80033d6 <shake256_inc_squeeze+0x8a>
}
 8003430:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8003434:	2300      	movs	r3, #0
 8003436:	4619      	mov	r1, r3
 8003438:	e7f5      	b.n	8003426 <shake256_inc_squeeze+0xda>
    s_inc[25] -= i;
 800343a:	e9d6 3e32 	ldrd	r3, lr, [r6, #200]	; 0xc8
 800343e:	2700      	movs	r7, #0
 8003440:	e7c1      	b.n	80033c6 <shake256_inc_squeeze+0x7a>
 8003442:	bf00      	nop

08003444 <shake256_inc_ctx_release>:
    }
    memcpy(dest->ctx, src->ctx, PQC_SHAKEINCCTX_BYTES);
}

void shake256_inc_ctx_release(shake256incctx *state) {
    free(state->ctx);
 8003444:	6800      	ldr	r0, [r0, #0]
 8003446:	f7fc bf41 	b.w	80002cc <free>
 800344a:	bf00      	nop

0800344c <shake256>:
 *              - size_t outlen: requested output length in bytes
 *              - const uint8_t *input: pointer to input
 *              - size_t inlen: length of input in bytes
 **************************************************/
void shake256(uint8_t *output, size_t outlen,
              const uint8_t *input, size_t inlen) {
 800344c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003450:	b0a5      	sub	sp, #148	; 0x94
    size_t nblocks = outlen / SHAKE256_RATE;
 8003452:	4c50      	ldr	r4, [pc, #320]	; (8003594 <shake256+0x148>)
              const uint8_t *input, size_t inlen) {
 8003454:	9001      	str	r0, [sp, #4]
 8003456:	460f      	mov	r7, r1
    state->ctx = malloc(PQC_SHAKECTX_BYTES);
 8003458:	20c8      	movs	r0, #200	; 0xc8
    size_t nblocks = outlen / SHAKE256_RATE;
 800345a:	fba4 1407 	umull	r1, r4, r4, r7
              const uint8_t *input, size_t inlen) {
 800345e:	4615      	mov	r5, r2
 8003460:	4698      	mov	r8, r3
    state->ctx = malloc(PQC_SHAKECTX_BYTES);
 8003462:	f7fc ff2b 	bl	80002bc <malloc>
    if (state->ctx == NULL) {
 8003466:	2800      	cmp	r0, #0
 8003468:	f000 8090 	beq.w	800358c <shake256+0x140>
    keccak_absorb(state->ctx, SHAKE256_RATE, input, inlen, 0x1F);
 800346c:	4642      	mov	r2, r8
 800346e:	4629      	mov	r1, r5
 8003470:	231f      	movs	r3, #31
 8003472:	09e6      	lsrs	r6, r4, #7
 8003474:	4604      	mov	r4, r0
 8003476:	f7ff fdd7 	bl	8003028 <keccak_absorb.constprop.2>
    while (nblocks > 0) {
 800347a:	2f87      	cmp	r7, #135	; 0x87
 800347c:	d93b      	bls.n	80034f6 <shake256+0xaa>
 800347e:	f8dd 9004 	ldr.w	r9, [sp, #4]
 8003482:	46b2      	mov	sl, r6
 8003484:	f1a4 0508 	sub.w	r5, r4, #8
 8003488:	f104 0880 	add.w	r8, r4, #128	; 0x80
        KeccakF1600_StatePermute(s);
 800348c:	4620      	mov	r0, r4
 800348e:	f7fe fc81 	bl	8001d94 <KeccakF1600_StatePermute>
        for (size_t i = 0; i < (r >> 3); i++) {
 8003492:	46ac      	mov	ip, r5
 8003494:	4648      	mov	r0, r9
            store64(h + 8 * i, s[i]);
 8003496:	f85c 2f08 	ldr.w	r2, [ip, #8]!
 800349a:	f8dc 3004 	ldr.w	r3, [ip, #4]
        x[i] = (uint8_t) (u >> 8 * i);
 800349e:	0a11      	lsrs	r1, r2, #8
 80034a0:	f04f 0e00 	mov.w	lr, #0
 80034a4:	ea41 6103 	orr.w	r1, r1, r3, lsl #24
 80034a8:	f362 0e07 	bfi	lr, r2, #0, #8
 80034ac:	ea4f 4b12 	mov.w	fp, r2, lsr #16
 80034b0:	f361 2e0f 	bfi	lr, r1, #8, #8
 80034b4:	ea4b 4b03 	orr.w	fp, fp, r3, lsl #16
 80034b8:	0e12      	lsrs	r2, r2, #24
 80034ba:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 80034be:	2100      	movs	r1, #0
 80034c0:	f36b 4e17 	bfi	lr, fp, #16, #8
 80034c4:	f363 0107 	bfi	r1, r3, #0, #8
 80034c8:	f362 6e1f 	bfi	lr, r2, #24, #8
 80034cc:	0a1a      	lsrs	r2, r3, #8
 80034ce:	f362 210f 	bfi	r1, r2, #8, #8
 80034d2:	0c1a      	lsrs	r2, r3, #16
 80034d4:	f362 4117 	bfi	r1, r2, #16, #8
 80034d8:	0e1b      	lsrs	r3, r3, #24
 80034da:	f363 611f 	bfi	r1, r3, #24, #8
        for (size_t i = 0; i < (r >> 3); i++) {
 80034de:	45e0      	cmp	r8, ip
        x[i] = (uint8_t) (u >> 8 * i);
 80034e0:	f8c0 e000 	str.w	lr, [r0]
 80034e4:	6041      	str	r1, [r0, #4]
        for (size_t i = 0; i < (r >> 3); i++) {
 80034e6:	f100 0008 	add.w	r0, r0, #8
 80034ea:	d1d4      	bne.n	8003496 <shake256+0x4a>
    while (nblocks > 0) {
 80034ec:	f1ba 0a01 	subs.w	sl, sl, #1
        h += r;
 80034f0:	f109 0988 	add.w	r9, r9, #136	; 0x88
    while (nblocks > 0) {
 80034f4:	d1ca      	bne.n	800348c <shake256+0x40>

    shake256_absorb(&s, input, inlen);
    shake256_squeezeblocks(output, nblocks, &s);

    output += nblocks * SHAKE256_RATE;
    outlen -= nblocks * SHAKE256_RATE;
 80034f6:	f8df 809c 	ldr.w	r8, [pc, #156]	; 8003594 <shake256+0x148>
 80034fa:	fba8 3807 	umull	r3, r8, r8, r7
 80034fe:	ea4f 18d8 	mov.w	r8, r8, lsr #7
 8003502:	eb08 1808 	add.w	r8, r8, r8, lsl #4

    if (outlen) {
 8003506:	ebb7 08c8 	subs.w	r8, r7, r8, lsl #3
 800350a:	d105      	bne.n	8003518 <shake256+0xcc>
    free(state->ctx);
 800350c:	4620      	mov	r0, r4
        for (size_t i = 0; i < outlen; ++i) {
            output[i] = t[i];
        }
    }
    shake256_ctx_release(&s);
}
 800350e:	b025      	add	sp, #148	; 0x94
 8003510:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    free(state->ctx);
 8003514:	f7fc beda 	b.w	80002cc <free>
        KeccakF1600_StatePermute(s);
 8003518:	4620      	mov	r0, r4
 800351a:	f7fe fc3b 	bl	8001d94 <KeccakF1600_StatePermute>
        for (size_t i = 0; i < (r >> 3); i++) {
 800351e:	f1a4 0c08 	sub.w	ip, r4, #8
 8003522:	aa03      	add	r2, sp, #12
 8003524:	f10d 0e94 	add.w	lr, sp, #148	; 0x94
            store64(h + 8 * i, s[i]);
 8003528:	f85c 1f08 	ldr.w	r1, [ip, #8]!
 800352c:	f8dc 3004 	ldr.w	r3, [ip, #4]
        x[i] = (uint8_t) (u >> 8 * i);
 8003530:	0a08      	lsrs	r0, r1, #8
 8003532:	2500      	movs	r5, #0
 8003534:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
 8003538:	f361 0507 	bfi	r5, r1, #0, #8
 800353c:	0c0f      	lsrs	r7, r1, #16
 800353e:	f360 250f 	bfi	r5, r0, #8, #8
 8003542:	ea47 4703 	orr.w	r7, r7, r3, lsl #16
 8003546:	0e09      	lsrs	r1, r1, #24
 8003548:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
 800354c:	2000      	movs	r0, #0
 800354e:	f367 4517 	bfi	r5, r7, #16, #8
 8003552:	f363 0007 	bfi	r0, r3, #0, #8
 8003556:	f361 651f 	bfi	r5, r1, #24, #8
 800355a:	0a19      	lsrs	r1, r3, #8
 800355c:	f361 200f 	bfi	r0, r1, #8, #8
 8003560:	0c19      	lsrs	r1, r3, #16
 8003562:	f361 4017 	bfi	r0, r1, #16, #8
 8003566:	0e1b      	lsrs	r3, r3, #24
 8003568:	f363 601f 	bfi	r0, r3, #24, #8
 800356c:	f842 5c04 	str.w	r5, [r2, #-4]
 8003570:	f842 0b08 	str.w	r0, [r2], #8
        for (size_t i = 0; i < (r >> 3); i++) {
 8003574:	4596      	cmp	lr, r2
 8003576:	d1d7      	bne.n	8003528 <shake256+0xdc>
            output[i] = t[i];
 8003578:	9b01      	ldr	r3, [sp, #4]
    output += nblocks * SHAKE256_RATE;
 800357a:	eb06 1606 	add.w	r6, r6, r6, lsl #4
            output[i] = t[i];
 800357e:	4642      	mov	r2, r8
 8003580:	a902      	add	r1, sp, #8
 8003582:	eb03 00c6 	add.w	r0, r3, r6, lsl #3
 8003586:	f7fd f953 	bl	8000830 <memcpy>
 800358a:	e7bf      	b.n	800350c <shake256+0xc0>
        exit(111);
 800358c:	206f      	movs	r0, #111	; 0x6f
 800358e:	f7fc fe4b 	bl	8000228 <exit>
 8003592:	bf00      	nop
 8003594:	f0f0f0f1 	.word	0xf0f0f0f1

08003598 <PQCLEAN_randombytes>:

#include "randombytes.h"



int randombytes(uint8_t *output, size_t n) {
 8003598:	b538      	push	{r3, r4, r5, lr}
 800359a:	4605      	mov	r5, r0
    void *buf = (void *)output;
    int i;
    srand((unsigned)time( NULL ) );
 800359c:	2000      	movs	r0, #0
int randombytes(uint8_t *output, size_t n) {
 800359e:	460c      	mov	r4, r1
    srand((unsigned)time( NULL ) );
 80035a0:	f7fd fa6c 	bl	8000a7c <time>
 80035a4:	f7fd fa34 	bl	8000a10 <srand>
    for(i=0;i<n;++i) output[i] = rand()%256;
 80035a8:	b16c      	cbz	r4, 80035c6 <PQCLEAN_randombytes+0x2e>
 80035aa:	1e61      	subs	r1, r4, #1
 80035ac:	1e6c      	subs	r4, r5, #1
 80035ae:	440d      	add	r5, r1
 80035b0:	f7fd fa36 	bl	8000a20 <rand>
 80035b4:	4242      	negs	r2, r0
 80035b6:	b2d2      	uxtb	r2, r2
 80035b8:	b2c3      	uxtb	r3, r0
 80035ba:	bf58      	it	pl
 80035bc:	4253      	negpl	r3, r2
 80035be:	f804 3f01 	strb.w	r3, [r4, #1]!
 80035c2:	42ac      	cmp	r4, r5
 80035c4:	d1f4      	bne.n	80035b0 <PQCLEAN_randombytes+0x18>
    return 0;
}
 80035c6:	2000      	movs	r0, #0
 80035c8:	bd38      	pop	{r3, r4, r5, pc}
 80035ca:	bf00      	nop

080035cc <simpleserial_put.constprop.0>:
	return;
}

void simpleserial_put(char c, uint8_t size, uint8_t* output)
{
    if (!output) return;
 80035cc:	2900      	cmp	r1, #0
 80035ce:	f000 8164 	beq.w	800389a <simpleserial_put.constprop.0+0x2ce>
void simpleserial_put(char c, uint8_t size, uint8_t* output)
 80035d2:	b530      	push	{r4, r5, lr}
 80035d4:	b0c1      	sub	sp, #260	; 0x104
	data_buf[0] = 0x00;
	data_buf[1] = c;
	data_buf[2] = size;
	int i = 0;
	for (; i < size; i++) {
		data_buf[i + 3] = output[i];
 80035d6:	780a      	ldrb	r2, [r1, #0]
 80035d8:	f88d 2003 	strb.w	r2, [sp, #3]
	data_buf[0] = 0x00;
 80035dc:	2100      	movs	r1, #0
	data_buf[2] = size;
 80035de:	2301      	movs	r3, #1
			crc = crc & 0x80 ? (crc << 1) ^ CW_CRC: crc << 1;
 80035e0:	0604      	lsls	r4, r0, #24
	data_buf[0] = 0x00;
 80035e2:	f88d 1000 	strb.w	r1, [sp]
	data_buf[2] = size;
 80035e6:	f88d 3002 	strb.w	r3, [sp, #2]
	data_buf[1] = c;
 80035ea:	f88d 0001 	strb.w	r0, [sp, #1]
			crc = crc & 0x80 ? (crc << 1) ^ CW_CRC: crc << 1;
 80035ee:	f100 80bb 	bmi.w	8003768 <simpleserial_put.constprop.0+0x19c>
 80035f2:	0041      	lsls	r1, r0, #1
 80035f4:	b2cb      	uxtb	r3, r1
 80035f6:	b249      	sxtb	r1, r1
 80035f8:	2900      	cmp	r1, #0
 80035fa:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80035fe:	f2c0 80be 	blt.w	800377e <simpleserial_put.constprop.0+0x1b2>
 8003602:	b2d9      	uxtb	r1, r3
 8003604:	b25b      	sxtb	r3, r3
 8003606:	2b00      	cmp	r3, #0
 8003608:	f2c0 80c0 	blt.w	800378c <simpleserial_put.constprop.0+0x1c0>
 800360c:	0049      	lsls	r1, r1, #1
 800360e:	b2cb      	uxtb	r3, r1
 8003610:	b249      	sxtb	r1, r1
 8003612:	2900      	cmp	r1, #0
 8003614:	f2c0 80c2 	blt.w	800379c <simpleserial_put.constprop.0+0x1d0>
 8003618:	0059      	lsls	r1, r3, #1
 800361a:	b2cb      	uxtb	r3, r1
 800361c:	b249      	sxtb	r1, r1
 800361e:	2900      	cmp	r1, #0
 8003620:	f2c0 80c4 	blt.w	80037ac <simpleserial_put.constprop.0+0x1e0>
 8003624:	0059      	lsls	r1, r3, #1
 8003626:	b2cb      	uxtb	r3, r1
 8003628:	b249      	sxtb	r1, r1
 800362a:	2900      	cmp	r1, #0
 800362c:	f2c0 80c6 	blt.w	80037bc <simpleserial_put.constprop.0+0x1f0>
 8003630:	0059      	lsls	r1, r3, #1
 8003632:	b2cb      	uxtb	r3, r1
 8003634:	b249      	sxtb	r1, r1
 8003636:	2900      	cmp	r1, #0
 8003638:	f2c0 80c8 	blt.w	80037cc <simpleserial_put.constprop.0+0x200>
 800363c:	0059      	lsls	r1, r3, #1
 800363e:	b2cb      	uxtb	r3, r1
 8003640:	b249      	sxtb	r1, r1
 8003642:	2900      	cmp	r1, #0
 8003644:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8003648:	bfb8      	it	lt
 800364a:	f083 034d 	eorlt.w	r3, r3, #77	; 0x4d
 800364e:	b2db      	uxtb	r3, r3
		crc ^= *buf++;
 8003650:	f083 0101 	eor.w	r1, r3, #1
			crc = crc & 0x80 ? (crc << 1) ^ CW_CRC: crc << 1;
 8003654:	09db      	lsrs	r3, r3, #7
 8003656:	f040 8118 	bne.w	800388a <simpleserial_put.constprop.0+0x2be>
 800365a:	0049      	lsls	r1, r1, #1
 800365c:	b2cb      	uxtb	r3, r1
 800365e:	b249      	sxtb	r1, r1
 8003660:	2900      	cmp	r1, #0
 8003662:	f2c0 810c 	blt.w	800387e <simpleserial_put.constprop.0+0x2b2>
 8003666:	0059      	lsls	r1, r3, #1
 8003668:	b2cb      	uxtb	r3, r1
 800366a:	b249      	sxtb	r1, r1
 800366c:	2900      	cmp	r1, #0
 800366e:	f2c0 8100 	blt.w	8003872 <simpleserial_put.constprop.0+0x2a6>
 8003672:	0059      	lsls	r1, r3, #1
 8003674:	b2cb      	uxtb	r3, r1
 8003676:	b249      	sxtb	r1, r1
 8003678:	2900      	cmp	r1, #0
 800367a:	f2c0 80f4 	blt.w	8003866 <simpleserial_put.constprop.0+0x29a>
 800367e:	0059      	lsls	r1, r3, #1
 8003680:	b2cb      	uxtb	r3, r1
 8003682:	b249      	sxtb	r1, r1
 8003684:	2900      	cmp	r1, #0
 8003686:	f2c0 80e8 	blt.w	800385a <simpleserial_put.constprop.0+0x28e>
 800368a:	0059      	lsls	r1, r3, #1
 800368c:	b2cb      	uxtb	r3, r1
 800368e:	b249      	sxtb	r1, r1
 8003690:	2900      	cmp	r1, #0
 8003692:	f2c0 80dc 	blt.w	800384e <simpleserial_put.constprop.0+0x282>
 8003696:	0059      	lsls	r1, r3, #1
 8003698:	b2cb      	uxtb	r3, r1
 800369a:	b249      	sxtb	r1, r1
 800369c:	2900      	cmp	r1, #0
 800369e:	f2c0 80d0 	blt.w	8003842 <simpleserial_put.constprop.0+0x276>
 80036a2:	0059      	lsls	r1, r3, #1
 80036a4:	b2cb      	uxtb	r3, r1
 80036a6:	b249      	sxtb	r1, r1
 80036a8:	005b      	lsls	r3, r3, #1
 80036aa:	2900      	cmp	r1, #0
 80036ac:	bfb8      	it	lt
 80036ae:	f083 034d 	eorlt.w	r3, r3, #77	; 0x4d
 80036b2:	b2db      	uxtb	r3, r3
		crc ^= *buf++;
 80036b4:	4053      	eors	r3, r2
			crc = crc & 0x80 ? (crc << 1) ^ CW_CRC: crc << 1;
 80036b6:	0619      	lsls	r1, r3, #24
 80036b8:	f100 80bd 	bmi.w	8003836 <simpleserial_put.constprop.0+0x26a>
 80036bc:	0059      	lsls	r1, r3, #1
 80036be:	b2cb      	uxtb	r3, r1
 80036c0:	b249      	sxtb	r1, r1
 80036c2:	2900      	cmp	r1, #0
 80036c4:	f2c0 80b1 	blt.w	800382a <simpleserial_put.constprop.0+0x25e>
 80036c8:	0059      	lsls	r1, r3, #1
 80036ca:	b2cb      	uxtb	r3, r1
 80036cc:	b249      	sxtb	r1, r1
 80036ce:	2900      	cmp	r1, #0
 80036d0:	f2c0 80a5 	blt.w	800381e <simpleserial_put.constprop.0+0x252>
 80036d4:	0059      	lsls	r1, r3, #1
 80036d6:	b2cb      	uxtb	r3, r1
 80036d8:	b249      	sxtb	r1, r1
 80036da:	2900      	cmp	r1, #0
 80036dc:	f2c0 8099 	blt.w	8003812 <simpleserial_put.constprop.0+0x246>
 80036e0:	0059      	lsls	r1, r3, #1
 80036e2:	b2cb      	uxtb	r3, r1
 80036e4:	b249      	sxtb	r1, r1
 80036e6:	2900      	cmp	r1, #0
 80036e8:	f2c0 808d 	blt.w	8003806 <simpleserial_put.constprop.0+0x23a>
 80036ec:	0059      	lsls	r1, r3, #1
 80036ee:	b2cb      	uxtb	r3, r1
 80036f0:	b249      	sxtb	r1, r1
 80036f2:	2900      	cmp	r1, #0
 80036f4:	f2c0 8081 	blt.w	80037fa <simpleserial_put.constprop.0+0x22e>
 80036f8:	0059      	lsls	r1, r3, #1
 80036fa:	b2cb      	uxtb	r3, r1
 80036fc:	b249      	sxtb	r1, r1
 80036fe:	2900      	cmp	r1, #0
 8003700:	db75      	blt.n	80037ee <simpleserial_put.constprop.0+0x222>
 8003702:	0059      	lsls	r1, r3, #1
 8003704:	b2cb      	uxtb	r3, r1
 8003706:	b249      	sxtb	r1, r1
 8003708:	005b      	lsls	r3, r3, #1
 800370a:	2900      	cmp	r1, #0
 800370c:	bfb8      	it	lt
 800370e:	f083 034d 	eorlt.w	r3, r3, #77	; 0x4d
 8003712:	b2db      	uxtb	r3, r3
	}
	data_buf[i + 3] = ss_crc(data_buf+1, size+2);
	data_buf[i + 4] = 0x00;
 8003714:	2100      	movs	r1, #0
	data_buf[i + 3] = ss_crc(data_buf+1, size+2);
 8003716:	f88d 3004 	strb.w	r3, [sp, #4]
	data_buf[i + 4] = 0x00;
 800371a:	f88d 1005 	strb.w	r1, [sp, #5]
		if (buf[i] == FRAME_BYTE) {
 800371e:	2800      	cmp	r0, #0
 8003720:	d163      	bne.n	80037ea <simpleserial_put.constprop.0+0x21e>
			buf[last] = i - last;
 8003722:	2301      	movs	r3, #1
 8003724:	f88d 3000 	strb.w	r3, [sp]
		if (buf[i] == FRAME_BYTE) {
 8003728:	2a00      	cmp	r2, #0
 800372a:	d155      	bne.n	80037d8 <simpleserial_put.constprop.0+0x20c>
			buf[last] = i - last;
 800372c:	f1c3 0203 	rsb	r2, r3, #3
 8003730:	f80d 2003 	strb.w	r2, [sp, r3]
		if (buf[i] == FRAME_BYTE) {
 8003734:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8003738:	2b00      	cmp	r3, #0
 800373a:	f040 80ac 	bne.w	8003896 <simpleserial_put.constprop.0+0x2ca>
	for (; i < len; i++) {
 800373e:	2303      	movs	r3, #3
			buf[last] = i - last;
 8003740:	f1c3 0204 	rsb	r2, r3, #4
 8003744:	f80d 2003 	strb.w	r2, [sp, r3]
	for (; i < len; i++) {
 8003748:	2304      	movs	r3, #4
		if (buf[i] == FRAME_BYTE) {
 800374a:	f89d 2005 	ldrb.w	r2, [sp, #5]
 800374e:	2a00      	cmp	r2, #0
 8003750:	d046      	beq.n	80037e0 <simpleserial_put.constprop.0+0x214>
	for (; i < len; i++) {
 8003752:	466c      	mov	r4, sp
 8003754:	f10d 0506 	add.w	r5, sp, #6
	stuff_data(data_buf, i + 5);
	for (int i = 0; i < size + 5; i++) {
		putch(data_buf[i]);
 8003758:	f814 0b01 	ldrb.w	r0, [r4], #1
 800375c:	f000 fb98 	bl	8003e90 <putch>
	for (int i = 0; i < size + 5; i++) {
 8003760:	42ac      	cmp	r4, r5
 8003762:	d1f9      	bne.n	8003758 <simpleserial_put.constprop.0+0x18c>
	}
}
 8003764:	b041      	add	sp, #260	; 0x104
 8003766:	bd30      	pop	{r4, r5, pc}
			crc = crc & 0x80 ? (crc << 1) ^ CW_CRC: crc << 1;
 8003768:	fa00 f303 	lsl.w	r3, r0, r3
 800376c:	f083 034d 	eor.w	r3, r3, #77	; 0x4d
 8003770:	b259      	sxtb	r1, r3
 8003772:	2900      	cmp	r1, #0
 8003774:	b2db      	uxtb	r3, r3
 8003776:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800377a:	f6bf af42 	bge.w	8003602 <simpleserial_put.constprop.0+0x36>
 800377e:	f083 014d 	eor.w	r1, r3, #77	; 0x4d
 8003782:	b24b      	sxtb	r3, r1
 8003784:	2b00      	cmp	r3, #0
 8003786:	b2c9      	uxtb	r1, r1
 8003788:	f6bf af40 	bge.w	800360c <simpleserial_put.constprop.0+0x40>
 800378c:	004b      	lsls	r3, r1, #1
 800378e:	f083 034d 	eor.w	r3, r3, #77	; 0x4d
 8003792:	b259      	sxtb	r1, r3
 8003794:	2900      	cmp	r1, #0
 8003796:	b2db      	uxtb	r3, r3
 8003798:	f6bf af3e 	bge.w	8003618 <simpleserial_put.constprop.0+0x4c>
 800379c:	005b      	lsls	r3, r3, #1
 800379e:	f083 034d 	eor.w	r3, r3, #77	; 0x4d
 80037a2:	b259      	sxtb	r1, r3
 80037a4:	2900      	cmp	r1, #0
 80037a6:	b2db      	uxtb	r3, r3
 80037a8:	f6bf af3c 	bge.w	8003624 <simpleserial_put.constprop.0+0x58>
 80037ac:	005b      	lsls	r3, r3, #1
 80037ae:	f083 034d 	eor.w	r3, r3, #77	; 0x4d
 80037b2:	b259      	sxtb	r1, r3
 80037b4:	2900      	cmp	r1, #0
 80037b6:	b2db      	uxtb	r3, r3
 80037b8:	f6bf af3a 	bge.w	8003630 <simpleserial_put.constprop.0+0x64>
 80037bc:	005b      	lsls	r3, r3, #1
 80037be:	f083 034d 	eor.w	r3, r3, #77	; 0x4d
 80037c2:	b259      	sxtb	r1, r3
 80037c4:	2900      	cmp	r1, #0
 80037c6:	b2db      	uxtb	r3, r3
 80037c8:	f6bf af38 	bge.w	800363c <simpleserial_put.constprop.0+0x70>
 80037cc:	005b      	lsls	r3, r3, #1
 80037ce:	f083 034d 	eor.w	r3, r3, #77	; 0x4d
 80037d2:	b259      	sxtb	r1, r3
 80037d4:	b2db      	uxtb	r3, r3
 80037d6:	e734      	b.n	8003642 <simpleserial_put.constprop.0+0x76>
		if (buf[i] == FRAME_BYTE) {
 80037d8:	f89d 2004 	ldrb.w	r2, [sp, #4]
 80037dc:	2a00      	cmp	r2, #0
 80037de:	d0af      	beq.n	8003740 <simpleserial_put.constprop.0+0x174>
			buf[last] = i - last;
 80037e0:	f1c3 0205 	rsb	r2, r3, #5
 80037e4:	f80d 2003 	strb.w	r2, [sp, r3]
			last = i;
 80037e8:	e7b3      	b.n	8003752 <simpleserial_put.constprop.0+0x186>
	uint8_t last = 0;
 80037ea:	460b      	mov	r3, r1
 80037ec:	e79c      	b.n	8003728 <simpleserial_put.constprop.0+0x15c>
			crc = crc & 0x80 ? (crc << 1) ^ CW_CRC: crc << 1;
 80037ee:	005b      	lsls	r3, r3, #1
 80037f0:	f083 034d 	eor.w	r3, r3, #77	; 0x4d
 80037f4:	b259      	sxtb	r1, r3
 80037f6:	b2db      	uxtb	r3, r3
 80037f8:	e786      	b.n	8003708 <simpleserial_put.constprop.0+0x13c>
 80037fa:	005b      	lsls	r3, r3, #1
 80037fc:	f083 034d 	eor.w	r3, r3, #77	; 0x4d
 8003800:	b259      	sxtb	r1, r3
 8003802:	b2db      	uxtb	r3, r3
 8003804:	e77b      	b.n	80036fe <simpleserial_put.constprop.0+0x132>
 8003806:	005b      	lsls	r3, r3, #1
 8003808:	f083 034d 	eor.w	r3, r3, #77	; 0x4d
 800380c:	b259      	sxtb	r1, r3
 800380e:	b2db      	uxtb	r3, r3
 8003810:	e76f      	b.n	80036f2 <simpleserial_put.constprop.0+0x126>
 8003812:	005b      	lsls	r3, r3, #1
 8003814:	f083 034d 	eor.w	r3, r3, #77	; 0x4d
 8003818:	b259      	sxtb	r1, r3
 800381a:	b2db      	uxtb	r3, r3
 800381c:	e763      	b.n	80036e6 <simpleserial_put.constprop.0+0x11a>
 800381e:	005b      	lsls	r3, r3, #1
 8003820:	f083 034d 	eor.w	r3, r3, #77	; 0x4d
 8003824:	b259      	sxtb	r1, r3
 8003826:	b2db      	uxtb	r3, r3
 8003828:	e757      	b.n	80036da <simpleserial_put.constprop.0+0x10e>
 800382a:	005b      	lsls	r3, r3, #1
 800382c:	f083 034d 	eor.w	r3, r3, #77	; 0x4d
 8003830:	b259      	sxtb	r1, r3
 8003832:	b2db      	uxtb	r3, r3
 8003834:	e74b      	b.n	80036ce <simpleserial_put.constprop.0+0x102>
 8003836:	005b      	lsls	r3, r3, #1
 8003838:	f083 034d 	eor.w	r3, r3, #77	; 0x4d
 800383c:	b259      	sxtb	r1, r3
 800383e:	b2db      	uxtb	r3, r3
 8003840:	e73f      	b.n	80036c2 <simpleserial_put.constprop.0+0xf6>
 8003842:	005b      	lsls	r3, r3, #1
 8003844:	f083 034d 	eor.w	r3, r3, #77	; 0x4d
 8003848:	b259      	sxtb	r1, r3
 800384a:	b2db      	uxtb	r3, r3
 800384c:	e72c      	b.n	80036a8 <simpleserial_put.constprop.0+0xdc>
 800384e:	005b      	lsls	r3, r3, #1
 8003850:	f083 034d 	eor.w	r3, r3, #77	; 0x4d
 8003854:	b259      	sxtb	r1, r3
 8003856:	b2db      	uxtb	r3, r3
 8003858:	e720      	b.n	800369c <simpleserial_put.constprop.0+0xd0>
 800385a:	005b      	lsls	r3, r3, #1
 800385c:	f083 034d 	eor.w	r3, r3, #77	; 0x4d
 8003860:	b259      	sxtb	r1, r3
 8003862:	b2db      	uxtb	r3, r3
 8003864:	e714      	b.n	8003690 <simpleserial_put.constprop.0+0xc4>
 8003866:	005b      	lsls	r3, r3, #1
 8003868:	f083 034d 	eor.w	r3, r3, #77	; 0x4d
 800386c:	b259      	sxtb	r1, r3
 800386e:	b2db      	uxtb	r3, r3
 8003870:	e708      	b.n	8003684 <simpleserial_put.constprop.0+0xb8>
 8003872:	005b      	lsls	r3, r3, #1
 8003874:	f083 034d 	eor.w	r3, r3, #77	; 0x4d
 8003878:	b259      	sxtb	r1, r3
 800387a:	b2db      	uxtb	r3, r3
 800387c:	e6fc      	b.n	8003678 <simpleserial_put.constprop.0+0xac>
 800387e:	005b      	lsls	r3, r3, #1
 8003880:	f083 034d 	eor.w	r3, r3, #77	; 0x4d
 8003884:	b259      	sxtb	r1, r3
 8003886:	b2db      	uxtb	r3, r3
 8003888:	e6f0      	b.n	800366c <simpleserial_put.constprop.0+0xa0>
 800388a:	004b      	lsls	r3, r1, #1
 800388c:	f083 034d 	eor.w	r3, r3, #77	; 0x4d
 8003890:	b259      	sxtb	r1, r3
 8003892:	b2db      	uxtb	r3, r3
 8003894:	e6e4      	b.n	8003660 <simpleserial_put.constprop.0+0x94>
	for (; i < len; i++) {
 8003896:	2303      	movs	r3, #3
 8003898:	e757      	b.n	800374a <simpleserial_put.constprop.0+0x17e>
 800389a:	4770      	bx	lr

0800389c <check_version>:
{
 800389c:	b500      	push	{lr}
 800389e:	b083      	sub	sp, #12
	uint8_t ver = SS_VER;
 80038a0:	2303      	movs	r3, #3
	simpleserial_put('r', 1, &ver);
 80038a2:	2072      	movs	r0, #114	; 0x72
 80038a4:	f10d 0107 	add.w	r1, sp, #7
	uint8_t ver = SS_VER;
 80038a8:	f88d 3007 	strb.w	r3, [sp, #7]
	simpleserial_put('r', 1, &ver);
 80038ac:	f7ff fe8e 	bl	80035cc <simpleserial_put.constprop.0>
}
 80038b0:	2000      	movs	r0, #0
 80038b2:	b003      	add	sp, #12
 80038b4:	f85d fb04 	ldr.w	pc, [sp], #4

080038b8 <simpleserial_init>:
{
 80038b8:	b510      	push	{r4, lr}
	if(num_commands >= MAX_SS_CMDS) {
 80038ba:	4c15      	ldr	r4, [pc, #84]	; (8003910 <simpleserial_init+0x58>)
 80038bc:	6823      	ldr	r3, [r4, #0]
 80038be:	2b0f      	cmp	r3, #15
 80038c0:	dc1b      	bgt.n	80038fa <simpleserial_init+0x42>
	commands[num_commands].c   = c;
 80038c2:	eb03 0243 	add.w	r2, r3, r3, lsl #1
 80038c6:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 80038ca:	2076      	movs	r0, #118	; 0x76
	num_commands++;
 80038cc:	3301      	adds	r3, #1
	commands[num_commands].fp  = fp;
 80038ce:	4911      	ldr	r1, [pc, #68]	; (8003914 <simpleserial_init+0x5c>)
	commands[num_commands].c   = c;
 80038d0:	7110      	strb	r0, [r2, #4]
	if(num_commands >= MAX_SS_CMDS) {
 80038d2:	2b0f      	cmp	r3, #15
	commands[num_commands].len = len;
 80038d4:	f04f 0000 	mov.w	r0, #0
	commands[num_commands].fp  = fp;
 80038d8:	e9c2 0102 	strd	r0, r1, [r2, #8]
	num_commands++;
 80038dc:	6023      	str	r3, [r4, #0]
	if(num_commands >= MAX_SS_CMDS) {
 80038de:	dc12      	bgt.n	8003906 <simpleserial_init+0x4e>
	commands[num_commands].c   = c;
 80038e0:	eb03 0243 	add.w	r2, r3, r3, lsl #1
 80038e4:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 80038e8:	2077      	movs	r0, #119	; 0x77
	commands[num_commands].fp  = fp;
 80038ea:	490b      	ldr	r1, [pc, #44]	; (8003918 <simpleserial_init+0x60>)
	commands[num_commands].c   = c;
 80038ec:	7110      	strb	r0, [r2, #4]
	num_commands++;
 80038ee:	3301      	adds	r3, #1
	commands[num_commands].len = len;
 80038f0:	2000      	movs	r0, #0
	commands[num_commands].fp  = fp;
 80038f2:	e9c2 0102 	strd	r0, r1, [r2, #8]
	num_commands++;
 80038f6:	6023      	str	r3, [r4, #0]
}
 80038f8:	bd10      	pop	{r4, pc}
		putch('a');
 80038fa:	2061      	movs	r0, #97	; 0x61
 80038fc:	f000 fac8 	bl	8003e90 <putch>
	if(num_commands >= MAX_SS_CMDS) {
 8003900:	6823      	ldr	r3, [r4, #0]
 8003902:	2b0f      	cmp	r3, #15
 8003904:	ddec      	ble.n	80038e0 <simpleserial_init+0x28>
}
 8003906:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		putch('a');
 800390a:	2061      	movs	r0, #97	; 0x61
 800390c:	f000 bac0 	b.w	8003e90 <putch>
 8003910:	2000177c 	.word	0x2000177c
 8003914:	0800389d 	.word	0x0800389d
 8003918:	08003cc5 	.word	0x08003cc5

0800391c <simpleserial_addcmd>:
{
 800391c:	b510      	push	{r4, lr}
	if(num_commands >= MAX_SS_CMDS) {
 800391e:	4c0e      	ldr	r4, [pc, #56]	; (8003958 <simpleserial_addcmd+0x3c>)
 8003920:	6823      	ldr	r3, [r4, #0]
 8003922:	2b0f      	cmp	r3, #15
 8003924:	dc0d      	bgt.n	8003942 <simpleserial_addcmd+0x26>
	if(len >= MAX_SS_LEN) {
 8003926:	29ff      	cmp	r1, #255	; 0xff
 8003928:	d810      	bhi.n	800394c <simpleserial_addcmd+0x30>
	commands[num_commands].c   = c;
 800392a:	eb03 0c43 	add.w	ip, r3, r3, lsl #1
 800392e:	eb04 0c8c 	add.w	ip, r4, ip, lsl #2
	num_commands++;
 8003932:	3301      	adds	r3, #1
	commands[num_commands].c   = c;
 8003934:	f88c 0004 	strb.w	r0, [ip, #4]
	commands[num_commands].fp  = fp;
 8003938:	e9cc 1202 	strd	r1, r2, [ip, #8]
	num_commands++;
 800393c:	6023      	str	r3, [r4, #0]
	return 0;
 800393e:	2000      	movs	r0, #0
}
 8003940:	bd10      	pop	{r4, pc}
		putch('a');
 8003942:	2061      	movs	r0, #97	; 0x61
 8003944:	f000 faa4 	bl	8003e90 <putch>
		return 1;
 8003948:	2001      	movs	r0, #1
}
 800394a:	bd10      	pop	{r4, pc}
		putch('b');
 800394c:	2062      	movs	r0, #98	; 0x62
 800394e:	f000 fa9f 	bl	8003e90 <putch>
		return 1;
 8003952:	2001      	movs	r0, #1
}
 8003954:	bd10      	pop	{r4, pc}
 8003956:	bf00      	nop
 8003958:	2000177c 	.word	0x2000177c

0800395c <simpleserial_get>:
{
 800395c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003960:	b0c3      	sub	sp, #268	; 0x10c
	uint8_t err = 0;
 8003962:	2300      	movs	r3, #0
 8003964:	ad02      	add	r5, sp, #8
 8003966:	f88d 3007 	strb.w	r3, [sp, #7]
	for (int i = 0; i < 4; i++) {
 800396a:	462c      	mov	r4, r5
 800396c:	ae03      	add	r6, sp, #12
		data_buf[i] = getch(); //PTR, cmd, scmd, len
 800396e:	f000 fa7b 	bl	8003e68 <getch>
 8003972:	f804 0b01 	strb.w	r0, [r4], #1
		if (data_buf[i] == FRAME_BYTE) {
 8003976:	2800      	cmp	r0, #0
 8003978:	d03d      	beq.n	80039f6 <simpleserial_get+0x9a>
	for (int i = 0; i < 4; i++) {
 800397a:	42a6      	cmp	r6, r4
 800397c:	d1f7      	bne.n	800396e <simpleserial_get+0x12>
	uint8_t next = buf[0];
 800397e:	782c      	ldrb	r4, [r5, #0]
	buf[0] = 0x00;
 8003980:	2200      	movs	r2, #0
	while ((next < len) && tmp != 0) {
 8003982:	2c03      	cmp	r4, #3
	buf[0] = 0x00;
 8003984:	702a      	strb	r2, [r5, #0]
	while ((next < len) && tmp != 0) {
 8003986:	d808      	bhi.n	800399a <simpleserial_get+0x3e>
 8003988:	b90c      	cbnz	r4, 800398e <simpleserial_get+0x32>
 800398a:	e006      	b.n	800399a <simpleserial_get+0x3e>
 800398c:	b12b      	cbz	r3, 800399a <simpleserial_get+0x3e>
		tmp = buf[next];
 800398e:	5d2b      	ldrb	r3, [r5, r4]
		buf[next] = FRAME_BYTE;
 8003990:	552a      	strb	r2, [r5, r4]
		next += tmp;
 8003992:	441c      	add	r4, r3
 8003994:	b2e4      	uxtb	r4, r4
	while ((next < len) && tmp != 0) {
 8003996:	2c03      	cmp	r4, #3
 8003998:	d9f8      	bls.n	800398c <simpleserial_get+0x30>
	for(c = 0; c < num_commands; c++)
 800399a:	f8df 81b4 	ldr.w	r8, [pc, #436]	; 8003b50 <simpleserial_get+0x1f4>
 800399e:	f8d8 1000 	ldr.w	r1, [r8]
 80039a2:	2900      	cmp	r1, #0
 80039a4:	bfd8      	it	le
 80039a6:	2700      	movle	r7, #0
 80039a8:	dd39      	ble.n	8003a1e <simpleserial_get+0xc2>
		if(commands[c].c == data_buf[1])
 80039aa:	2300      	movs	r3, #0
 80039ac:	7868      	ldrb	r0, [r5, #1]
	for(c = 0; c < num_commands; c++)
 80039ae:	461f      	mov	r7, r3
 80039b0:	e002      	b.n	80039b8 <simpleserial_get+0x5c>
 80039b2:	428b      	cmp	r3, r1
 80039b4:	461f      	mov	r7, r3
 80039b6:	da32      	bge.n	8003a1e <simpleserial_get+0xc2>
		if(commands[c].c == data_buf[1])
 80039b8:	eb07 0247 	add.w	r2, r7, r7, lsl #1
 80039bc:	eb08 0282 	add.w	r2, r8, r2, lsl #2
	for(c = 0; c < num_commands; c++)
 80039c0:	3301      	adds	r3, #1
		if(commands[c].c == data_buf[1])
 80039c2:	7912      	ldrb	r2, [r2, #4]
 80039c4:	4282      	cmp	r2, r0
	for(c = 0; c < num_commands; c++)
 80039c6:	b2db      	uxtb	r3, r3
		if(commands[c].c == data_buf[1])
 80039c8:	d1f3      	bne.n	80039b2 <simpleserial_get+0x56>
	if ((data_buf[3] + 5) < next_frame) {
 80039ca:	78eb      	ldrb	r3, [r5, #3]
 80039cc:	3305      	adds	r3, #5
 80039ce:	42a3      	cmp	r3, r4
 80039d0:	db1a      	blt.n	8003a08 <simpleserial_get+0xac>
 80039d2:	f10d 0b0b 	add.w	fp, sp, #11
	int i = 4;
 80039d6:	f04f 0904 	mov.w	r9, #4
 80039da:	e004      	b.n	80039e6 <simpleserial_get+0x8a>
	for (; i < data_buf[3] + 5; i++) {
 80039dc:	78eb      	ldrb	r3, [r5, #3]
 80039de:	3304      	adds	r3, #4
 80039e0:	4553      	cmp	r3, sl
 80039e2:	db0c      	blt.n	80039fe <simpleserial_get+0xa2>
 80039e4:	46d1      	mov	r9, sl
		data_buf[i] = getch();
 80039e6:	f000 fa3f 	bl	8003e68 <getch>
	for (; i < data_buf[3] + 5; i++) {
 80039ea:	f109 0a01 	add.w	sl, r9, #1
		data_buf[i] = getch();
 80039ee:	f80b 0f01 	strb.w	r0, [fp, #1]!
		if (data_buf[i] == FRAME_BYTE) {
 80039f2:	2800      	cmp	r0, #0
 80039f4:	d1f2      	bne.n	80039dc <simpleserial_get+0x80>
			err = SS_ERR_FRAME_BYTE;
 80039f6:	2305      	movs	r3, #5
 80039f8:	f88d 3007 	strb.w	r3, [sp, #7]
			goto ERROR;
 80039fc:	e007      	b.n	8003a0e <simpleserial_get+0xb2>
	data_buf[i] = getch();
 80039fe:	f000 fa33 	bl	8003e68 <getch>
 8003a02:	f805 000a 	strb.w	r0, [r5, sl]
	if (data_buf[i] != FRAME_BYTE) {
 8003a06:	b180      	cbz	r0, 8003a2a <simpleserial_get+0xce>
		err = SS_ERR_LEN;
 8003a08:	2304      	movs	r3, #4
 8003a0a:	f88d 3007 	strb.w	r3, [sp, #7]
	simpleserial_put('e', 0x01, &err);
 8003a0e:	f10d 0107 	add.w	r1, sp, #7
 8003a12:	2065      	movs	r0, #101	; 0x65
 8003a14:	f7ff fdda 	bl	80035cc <simpleserial_put.constprop.0>
}
 8003a18:	b043      	add	sp, #268	; 0x10c
 8003a1a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (c == num_commands) {
 8003a1e:	428f      	cmp	r7, r1
 8003a20:	d1d3      	bne.n	80039ca <simpleserial_get+0x6e>
		err = SS_ERR_CMD;
 8003a22:	2301      	movs	r3, #1
 8003a24:	f88d 3007 	strb.w	r3, [sp, #7]
		goto ERROR;
 8003a28:	e7f1      	b.n	8003a0e <simpleserial_get+0xb2>
	unstuff_data(data_buf + next_frame, i - next_frame + 1);
 8003a2a:	f1c4 0101 	rsb	r1, r4, #1
 8003a2e:	fa5f fa8a 	uxtb.w	sl, sl
	uint8_t next = buf[0];
 8003a32:	5d2b      	ldrb	r3, [r5, r4]
	buf[0] = 0x00;
 8003a34:	5528      	strb	r0, [r5, r4]
	unstuff_data(data_buf + next_frame, i - next_frame + 1);
 8003a36:	4451      	add	r1, sl
 8003a38:	b2c9      	uxtb	r1, r1
	while ((next < len) && tmp != 0) {
 8003a3a:	4299      	cmp	r1, r3
	unstuff_data(data_buf + next_frame, i - next_frame + 1);
 8003a3c:	442c      	add	r4, r5
	while ((next < len) && tmp != 0) {
 8003a3e:	d90a      	bls.n	8003a56 <simpleserial_get+0xfa>
 8003a40:	b14b      	cbz	r3, 8003a56 <simpleserial_get+0xfa>
		buf[next] = FRAME_BYTE;
 8003a42:	4684      	mov	ip, r0
 8003a44:	e000      	b.n	8003a48 <simpleserial_get+0xec>
	while ((next < len) && tmp != 0) {
 8003a46:	b132      	cbz	r2, 8003a56 <simpleserial_get+0xfa>
		tmp = buf[next];
 8003a48:	5ce2      	ldrb	r2, [r4, r3]
		buf[next] = FRAME_BYTE;
 8003a4a:	f804 c003 	strb.w	ip, [r4, r3]
		next += tmp;
 8003a4e:	4413      	add	r3, r2
 8003a50:	b2db      	uxtb	r3, r3
	while ((next < len) && tmp != 0) {
 8003a52:	4299      	cmp	r1, r3
 8003a54:	d8f7      	bhi.n	8003a46 <simpleserial_get+0xea>
	while (len--) {
 8003a56:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
 8003a5a:	fa55 f48a 	uxtab	r4, r5, sl
 8003a5e:	f10d 0109 	add.w	r1, sp, #9
 8003a62:	e029      	b.n	8003ab8 <simpleserial_get+0x15c>
			crc = crc & 0x80 ? (crc << 1) ^ CW_CRC: crc << 1;
 8003a64:	005a      	lsls	r2, r3, #1
 8003a66:	b2d3      	uxtb	r3, r2
 8003a68:	b252      	sxtb	r2, r2
 8003a6a:	2a00      	cmp	r2, #0
 8003a6c:	db31      	blt.n	8003ad2 <simpleserial_get+0x176>
 8003a6e:	005a      	lsls	r2, r3, #1
 8003a70:	b2d3      	uxtb	r3, r2
 8003a72:	b252      	sxtb	r2, r2
 8003a74:	2a00      	cmp	r2, #0
 8003a76:	db33      	blt.n	8003ae0 <simpleserial_get+0x184>
 8003a78:	005a      	lsls	r2, r3, #1
 8003a7a:	b2d3      	uxtb	r3, r2
 8003a7c:	b252      	sxtb	r2, r2
 8003a7e:	2a00      	cmp	r2, #0
 8003a80:	db35      	blt.n	8003aee <simpleserial_get+0x192>
 8003a82:	005a      	lsls	r2, r3, #1
 8003a84:	b2d3      	uxtb	r3, r2
 8003a86:	b252      	sxtb	r2, r2
 8003a88:	2a00      	cmp	r2, #0
 8003a8a:	db37      	blt.n	8003afc <simpleserial_get+0x1a0>
 8003a8c:	005a      	lsls	r2, r3, #1
 8003a8e:	b2d3      	uxtb	r3, r2
 8003a90:	b252      	sxtb	r2, r2
 8003a92:	2a00      	cmp	r2, #0
 8003a94:	db39      	blt.n	8003b0a <simpleserial_get+0x1ae>
 8003a96:	005a      	lsls	r2, r3, #1
 8003a98:	b2d3      	uxtb	r3, r2
 8003a9a:	b252      	sxtb	r2, r2
 8003a9c:	2a00      	cmp	r2, #0
 8003a9e:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8003aa2:	db3b      	blt.n	8003b1c <simpleserial_get+0x1c0>
 8003aa4:	b2d8      	uxtb	r0, r3
 8003aa6:	b25b      	sxtb	r3, r3
 8003aa8:	0040      	lsls	r0, r0, #1
 8003aaa:	2b00      	cmp	r3, #0
 8003aac:	bfb8      	it	lt
 8003aae:	f080 004d 	eorlt.w	r0, r0, #77	; 0x4d
	while (len--) {
 8003ab2:	428c      	cmp	r4, r1
			crc = crc & 0x80 ? (crc << 1) ^ CW_CRC: crc << 1;
 8003ab4:	b2c0      	uxtb	r0, r0
	while (len--) {
 8003ab6:	d036      	beq.n	8003b26 <simpleserial_get+0x1ca>
		crc ^= *buf++;
 8003ab8:	f811 3b01 	ldrb.w	r3, [r1], #1
 8003abc:	4058      	eors	r0, r3
			crc = crc & 0x80 ? (crc << 1) ^ CW_CRC: crc << 1;
 8003abe:	0602      	lsls	r2, r0, #24
		crc ^= *buf++;
 8003ac0:	b2c3      	uxtb	r3, r0
			crc = crc & 0x80 ? (crc << 1) ^ CW_CRC: crc << 1;
 8003ac2:	d5cf      	bpl.n	8003a64 <simpleserial_get+0x108>
 8003ac4:	005b      	lsls	r3, r3, #1
 8003ac6:	f083 034d 	eor.w	r3, r3, #77	; 0x4d
 8003aca:	b25a      	sxtb	r2, r3
 8003acc:	2a00      	cmp	r2, #0
 8003ace:	b2db      	uxtb	r3, r3
 8003ad0:	dacd      	bge.n	8003a6e <simpleserial_get+0x112>
 8003ad2:	005b      	lsls	r3, r3, #1
 8003ad4:	f083 034d 	eor.w	r3, r3, #77	; 0x4d
 8003ad8:	b25a      	sxtb	r2, r3
 8003ada:	2a00      	cmp	r2, #0
 8003adc:	b2db      	uxtb	r3, r3
 8003ade:	dacb      	bge.n	8003a78 <simpleserial_get+0x11c>
 8003ae0:	005b      	lsls	r3, r3, #1
 8003ae2:	f083 034d 	eor.w	r3, r3, #77	; 0x4d
 8003ae6:	b25a      	sxtb	r2, r3
 8003ae8:	2a00      	cmp	r2, #0
 8003aea:	b2db      	uxtb	r3, r3
 8003aec:	dac9      	bge.n	8003a82 <simpleserial_get+0x126>
 8003aee:	005b      	lsls	r3, r3, #1
 8003af0:	f083 034d 	eor.w	r3, r3, #77	; 0x4d
 8003af4:	b25a      	sxtb	r2, r3
 8003af6:	2a00      	cmp	r2, #0
 8003af8:	b2db      	uxtb	r3, r3
 8003afa:	dac7      	bge.n	8003a8c <simpleserial_get+0x130>
 8003afc:	005b      	lsls	r3, r3, #1
 8003afe:	f083 034d 	eor.w	r3, r3, #77	; 0x4d
 8003b02:	b25a      	sxtb	r2, r3
 8003b04:	2a00      	cmp	r2, #0
 8003b06:	b2db      	uxtb	r3, r3
 8003b08:	dac5      	bge.n	8003a96 <simpleserial_get+0x13a>
 8003b0a:	005b      	lsls	r3, r3, #1
 8003b0c:	f083 034d 	eor.w	r3, r3, #77	; 0x4d
 8003b10:	b25a      	sxtb	r2, r3
 8003b12:	2a00      	cmp	r2, #0
 8003b14:	b2db      	uxtb	r3, r3
 8003b16:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8003b1a:	dac3      	bge.n	8003aa4 <simpleserial_get+0x148>
 8003b1c:	f083 004d 	eor.w	r0, r3, #77	; 0x4d
 8003b20:	b243      	sxtb	r3, r0
 8003b22:	b2c0      	uxtb	r0, r0
 8003b24:	e7c0      	b.n	8003aa8 <simpleserial_get+0x14c>
	if (crc != data_buf[i-1]) {
 8003b26:	f815 3009 	ldrb.w	r3, [r5, r9]
 8003b2a:	4283      	cmp	r3, r0
 8003b2c:	d003      	beq.n	8003b36 <simpleserial_get+0x1da>
		err = SS_ERR_CRC;
 8003b2e:	2302      	movs	r3, #2
 8003b30:	f88d 3007 	strb.w	r3, [sp, #7]
		goto ERROR;
 8003b34:	e76b      	b.n	8003a0e <simpleserial_get+0xb2>
	err = commands[c].fp(data_buf[1], data_buf[2], data_buf[3], data_buf+4);
 8003b36:	eb07 0747 	add.w	r7, r7, r7, lsl #1
 8003b3a:	eb08 0787 	add.w	r7, r8, r7, lsl #2
 8003b3e:	78ea      	ldrb	r2, [r5, #3]
 8003b40:	68fc      	ldr	r4, [r7, #12]
 8003b42:	78a9      	ldrb	r1, [r5, #2]
 8003b44:	7868      	ldrb	r0, [r5, #1]
 8003b46:	4633      	mov	r3, r6
 8003b48:	47a0      	blx	r4
 8003b4a:	f88d 0007 	strb.w	r0, [sp, #7]
 8003b4e:	e75e      	b.n	8003a0e <simpleserial_get+0xb2>
 8003b50:	2000177c 	.word	0x2000177c

08003b54 <simpleserial_put>:
    if (!output) return;
 8003b54:	2a00      	cmp	r2, #0
 8003b56:	f000 80a7 	beq.w	8003ca8 <simpleserial_put+0x154>
{
 8003b5a:	b570      	push	{r4, r5, r6, lr}
 8003b5c:	b0c0      	sub	sp, #256	; 0x100
	data_buf[0] = 0x00;
 8003b5e:	2500      	movs	r5, #0
 8003b60:	460c      	mov	r4, r1
 8003b62:	f88d 5000 	strb.w	r5, [sp]
	data_buf[1] = c;
 8003b66:	f88d 0001 	strb.w	r0, [sp, #1]
	data_buf[2] = size;
 8003b6a:	f88d 1002 	strb.w	r1, [sp, #2]
	for (; i < size; i++) {
 8003b6e:	2900      	cmp	r1, #0
 8003b70:	f000 809b 	beq.w	8003caa <simpleserial_put+0x156>
 8003b74:	4611      	mov	r1, r2
		data_buf[i + 3] = output[i];
 8003b76:	f10d 0003 	add.w	r0, sp, #3
 8003b7a:	4622      	mov	r2, r4
 8003b7c:	f7fc fe58 	bl	8000830 <memcpy>
	stuff_data(data_buf, i + 5);
 8003b80:	1d61      	adds	r1, r4, #5
	while (len--) {
 8003b82:	1c63      	adds	r3, r4, #1
 8003b84:	2cfe      	cmp	r4, #254	; 0xfe
	data_buf[i + 3] = ss_crc(data_buf+1, size+2);
 8003b86:	f104 0e03 	add.w	lr, r4, #3
	data_buf[i + 4] = 0x00;
 8003b8a:	f104 0c04 	add.w	ip, r4, #4
	stuff_data(data_buf, i + 5);
 8003b8e:	b2c9      	uxtb	r1, r1
	while (len--) {
 8003b90:	b2db      	uxtb	r3, r3
 8003b92:	f000 8091 	beq.w	8003cb8 <simpleserial_put+0x164>
 8003b96:	3302      	adds	r3, #2
 8003b98:	eb0d 0203 	add.w	r2, sp, r3
	uint8_t crc = 0x00;
 8003b9c:	f10d 0001 	add.w	r0, sp, #1
 8003ba0:	2300      	movs	r3, #0
 8003ba2:	e027      	b.n	8003bf4 <simpleserial_put+0xa0>
			crc = crc & 0x80 ? (crc << 1) ^ CW_CRC: crc << 1;
 8003ba4:	b2dd      	uxtb	r5, r3
 8003ba6:	b25b      	sxtb	r3, r3
 8003ba8:	2b00      	cmp	r3, #0
 8003baa:	db31      	blt.n	8003c10 <simpleserial_put+0xbc>
 8003bac:	006b      	lsls	r3, r5, #1
 8003bae:	b2dd      	uxtb	r5, r3
 8003bb0:	b25b      	sxtb	r3, r3
 8003bb2:	2b00      	cmp	r3, #0
 8003bb4:	db33      	blt.n	8003c1e <simpleserial_put+0xca>
 8003bb6:	006d      	lsls	r5, r5, #1
 8003bb8:	b2eb      	uxtb	r3, r5
 8003bba:	b26d      	sxtb	r5, r5
 8003bbc:	2d00      	cmp	r5, #0
 8003bbe:	db35      	blt.n	8003c2c <simpleserial_put+0xd8>
 8003bc0:	005d      	lsls	r5, r3, #1
 8003bc2:	b2eb      	uxtb	r3, r5
 8003bc4:	b26d      	sxtb	r5, r5
 8003bc6:	2d00      	cmp	r5, #0
 8003bc8:	db37      	blt.n	8003c3a <simpleserial_put+0xe6>
 8003bca:	005d      	lsls	r5, r3, #1
 8003bcc:	b2eb      	uxtb	r3, r5
 8003bce:	b26d      	sxtb	r5, r5
 8003bd0:	2d00      	cmp	r5, #0
 8003bd2:	db39      	blt.n	8003c48 <simpleserial_put+0xf4>
 8003bd4:	005d      	lsls	r5, r3, #1
 8003bd6:	b2eb      	uxtb	r3, r5
 8003bd8:	b26d      	sxtb	r5, r5
 8003bda:	2d00      	cmp	r5, #0
 8003bdc:	db3b      	blt.n	8003c56 <simpleserial_put+0x102>
 8003bde:	005d      	lsls	r5, r3, #1
 8003be0:	b2eb      	uxtb	r3, r5
 8003be2:	b26d      	sxtb	r5, r5
 8003be4:	005b      	lsls	r3, r3, #1
 8003be6:	2d00      	cmp	r5, #0
 8003be8:	bfb8      	it	lt
 8003bea:	f083 034d 	eorlt.w	r3, r3, #77	; 0x4d
	while (len--) {
 8003bee:	4290      	cmp	r0, r2
			crc = crc & 0x80 ? (crc << 1) ^ CW_CRC: crc << 1;
 8003bf0:	b2db      	uxtb	r3, r3
	while (len--) {
 8003bf2:	d036      	beq.n	8003c62 <simpleserial_put+0x10e>
		crc ^= *buf++;
 8003bf4:	f810 5b01 	ldrb.w	r5, [r0], #1
 8003bf8:	406b      	eors	r3, r5
			crc = crc & 0x80 ? (crc << 1) ^ CW_CRC: crc << 1;
 8003bfa:	f013 0f80 	tst.w	r3, #128	; 0x80
 8003bfe:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8003c02:	d0cf      	beq.n	8003ba4 <simpleserial_put+0x50>
 8003c04:	f083 054d 	eor.w	r5, r3, #77	; 0x4d
 8003c08:	b26b      	sxtb	r3, r5
 8003c0a:	2b00      	cmp	r3, #0
 8003c0c:	b2ed      	uxtb	r5, r5
 8003c0e:	dacd      	bge.n	8003bac <simpleserial_put+0x58>
 8003c10:	006d      	lsls	r5, r5, #1
 8003c12:	f085 054d 	eor.w	r5, r5, #77	; 0x4d
 8003c16:	b26b      	sxtb	r3, r5
 8003c18:	2b00      	cmp	r3, #0
 8003c1a:	b2ed      	uxtb	r5, r5
 8003c1c:	dacb      	bge.n	8003bb6 <simpleserial_put+0x62>
 8003c1e:	006b      	lsls	r3, r5, #1
 8003c20:	f083 034d 	eor.w	r3, r3, #77	; 0x4d
 8003c24:	b25d      	sxtb	r5, r3
 8003c26:	2d00      	cmp	r5, #0
 8003c28:	b2db      	uxtb	r3, r3
 8003c2a:	dac9      	bge.n	8003bc0 <simpleserial_put+0x6c>
 8003c2c:	005b      	lsls	r3, r3, #1
 8003c2e:	f083 034d 	eor.w	r3, r3, #77	; 0x4d
 8003c32:	b25d      	sxtb	r5, r3
 8003c34:	2d00      	cmp	r5, #0
 8003c36:	b2db      	uxtb	r3, r3
 8003c38:	dac7      	bge.n	8003bca <simpleserial_put+0x76>
 8003c3a:	005b      	lsls	r3, r3, #1
 8003c3c:	f083 034d 	eor.w	r3, r3, #77	; 0x4d
 8003c40:	b25d      	sxtb	r5, r3
 8003c42:	2d00      	cmp	r5, #0
 8003c44:	b2db      	uxtb	r3, r3
 8003c46:	dac5      	bge.n	8003bd4 <simpleserial_put+0x80>
 8003c48:	005b      	lsls	r3, r3, #1
 8003c4a:	f083 034d 	eor.w	r3, r3, #77	; 0x4d
 8003c4e:	b25d      	sxtb	r5, r3
 8003c50:	2d00      	cmp	r5, #0
 8003c52:	b2db      	uxtb	r3, r3
 8003c54:	dac3      	bge.n	8003bde <simpleserial_put+0x8a>
 8003c56:	005b      	lsls	r3, r3, #1
 8003c58:	f083 034d 	eor.w	r3, r3, #77	; 0x4d
 8003c5c:	b25d      	sxtb	r5, r3
 8003c5e:	b2db      	uxtb	r3, r3
 8003c60:	e7c0      	b.n	8003be4 <simpleserial_put+0x90>
	data_buf[i + 3] = ss_crc(data_buf+1, size+2);
 8003c62:	f80d 300e 	strb.w	r3, [sp, lr]
	for (; i < len; i++) {
 8003c66:	2901      	cmp	r1, #1
	data_buf[i + 4] = 0x00;
 8003c68:	f04f 0300 	mov.w	r3, #0
 8003c6c:	f80d 300c 	strb.w	r3, [sp, ip]
	for (; i < len; i++) {
 8003c70:	d90e      	bls.n	8003c90 <simpleserial_put+0x13c>
 8003c72:	466a      	mov	r2, sp
	uint8_t last = 0;
 8003c74:	2000      	movs	r0, #0
	uint8_t i = 1;
 8003c76:	2301      	movs	r3, #1
		if (buf[i] == FRAME_BYTE) {
 8003c78:	f812 6f01 	ldrb.w	r6, [r2, #1]!
	for (; i < len; i++) {
 8003c7c:	1c5d      	adds	r5, r3, #1
			buf[last] = i - last;
 8003c7e:	eba3 0c00 	sub.w	ip, r3, r0
		if (buf[i] == FRAME_BYTE) {
 8003c82:	b916      	cbnz	r6, 8003c8a <simpleserial_put+0x136>
			buf[last] = i - last;
 8003c84:	f80d c000 	strb.w	ip, [sp, r0]
 8003c88:	4618      	mov	r0, r3
	for (; i < len; i++) {
 8003c8a:	b2eb      	uxtb	r3, r5
 8003c8c:	428b      	cmp	r3, r1
 8003c8e:	d1f3      	bne.n	8003c78 <simpleserial_put+0x124>
	for (int i = 0; i < size + 5; i++) {
 8003c90:	f10d 0305 	add.w	r3, sp, #5
 8003c94:	466d      	mov	r5, sp
 8003c96:	441c      	add	r4, r3
		putch(data_buf[i]);
 8003c98:	f815 0b01 	ldrb.w	r0, [r5], #1
 8003c9c:	f000 f8f8 	bl	8003e90 <putch>
	for (int i = 0; i < size + 5; i++) {
 8003ca0:	42ac      	cmp	r4, r5
 8003ca2:	d1f9      	bne.n	8003c98 <simpleserial_put+0x144>
}
 8003ca4:	b040      	add	sp, #256	; 0x100
 8003ca6:	bd70      	pop	{r4, r5, r6, pc}
 8003ca8:	4770      	bx	lr
	while (len--) {
 8003caa:	2301      	movs	r3, #1
 8003cac:	f04f 0c04 	mov.w	ip, #4
 8003cb0:	2105      	movs	r1, #5
 8003cb2:	f04f 0e03 	mov.w	lr, #3
 8003cb6:	e76e      	b.n	8003b96 <simpleserial_put+0x42>
	data_buf[i + 3] = ss_crc(data_buf+1, size+2);
 8003cb8:	f80d 500e 	strb.w	r5, [sp, lr]
	data_buf[i + 4] = 0x00;
 8003cbc:	2103      	movs	r1, #3
 8003cbe:	f80d 500c 	strb.w	r5, [sp, ip]
	for (; i < len; i++) {
 8003cc2:	e7d6      	b.n	8003c72 <simpleserial_put+0x11e>

08003cc4 <ss_get_commands>:
{
 8003cc4:	b510      	push	{r4, lr}
    for (uint8_t i = 0; i < (num_commands & 0xFF); i++) {
 8003cc6:	4c0d      	ldr	r4, [pc, #52]	; (8003cfc <ss_get_commands+0x38>)
 8003cc8:	7821      	ldrb	r1, [r4, #0]
{
 8003cca:	b084      	sub	sp, #16
    for (uint8_t i = 0; i < (num_commands & 0xFF); i++) {
 8003ccc:	b179      	cbz	r1, 8003cee <ss_get_commands+0x2a>
 8003cce:	2300      	movs	r3, #0
 8003cd0:	461a      	mov	r2, r3
        cmd_chars[i] = commands[i].c;
 8003cd2:	eb02 0042 	add.w	r0, r2, r2, lsl #1
 8003cd6:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 8003cda:	3210      	adds	r2, #16
    for (uint8_t i = 0; i < (num_commands & 0xFF); i++) {
 8003cdc:	3301      	adds	r3, #1
        cmd_chars[i] = commands[i].c;
 8003cde:	446a      	add	r2, sp
    for (uint8_t i = 0; i < (num_commands & 0xFF); i++) {
 8003ce0:	b2db      	uxtb	r3, r3
        cmd_chars[i] = commands[i].c;
 8003ce2:	7900      	ldrb	r0, [r0, #4]
 8003ce4:	f802 0c10 	strb.w	r0, [r2, #-16]
    for (uint8_t i = 0; i < (num_commands & 0xFF); i++) {
 8003ce8:	428b      	cmp	r3, r1
 8003cea:	461a      	mov	r2, r3
 8003cec:	dbf1      	blt.n	8003cd2 <ss_get_commands+0xe>
    simpleserial_put('r', num_commands & 0xFF, (void *)cmd_chars);
 8003cee:	2072      	movs	r0, #114	; 0x72
 8003cf0:	466a      	mov	r2, sp
 8003cf2:	f7ff ff2f 	bl	8003b54 <simpleserial_put>
}
 8003cf6:	2000      	movs	r0, #0
 8003cf8:	b004      	add	sp, #16
 8003cfa:	bd10      	pop	{r4, pc}
 8003cfc:	2000177c 	.word	0x2000177c

08003d00 <platform_init>:

uint8_t hw_key[16];
static CRYP_HandleTypeDef cryp;

void platform_init(void)
{
 8003d00:	b530      	push	{r4, r5, lr}
 8003d02:	b095      	sub	sp, #84	; 0x54
	HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_ACR_LATENCY_5WS);
    FLASH->ACR |= 0b111 << 8; //enable ART acceleration

#else
	RCC_OscInitTypeDef RCC_OscInitStruct;
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI;
 8003d04:	2403      	movs	r4, #3
	RCC_OscInitStruct.HSEState       = RCC_HSE_BYPASS;
	RCC_OscInitStruct.HSIState       = RCC_HSI_ON;  // HSI is needed for the RNG
 8003d06:	2201      	movs	r2, #1
	RCC_OscInitStruct.PLL.PLLState   = RCC_PLL_ON;  // we need PLL to use RNG
 8003d08:	2002      	movs	r0, #2
	RCC_OscInitStruct.PLL.PLLSource  = RCC_PLLSOURCE_HSE;
 8003d0a:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI;
 8003d0e:	f44f 25a0 	mov.w	r5, #327680	; 0x50000
	RCC_OscInitStruct.PLL.PLLSource  = RCC_PLLSOURCE_HSE;
 8003d12:	e9cd 030e 	strd	r0, r3, [sp, #56]	; 0x38
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI;
 8003d16:	e9cd 4508 	strd	r4, r5, [sp, #32]
	RCC_OscInitStruct.HSIState       = RCC_HSI_ON;  // HSI is needed for the RNG
 8003d1a:	920b      	str	r2, [sp, #44]	; 0x2c
	RCC_OscInitStruct.PLL.PLLM       = 12;  // Internal clock is 16MHz
 8003d1c:	240c      	movs	r4, #12
	RCC_OscInitStruct.PLL.PLLN       = 196;
 8003d1e:	21c4      	movs	r1, #196	; 0xc4
	RCC_OscInitStruct.PLL.PLLP       = RCC_PLLP_DIV4;
 8003d20:	2204      	movs	r2, #4
	RCC_OscInitStruct.PLL.PLLQ       = 7;  // divisor for RNG, USB and SDIO
 8003d22:	2307      	movs	r3, #7
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {
 8003d24:	a808      	add	r0, sp, #32
	RCC_OscInitStruct.PLL.PLLN       = 196;
 8003d26:	e9cd 4110 	strd	r4, r1, [sp, #64]	; 0x40
	RCC_OscInitStruct.PLL.PLLQ       = 7;  // divisor for RNG, USB and SDIO
 8003d2a:	e9cd 2312 	strd	r2, r3, [sp, #72]	; 0x48
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {
 8003d2e:	f000 f8c1 	bl	8003eb4 <HAL_RCC_OscConfig>
 8003d32:	b100      	cbz	r0, 8003d36 <platform_init+0x36>
        for(;;);
 8003d34:	e7fe      	b.n	8003d34 <platform_init+0x34>

	RCC_ClkInitTypeDef RCC_ClkInitStruct;
	RCC_ClkInitStruct.ClockType      = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
	RCC_ClkInitStruct.SYSCLKSource   = RCC_SYSCLKSOURCE_HSE;
	RCC_ClkInitStruct.AHBCLKDivider  = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 8003d36:	4604      	mov	r4, r0
	RCC_ClkInitStruct.ClockType      = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
 8003d38:	2101      	movs	r1, #1
 8003d3a:	200f      	movs	r0, #15
 8003d3c:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8003d40:	2200      	movs	r2, #0
 8003d42:	2300      	movs	r3, #0
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
	HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_ACR_LATENCY_0WS); //wait states not needed for HSE
 8003d44:	4621      	mov	r1, r4
 8003d46:	a802      	add	r0, sp, #8
	RCC_ClkInitStruct.ClockType      = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
 8003d48:	e9cd 2304 	strd	r2, r3, [sp, #16]
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8003d4c:	9406      	str	r4, [sp, #24]
	HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_ACR_LATENCY_0WS); //wait states not needed for HSE
 8003d4e:	f000 fac9 	bl	80042e4 <HAL_RCC_ClockConfig>
#endif

	// Configure and starts the RNG
	__HAL_RCC_RNG_CLK_ENABLE();
 8003d52:	4b09      	ldr	r3, [pc, #36]	; (8003d78 <platform_init+0x78>)
 8003d54:	9401      	str	r4, [sp, #4]
 8003d56:	6b5a      	ldr	r2, [r3, #52]	; 0x34
	RngHandle.Instance = RNG;
 8003d58:	4808      	ldr	r0, [pc, #32]	; (8003d7c <platform_init+0x7c>)
	__HAL_RCC_RNG_CLK_ENABLE();
 8003d5a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8003d5e:	635a      	str	r2, [r3, #52]	; 0x34
 8003d60:	6b5b      	ldr	r3, [r3, #52]	; 0x34
	RngHandle.Instance = RNG;
 8003d62:	4a07      	ldr	r2, [pc, #28]	; (8003d80 <platform_init+0x80>)
 8003d64:	6002      	str	r2, [r0, #0]
	__HAL_RCC_RNG_CLK_ENABLE();
 8003d66:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8003d6a:	9301      	str	r3, [sp, #4]
 8003d6c:	9b01      	ldr	r3, [sp, #4]
	RngHandle.State = HAL_RNG_STATE_RESET;
 8003d6e:	7144      	strb	r4, [r0, #5]
	HAL_RNG_Init(&RngHandle);
 8003d70:	f000 fe0e 	bl	8004990 <HAL_RNG_Init>

}
 8003d74:	b015      	add	sp, #84	; 0x54
 8003d76:	bd30      	pop	{r4, r5, pc}
 8003d78:	40023800 	.word	0x40023800
 8003d7c:	20001840 	.word	0x20001840
 8003d80:	50060800 	.word	0x50060800

08003d84 <init_uart>:

void init_uart(void)
{
 8003d84:	b530      	push	{r4, r5, lr}
	GPIO_InitTypeDef GpioInit;
	GpioInit.Pin       = GPIO_PIN_9 | GPIO_PIN_10;
 8003d86:	2201      	movs	r2, #1
{
 8003d88:	b089      	sub	sp, #36	; 0x24
	GpioInit.Pin       = GPIO_PIN_9 | GPIO_PIN_10;
 8003d8a:	f44f 60c0 	mov.w	r0, #1536	; 0x600
 8003d8e:	2102      	movs	r1, #2
 8003d90:	2302      	movs	r3, #2
 8003d92:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8003d96:	e9cd 2304 	strd	r2, r3, [sp, #16]
	GpioInit.Mode      = GPIO_MODE_AF_PP;
	GpioInit.Pull      = GPIO_PULLUP;
	GpioInit.Speed     = GPIO_SPEED_FREQ_HIGH;
	GpioInit.Alternate = GPIO_AF7_USART1;
	__GPIOA_CLK_ENABLE();
 8003d9a:	4d17      	ldr	r5, [pc, #92]	; (8003df8 <init_uart+0x74>)
	HAL_GPIO_Init(GPIOA, &GpioInit);
 8003d9c:	4817      	ldr	r0, [pc, #92]	; (8003dfc <init_uart+0x78>)
	__GPIOA_CLK_ENABLE();
 8003d9e:	2400      	movs	r4, #0
	GpioInit.Alternate = GPIO_AF7_USART1;
 8003da0:	2307      	movs	r3, #7
	__GPIOA_CLK_ENABLE();
 8003da2:	9400      	str	r4, [sp, #0]
	GpioInit.Alternate = GPIO_AF7_USART1;
 8003da4:	9306      	str	r3, [sp, #24]
	__GPIOA_CLK_ENABLE();
 8003da6:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8003da8:	f043 0301 	orr.w	r3, r3, #1
 8003dac:	632b      	str	r3, [r5, #48]	; 0x30
 8003dae:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8003db0:	f003 0301 	and.w	r3, r3, #1
	HAL_GPIO_Init(GPIOA, &GpioInit);
 8003db4:	a902      	add	r1, sp, #8
	__GPIOA_CLK_ENABLE();
 8003db6:	9300      	str	r3, [sp, #0]
 8003db8:	9b00      	ldr	r3, [sp, #0]
	HAL_GPIO_Init(GPIOA, &GpioInit);
 8003dba:	f000 fb61 	bl	8004480 <HAL_GPIO_Init>
	UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
	UartHandle.Init.StopBits   = UART_STOPBITS_1;
	UartHandle.Init.Parity     = UART_PARITY_NONE;
	UartHandle.Init.HwFlowCtl  = UART_HWCONTROL_NONE;
	UartHandle.Init.Mode       = UART_MODE_TX_RX;
	__USART1_CLK_ENABLE();
 8003dbe:	9401      	str	r4, [sp, #4]
 8003dc0:	6c6a      	ldr	r2, [r5, #68]	; 0x44
	UartHandle.Instance        = USART1;
 8003dc2:	4b0f      	ldr	r3, [pc, #60]	; (8003e00 <init_uart+0x7c>)
	__USART1_CLK_ENABLE();
 8003dc4:	f042 0210 	orr.w	r2, r2, #16
 8003dc8:	646a      	str	r2, [r5, #68]	; 0x44
 8003dca:	6c6a      	ldr	r2, [r5, #68]	; 0x44
	UartHandle.Init.Parity     = UART_PARITY_NONE;
 8003dcc:	61dc      	str	r4, [r3, #28]
	__USART1_CLK_ENABLE();
 8003dce:	f002 0210 	and.w	r2, r2, #16
 8003dd2:	9201      	str	r2, [sp, #4]
 8003dd4:	9a01      	ldr	r2, [sp, #4]
  UartHandle.Init.BaudRate   = 230400;
 8003dd6:	f44f 3161 	mov.w	r1, #230400	; 0x38400
	UartHandle.Init.Mode       = UART_MODE_TX_RX;
 8003dda:	220c      	movs	r2, #12
	UartHandle.Instance        = USART1;
 8003ddc:	f5a5 3594 	sub.w	r5, r5, #75776	; 0x12800
	HAL_UART_Init(&UartHandle);
 8003de0:	f103 000c 	add.w	r0, r3, #12
  UartHandle.Init.BaudRate   = 230400;
 8003de4:	e9c3 5103 	strd	r5, r1, [r3, #12]
	UartHandle.Init.StopBits   = UART_STOPBITS_1;
 8003de8:	e9c3 4405 	strd	r4, r4, [r3, #20]
	UartHandle.Init.Mode       = UART_MODE_TX_RX;
 8003dec:	e9c3 2408 	strd	r2, r4, [r3, #32]
	HAL_UART_Init(&UartHandle);
 8003df0:	f000 fc7c 	bl	80046ec <HAL_UART_Init>
}
 8003df4:	b009      	add	sp, #36	; 0x24
 8003df6:	bd30      	pop	{r4, r5, pc}
 8003df8:	40023800 	.word	0x40023800
 8003dfc:	40020000 	.word	0x40020000
 8003e00:	20001840 	.word	0x20001840

08003e04 <trigger_setup>:

//#define STM32F4_WLCSP

void trigger_setup(void)
{
 8003e04:	b530      	push	{r4, r5, lr}
 8003e06:	b089      	sub	sp, #36	; 0x24
	__GPIOA_CLK_ENABLE();
 8003e08:	4b0d      	ldr	r3, [pc, #52]	; (8003e40 <trigger_setup+0x3c>)
	GPIO_InitTypeDef GpioInit;
	GpioInit.Pin       = GPIO_PIN_12;
	GpioInit.Mode      = GPIO_MODE_OUTPUT_PP;
	GpioInit.Pull      = GPIO_NOPULL;
	GpioInit.Speed     = GPIO_SPEED_FREQ_HIGH;
	HAL_GPIO_Init(GPIOA, &GpioInit);
 8003e0a:	480e      	ldr	r0, [pc, #56]	; (8003e44 <trigger_setup+0x40>)
	__GPIOA_CLK_ENABLE();
 8003e0c:	2200      	movs	r2, #0
 8003e0e:	9201      	str	r2, [sp, #4]
 8003e10:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8003e12:	f042 0201 	orr.w	r2, r2, #1
 8003e16:	631a      	str	r2, [r3, #48]	; 0x30
 8003e18:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8003e1a:	f003 0301 	and.w	r3, r3, #1
 8003e1e:	9301      	str	r3, [sp, #4]
	GpioInit.Pin       = GPIO_PIN_12;
 8003e20:	2200      	movs	r2, #0
 8003e22:	f44f 5480 	mov.w	r4, #4096	; 0x1000
 8003e26:	2501      	movs	r5, #1
 8003e28:	2302      	movs	r3, #2
	HAL_GPIO_Init(GPIOA, &GpioInit);
 8003e2a:	a902      	add	r1, sp, #8
	GpioInit.Pin       = GPIO_PIN_12;
 8003e2c:	e9cd 2304 	strd	r2, r3, [sp, #16]
 8003e30:	e9cd 4502 	strd	r4, r5, [sp, #8]
	__GPIOA_CLK_ENABLE();
 8003e34:	9b01      	ldr	r3, [sp, #4]
	HAL_GPIO_Init(GPIOA, &GpioInit);
 8003e36:	f000 fb23 	bl	8004480 <HAL_GPIO_Init>
#endif
}
 8003e3a:	b009      	add	sp, #36	; 0x24
 8003e3c:	bd30      	pop	{r4, r5, pc}
 8003e3e:	bf00      	nop
 8003e40:	40023800 	.word	0x40023800
 8003e44:	40020000 	.word	0x40020000

08003e48 <trigger_high>:
void trigger_high(void)
{
#ifdef STM32F4_WLCSP
    HAL_GPIO_WritePin(GPIOD, GPIO_PIN_4, SET);
#else
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_12, SET);
 8003e48:	4802      	ldr	r0, [pc, #8]	; (8003e54 <trigger_high+0xc>)
 8003e4a:	2201      	movs	r2, #1
 8003e4c:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8003e50:	f000 bc48 	b.w	80046e4 <HAL_GPIO_WritePin>
 8003e54:	40020000 	.word	0x40020000

08003e58 <trigger_low>:
void trigger_low(void)
{
#ifdef STM32F4_WLCSP
    HAL_GPIO_WritePin(GPIOD, GPIO_PIN_4, RESET);
#else
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_12, RESET);
 8003e58:	4802      	ldr	r0, [pc, #8]	; (8003e64 <trigger_low+0xc>)
 8003e5a:	2200      	movs	r2, #0
 8003e5c:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8003e60:	f000 bc40 	b.w	80046e4 <HAL_GPIO_WritePin>
 8003e64:	40020000 	.word	0x40020000

08003e68 <getch>:
#endif
}
char getch(void)
{
 8003e68:	b510      	push	{r4, lr}
	uint8_t d;
	while (HAL_UART_Receive(&UartHandle, &d, 1, 5000) != HAL_OK);
 8003e6a:	4c08      	ldr	r4, [pc, #32]	; (8003e8c <getch+0x24>)
{
 8003e6c:	b082      	sub	sp, #8
	while (HAL_UART_Receive(&UartHandle, &d, 1, 5000) != HAL_OK);
 8003e6e:	f241 3388 	movw	r3, #5000	; 0x1388
 8003e72:	2201      	movs	r2, #1
 8003e74:	f10d 0107 	add.w	r1, sp, #7
 8003e78:	4620      	mov	r0, r4
 8003e7a:	f000 fd03 	bl	8004884 <HAL_UART_Receive>
 8003e7e:	2800      	cmp	r0, #0
 8003e80:	d1f5      	bne.n	8003e6e <getch+0x6>
	return d;
}
 8003e82:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8003e86:	b002      	add	sp, #8
 8003e88:	bd10      	pop	{r4, pc}
 8003e8a:	bf00      	nop
 8003e8c:	2000184c 	.word	0x2000184c

08003e90 <putch>:

void putch(char c)
{
 8003e90:	b500      	push	{lr}
 8003e92:	b083      	sub	sp, #12
 8003e94:	4684      	mov	ip, r0
	uint8_t d  = c;
	HAL_UART_Transmit(&UartHandle,  &d, 1, 5000);
 8003e96:	f241 3388 	movw	r3, #5000	; 0x1388
 8003e9a:	2201      	movs	r2, #1
 8003e9c:	f10d 0107 	add.w	r1, sp, #7
 8003ea0:	4803      	ldr	r0, [pc, #12]	; (8003eb0 <putch+0x20>)
	uint8_t d  = c;
 8003ea2:	f88d c007 	strb.w	ip, [sp, #7]
	HAL_UART_Transmit(&UartHandle,  &d, 1, 5000);
 8003ea6:	f000 fc9f 	bl	80047e8 <HAL_UART_Transmit>
}
 8003eaa:	b003      	add	sp, #12
 8003eac:	f85d fb04 	ldr.w	pc, [sp], #4
 8003eb0:	2000184c 	.word	0x2000184c

08003eb4 <HAL_RCC_OscConfig>:
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8003eb4:	b4f0      	push	{r4, r5, r6, r7}
  uint32_t tickstart = 0U;

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8003eb6:	6801      	ldr	r1, [r0, #0]
 8003eb8:	07cf      	lsls	r7, r1, #31
{
 8003eba:	b082      	sub	sp, #8
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8003ebc:	d532      	bpl.n	8003f24 <HAL_RCC_OscConfig+0x70>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8003ebe:	4a94      	ldr	r2, [pc, #592]	; (8004110 <HAL_RCC_OscConfig+0x25c>)
 8003ec0:	6893      	ldr	r3, [r2, #8]
 8003ec2:	f003 030c 	and.w	r3, r3, #12
 8003ec6:	2b04      	cmp	r3, #4
 8003ec8:	f000 8108 	beq.w	80040dc <HAL_RCC_OscConfig+0x228>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8003ecc:	6893      	ldr	r3, [r2, #8]
 8003ece:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8003ed2:	2b08      	cmp	r3, #8
 8003ed4:	f000 80fe 	beq.w	80040d4 <HAL_RCC_OscConfig+0x220>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8003ed8:	6845      	ldr	r5, [r0, #4]
 8003eda:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
 8003ede:	f000 8132 	beq.w	8004146 <HAL_RCC_OscConfig+0x292>
 8003ee2:	f5b5 2fa0 	cmp.w	r5, #327680	; 0x50000
 8003ee6:	f000 8187 	beq.w	80041f8 <HAL_RCC_OscConfig+0x344>
 8003eea:	4e89      	ldr	r6, [pc, #548]	; (8004110 <HAL_RCC_OscConfig+0x25c>)
 8003eec:	6833      	ldr	r3, [r6, #0]
 8003eee:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8003ef2:	6033      	str	r3, [r6, #0]
 8003ef4:	6833      	ldr	r3, [r6, #0]
 8003ef6:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8003efa:	6033      	str	r3, [r6, #0]

      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 8003efc:	2d00      	cmp	r5, #0
 8003efe:	f040 8127 	bne.w	8004150 <HAL_RCC_OscConfig+0x29c>
	return tick++;;
 8003f02:	4b84      	ldr	r3, [pc, #528]	; (8004114 <HAL_RCC_OscConfig+0x260>)
 8003f04:	4f84      	ldr	r7, [pc, #528]	; (8004118 <HAL_RCC_OscConfig+0x264>)
 8003f06:	681a      	ldr	r2, [r3, #0]
 8003f08:	4417      	add	r7, r2
 8003f0a:	3201      	adds	r2, #1
 8003f0c:	601a      	str	r2, [r3, #0]
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8003f0e:	e004      	b.n	8003f1a <HAL_RCC_OscConfig+0x66>
	return tick++;;
 8003f10:	3201      	adds	r2, #1
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8003f12:	42ba      	cmp	r2, r7
 8003f14:	f04f 0501 	mov.w	r5, #1
 8003f18:	d055      	beq.n	8003fc6 <HAL_RCC_OscConfig+0x112>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8003f1a:	6834      	ldr	r4, [r6, #0]
 8003f1c:	03a4      	lsls	r4, r4, #14
 8003f1e:	d4f7      	bmi.n	8003f10 <HAL_RCC_OscConfig+0x5c>
 8003f20:	b105      	cbz	r5, 8003f24 <HAL_RCC_OscConfig+0x70>
 8003f22:	601a      	str	r2, [r3, #0]
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8003f24:	078a      	lsls	r2, r1, #30
 8003f26:	d533      	bpl.n	8003f90 <HAL_RCC_OscConfig+0xdc>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8003f28:	4b79      	ldr	r3, [pc, #484]	; (8004110 <HAL_RCC_OscConfig+0x25c>)
 8003f2a:	689a      	ldr	r2, [r3, #8]
 8003f2c:	f012 0f0c 	tst.w	r2, #12
 8003f30:	f000 80e2 	beq.w	80040f8 <HAL_RCC_OscConfig+0x244>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8003f34:	689a      	ldr	r2, [r3, #8]
 8003f36:	f002 020c 	and.w	r2, r2, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8003f3a:	2a08      	cmp	r2, #8
 8003f3c:	f000 80d8 	beq.w	80040f0 <HAL_RCC_OscConfig+0x23c>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8003f40:	68c2      	ldr	r2, [r0, #12]
 8003f42:	2a00      	cmp	r2, #0
 8003f44:	f000 8140 	beq.w	80041c8 <HAL_RCC_OscConfig+0x314>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8003f48:	4a74      	ldr	r2, [pc, #464]	; (800411c <HAL_RCC_OscConfig+0x268>)
	return tick++;;
 8003f4a:	4b72      	ldr	r3, [pc, #456]	; (8004114 <HAL_RCC_OscConfig+0x260>)
        __HAL_RCC_HSI_ENABLE();
 8003f4c:	2101      	movs	r1, #1
 8003f4e:	6011      	str	r1, [r2, #0]
	return tick++;;
 8003f50:	681a      	ldr	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8003f52:	496f      	ldr	r1, [pc, #444]	; (8004110 <HAL_RCC_OscConfig+0x25c>)
	return tick++;;
 8003f54:	1c54      	adds	r4, r2, #1
 8003f56:	601c      	str	r4, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8003f58:	680c      	ldr	r4, [r1, #0]
 8003f5a:	07a6      	lsls	r6, r4, #30
 8003f5c:	d40a      	bmi.n	8003f74 <HAL_RCC_OscConfig+0xc0>
 8003f5e:	680d      	ldr	r5, [r1, #0]
 8003f60:	07ad      	lsls	r5, r5, #30
	return tick++;;
 8003f62:	f102 0402 	add.w	r4, r2, #2
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8003f66:	d404      	bmi.n	8003f72 <HAL_RCC_OscConfig+0xbe>
 8003f68:	6809      	ldr	r1, [r1, #0]
 8003f6a:	078f      	lsls	r7, r1, #30
	return tick++;;
 8003f6c:	f102 0403 	add.w	r4, r2, #3
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8003f70:	d528      	bpl.n	8003fc4 <HAL_RCC_OscConfig+0x110>
 8003f72:	601c      	str	r4, [r3, #0]
            return HAL_TIMEOUT;
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8003f74:	4c66      	ldr	r4, [pc, #408]	; (8004110 <HAL_RCC_OscConfig+0x25c>)
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8003f76:	22f8      	movs	r2, #248	; 0xf8
 8003f78:	6821      	ldr	r1, [r4, #0]
 8003f7a:	fa92 f2a2 	rbit	r2, r2
 8003f7e:	6903      	ldr	r3, [r0, #16]
 8003f80:	fab2 f282 	clz	r2, r2
 8003f84:	4093      	lsls	r3, r2
 8003f86:	f021 02f8 	bic.w	r2, r1, #248	; 0xf8
 8003f8a:	4313      	orrs	r3, r2
 8003f8c:	6023      	str	r3, [r4, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8003f8e:	6801      	ldr	r1, [r0, #0]
 8003f90:	070f      	lsls	r7, r1, #28
 8003f92:	d536      	bpl.n	8004002 <HAL_RCC_OscConfig+0x14e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 8003f94:	6942      	ldr	r2, [r0, #20]
 8003f96:	b9da      	cbnz	r2, 8003fd0 <HAL_RCC_OscConfig+0x11c>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8003f98:	4960      	ldr	r1, [pc, #384]	; (800411c <HAL_RCC_OscConfig+0x268>)
	return tick++;;
 8003f9a:	4b5e      	ldr	r3, [pc, #376]	; (8004114 <HAL_RCC_OscConfig+0x260>)
      __HAL_RCC_LSI_DISABLE();
 8003f9c:	f8c1 2e80 	str.w	r2, [r1, #3712]	; 0xe80
	return tick++;;
 8003fa0:	681a      	ldr	r2, [r3, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8003fa2:	495b      	ldr	r1, [pc, #364]	; (8004110 <HAL_RCC_OscConfig+0x25c>)
	return tick++;;
 8003fa4:	1c54      	adds	r4, r2, #1
 8003fa6:	601c      	str	r4, [r3, #0]
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8003fa8:	6f4c      	ldr	r4, [r1, #116]	; 0x74
 8003faa:	07a6      	lsls	r6, r4, #30
 8003fac:	f140 812e 	bpl.w	800420c <HAL_RCC_OscConfig+0x358>
 8003fb0:	6f4d      	ldr	r5, [r1, #116]	; 0x74
 8003fb2:	07ad      	lsls	r5, r5, #30
	return tick++;;
 8003fb4:	f102 0402 	add.w	r4, r2, #2
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8003fb8:	d521      	bpl.n	8003ffe <HAL_RCC_OscConfig+0x14a>
 8003fba:	6f49      	ldr	r1, [r1, #116]	; 0x74
 8003fbc:	0789      	lsls	r1, r1, #30
	return tick++;;
 8003fbe:	f102 0403 	add.w	r4, r2, #3
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8003fc2:	d51c      	bpl.n	8003ffe <HAL_RCC_OscConfig+0x14a>
	return tick++;;
 8003fc4:	3204      	adds	r2, #4
            return HAL_TIMEOUT;
 8003fc6:	2003      	movs	r0, #3
 8003fc8:	601a      	str	r2, [r3, #0]
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
}
 8003fca:	b002      	add	sp, #8
 8003fcc:	bcf0      	pop	{r4, r5, r6, r7}
 8003fce:	4770      	bx	lr
      __HAL_RCC_LSI_ENABLE();
 8003fd0:	4a52      	ldr	r2, [pc, #328]	; (800411c <HAL_RCC_OscConfig+0x268>)
	return tick++;;
 8003fd2:	4b50      	ldr	r3, [pc, #320]	; (8004114 <HAL_RCC_OscConfig+0x260>)
      __HAL_RCC_LSI_ENABLE();
 8003fd4:	2101      	movs	r1, #1
 8003fd6:	f8c2 1e80 	str.w	r1, [r2, #3712]	; 0xe80
	return tick++;;
 8003fda:	681a      	ldr	r2, [r3, #0]
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8003fdc:	494c      	ldr	r1, [pc, #304]	; (8004110 <HAL_RCC_OscConfig+0x25c>)
	return tick++;;
 8003fde:	1c54      	adds	r4, r2, #1
 8003fe0:	601c      	str	r4, [r3, #0]
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8003fe2:	6f4c      	ldr	r4, [r1, #116]	; 0x74
 8003fe4:	07a6      	lsls	r6, r4, #30
 8003fe6:	f100 8111 	bmi.w	800420c <HAL_RCC_OscConfig+0x358>
 8003fea:	6f4d      	ldr	r5, [r1, #116]	; 0x74
 8003fec:	07ad      	lsls	r5, r5, #30
	return tick++;;
 8003fee:	f102 0402 	add.w	r4, r2, #2
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8003ff2:	d404      	bmi.n	8003ffe <HAL_RCC_OscConfig+0x14a>
 8003ff4:	6f49      	ldr	r1, [r1, #116]	; 0x74
 8003ff6:	078f      	lsls	r7, r1, #30
	return tick++;;
 8003ff8:	f102 0403 	add.w	r4, r2, #3
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8003ffc:	d5e2      	bpl.n	8003fc4 <HAL_RCC_OscConfig+0x110>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8003ffe:	6801      	ldr	r1, [r0, #0]
 8004000:	601c      	str	r4, [r3, #0]
 8004002:	074f      	lsls	r7, r1, #29
 8004004:	d541      	bpl.n	800408a <HAL_RCC_OscConfig+0x1d6>
    __HAL_RCC_PWR_CLK_ENABLE();
 8004006:	4b42      	ldr	r3, [pc, #264]	; (8004110 <HAL_RCC_OscConfig+0x25c>)
    PWR->CR |= PWR_CR_DBP;
 8004008:	4c45      	ldr	r4, [pc, #276]	; (8004120 <HAL_RCC_OscConfig+0x26c>)
    __HAL_RCC_PWR_CLK_ENABLE();
 800400a:	2200      	movs	r2, #0
 800400c:	9201      	str	r2, [sp, #4]
 800400e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8004010:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8004014:	641a      	str	r2, [r3, #64]	; 0x40
 8004016:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004018:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800401c:	9301      	str	r3, [sp, #4]
 800401e:	9b01      	ldr	r3, [sp, #4]
    PWR->CR |= PWR_CR_DBP;
 8004020:	6822      	ldr	r2, [r4, #0]
	return tick++;;
 8004022:	4b3c      	ldr	r3, [pc, #240]	; (8004114 <HAL_RCC_OscConfig+0x260>)
    PWR->CR |= PWR_CR_DBP;
 8004024:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8004028:	6022      	str	r2, [r4, #0]
	return tick++;;
 800402a:	6819      	ldr	r1, [r3, #0]
 800402c:	1c4a      	adds	r2, r1, #1
 800402e:	601a      	str	r2, [r3, #0]
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8004030:	6825      	ldr	r5, [r4, #0]
 8004032:	05ee      	lsls	r6, r5, #23
 8004034:	f100 80a3 	bmi.w	800417e <HAL_RCC_OscConfig+0x2ca>
 8004038:	6825      	ldr	r5, [r4, #0]
 800403a:	05ed      	lsls	r5, r5, #23
	return tick++;;
 800403c:	f101 0202 	add.w	r2, r1, #2
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8004040:	f100 809c 	bmi.w	800417c <HAL_RCC_OscConfig+0x2c8>
 8004044:	6824      	ldr	r4, [r4, #0]
 8004046:	05e4      	lsls	r4, r4, #23
	return tick++;;
 8004048:	f101 0203 	add.w	r2, r1, #3
    while((PWR->CR & PWR_CR_DBP) == RESET)
 800404c:	f100 8096 	bmi.w	800417c <HAL_RCC_OscConfig+0x2c8>
	return tick++;;
 8004050:	3104      	adds	r1, #4
 8004052:	6019      	str	r1, [r3, #0]
        return HAL_TIMEOUT;
 8004054:	2003      	movs	r0, #3
}
 8004056:	b002      	add	sp, #8
 8004058:	bcf0      	pop	{r4, r5, r6, r7}
 800405a:	4770      	bx	lr
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800405c:	4c2c      	ldr	r4, [pc, #176]	; (8004110 <HAL_RCC_OscConfig+0x25c>)
 800405e:	6f21      	ldr	r1, [r4, #112]	; 0x70
 8004060:	f041 0101 	orr.w	r1, r1, #1
 8004064:	6721      	str	r1, [r4, #112]	; 0x70
	return tick++;;
 8004066:	1c51      	adds	r1, r2, #1
 8004068:	f502 529c 	add.w	r2, r2, #4992	; 0x1380
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800406c:	4d28      	ldr	r5, [pc, #160]	; (8004110 <HAL_RCC_OscConfig+0x25c>)
	return tick++;;
 800406e:	6019      	str	r1, [r3, #0]
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8004070:	320a      	adds	r2, #10
 8004072:	2600      	movs	r6, #0
 8004074:	e004      	b.n	8004080 <HAL_RCC_OscConfig+0x1cc>
	return tick++;;
 8004076:	3101      	adds	r1, #1
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8004078:	428a      	cmp	r2, r1
 800407a:	f04f 0601 	mov.w	r6, #1
 800407e:	d0a2      	beq.n	8003fc6 <HAL_RCC_OscConfig+0x112>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8004080:	6f2c      	ldr	r4, [r5, #112]	; 0x70
 8004082:	07a7      	lsls	r7, r4, #30
 8004084:	d5f7      	bpl.n	8004076 <HAL_RCC_OscConfig+0x1c2>
 8004086:	b106      	cbz	r6, 800408a <HAL_RCC_OscConfig+0x1d6>
 8004088:	6019      	str	r1, [r3, #0]
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800408a:	6983      	ldr	r3, [r0, #24]
 800408c:	b1f3      	cbz	r3, 80040cc <HAL_RCC_OscConfig+0x218>
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 800408e:	4d20      	ldr	r5, [pc, #128]	; (8004110 <HAL_RCC_OscConfig+0x25c>)
 8004090:	68aa      	ldr	r2, [r5, #8]
 8004092:	f002 020c 	and.w	r2, r2, #12
 8004096:	2a08      	cmp	r2, #8
 8004098:	d035      	beq.n	8004106 <HAL_RCC_OscConfig+0x252>
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800409a:	2b02      	cmp	r3, #2
        __HAL_RCC_PLL_DISABLE();
 800409c:	4a1f      	ldr	r2, [pc, #124]	; (800411c <HAL_RCC_OscConfig+0x268>)
	return tick++;;
 800409e:	4b1d      	ldr	r3, [pc, #116]	; (8004114 <HAL_RCC_OscConfig+0x260>)
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80040a0:	f000 80b6 	beq.w	8004210 <HAL_RCC_OscConfig+0x35c>
        __HAL_RCC_PLL_DISABLE();
 80040a4:	2400      	movs	r4, #0
 80040a6:	6614      	str	r4, [r2, #96]	; 0x60
	return tick++;;
 80040a8:	6818      	ldr	r0, [r3, #0]
 80040aa:	1c42      	adds	r2, r0, #1
 80040ac:	f500 10f4 	add.w	r0, r0, #1998848	; 0x1e8000
 80040b0:	601a      	str	r2, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80040b2:	f200 4082 	addw	r0, r0, #1154	; 0x482
 80040b6:	e004      	b.n	80040c2 <HAL_RCC_OscConfig+0x20e>
	return tick++;;
 80040b8:	3201      	adds	r2, #1
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80040ba:	4282      	cmp	r2, r0
 80040bc:	f04f 0401 	mov.w	r4, #1
 80040c0:	d081      	beq.n	8003fc6 <HAL_RCC_OscConfig+0x112>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80040c2:	6829      	ldr	r1, [r5, #0]
 80040c4:	0189      	lsls	r1, r1, #6
 80040c6:	d4f7      	bmi.n	80040b8 <HAL_RCC_OscConfig+0x204>
 80040c8:	b104      	cbz	r4, 80040cc <HAL_RCC_OscConfig+0x218>
 80040ca:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 80040cc:	2000      	movs	r0, #0
}
 80040ce:	b002      	add	sp, #8
 80040d0:	bcf0      	pop	{r4, r5, r6, r7}
 80040d2:	4770      	bx	lr
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 80040d4:	6853      	ldr	r3, [r2, #4]
 80040d6:	025e      	lsls	r6, r3, #9
 80040d8:	f57f aefe 	bpl.w	8003ed8 <HAL_RCC_OscConfig+0x24>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80040dc:	4b0c      	ldr	r3, [pc, #48]	; (8004110 <HAL_RCC_OscConfig+0x25c>)
 80040de:	681b      	ldr	r3, [r3, #0]
 80040e0:	039d      	lsls	r5, r3, #14
 80040e2:	f57f af1f 	bpl.w	8003f24 <HAL_RCC_OscConfig+0x70>
 80040e6:	6843      	ldr	r3, [r0, #4]
 80040e8:	2b00      	cmp	r3, #0
 80040ea:	f47f af1b 	bne.w	8003f24 <HAL_RCC_OscConfig+0x70>
 80040ee:	e00a      	b.n	8004106 <HAL_RCC_OscConfig+0x252>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80040f0:	685b      	ldr	r3, [r3, #4]
 80040f2:	025b      	lsls	r3, r3, #9
 80040f4:	f53f af24 	bmi.w	8003f40 <HAL_RCC_OscConfig+0x8c>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80040f8:	4b05      	ldr	r3, [pc, #20]	; (8004110 <HAL_RCC_OscConfig+0x25c>)
 80040fa:	681b      	ldr	r3, [r3, #0]
 80040fc:	079f      	lsls	r7, r3, #30
 80040fe:	d511      	bpl.n	8004124 <HAL_RCC_OscConfig+0x270>
 8004100:	68c3      	ldr	r3, [r0, #12]
 8004102:	2b01      	cmp	r3, #1
 8004104:	d00e      	beq.n	8004124 <HAL_RCC_OscConfig+0x270>
        return HAL_ERROR;
 8004106:	2001      	movs	r0, #1
}
 8004108:	b002      	add	sp, #8
 800410a:	bcf0      	pop	{r4, r5, r6, r7}
 800410c:	4770      	bx	lr
 800410e:	bf00      	nop
 8004110:	40023800 	.word	0x40023800
 8004114:	200018dc 	.word	0x200018dc
 8004118:	05f5e102 	.word	0x05f5e102
 800411c:	42470000 	.word	0x42470000
 8004120:	40007000 	.word	0x40007000
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8004124:	4d6b      	ldr	r5, [pc, #428]	; (80042d4 <HAL_RCC_OscConfig+0x420>)
 8004126:	23f8      	movs	r3, #248	; 0xf8
 8004128:	682c      	ldr	r4, [r5, #0]
 800412a:	fa93 f3a3 	rbit	r3, r3
 800412e:	fab3 f283 	clz	r2, r3
 8004132:	6903      	ldr	r3, [r0, #16]
 8004134:	f024 04f8 	bic.w	r4, r4, #248	; 0xf8
 8004138:	4093      	lsls	r3, r2
 800413a:	4323      	orrs	r3, r4
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800413c:	070f      	lsls	r7, r1, #28
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800413e:	602b      	str	r3, [r5, #0]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8004140:	f57f af5f 	bpl.w	8004002 <HAL_RCC_OscConfig+0x14e>
 8004144:	e726      	b.n	8003f94 <HAL_RCC_OscConfig+0xe0>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8004146:	4a63      	ldr	r2, [pc, #396]	; (80042d4 <HAL_RCC_OscConfig+0x420>)
 8004148:	6813      	ldr	r3, [r2, #0]
 800414a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800414e:	6013      	str	r3, [r2, #0]
	return tick++;;
 8004150:	4b61      	ldr	r3, [pc, #388]	; (80042d8 <HAL_RCC_OscConfig+0x424>)
 8004152:	4d62      	ldr	r5, [pc, #392]	; (80042dc <HAL_RCC_OscConfig+0x428>)
 8004154:	681c      	ldr	r4, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8004156:	4f5f      	ldr	r7, [pc, #380]	; (80042d4 <HAL_RCC_OscConfig+0x420>)
	return tick++;;
 8004158:	1c62      	adds	r2, r4, #1
 800415a:	601a      	str	r2, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800415c:	4425      	add	r5, r4
 800415e:	2600      	movs	r6, #0
 8004160:	e005      	b.n	800416e <HAL_RCC_OscConfig+0x2ba>
	return tick++;;
 8004162:	3201      	adds	r2, #1
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8004164:	42aa      	cmp	r2, r5
 8004166:	f04f 0601 	mov.w	r6, #1
 800416a:	f43f af2c 	beq.w	8003fc6 <HAL_RCC_OscConfig+0x112>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800416e:	683c      	ldr	r4, [r7, #0]
 8004170:	03a4      	lsls	r4, r4, #14
 8004172:	d5f6      	bpl.n	8004162 <HAL_RCC_OscConfig+0x2ae>
 8004174:	2e00      	cmp	r6, #0
 8004176:	f47f aed4 	bne.w	8003f22 <HAL_RCC_OscConfig+0x6e>
 800417a:	e6d3      	b.n	8003f24 <HAL_RCC_OscConfig+0x70>
 800417c:	601a      	str	r2, [r3, #0]
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800417e:	6885      	ldr	r5, [r0, #8]
 8004180:	2d01      	cmp	r5, #1
 8004182:	f43f af6b 	beq.w	800405c <HAL_RCC_OscConfig+0x1a8>
 8004186:	2d05      	cmp	r5, #5
 8004188:	f000 8097 	beq.w	80042ba <HAL_RCC_OscConfig+0x406>
 800418c:	4e51      	ldr	r6, [pc, #324]	; (80042d4 <HAL_RCC_OscConfig+0x420>)
 800418e:	6f31      	ldr	r1, [r6, #112]	; 0x70
 8004190:	f021 0101 	bic.w	r1, r1, #1
 8004194:	6731      	str	r1, [r6, #112]	; 0x70
 8004196:	6f31      	ldr	r1, [r6, #112]	; 0x70
 8004198:	f021 0104 	bic.w	r1, r1, #4
 800419c:	6731      	str	r1, [r6, #112]	; 0x70
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 800419e:	2d00      	cmp	r5, #0
 80041a0:	f47f af61 	bne.w	8004066 <HAL_RCC_OscConfig+0x1b2>
	return tick++;;
 80041a4:	1c51      	adds	r1, r2, #1
 80041a6:	f502 529c 	add.w	r2, r2, #4992	; 0x1380
 80041aa:	6019      	str	r1, [r3, #0]
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80041ac:	320a      	adds	r2, #10
 80041ae:	e004      	b.n	80041ba <HAL_RCC_OscConfig+0x306>
	return tick++;;
 80041b0:	3101      	adds	r1, #1
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80041b2:	4291      	cmp	r1, r2
 80041b4:	f04f 0501 	mov.w	r5, #1
 80041b8:	d07c      	beq.n	80042b4 <HAL_RCC_OscConfig+0x400>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80041ba:	6f34      	ldr	r4, [r6, #112]	; 0x70
 80041bc:	07a4      	lsls	r4, r4, #30
 80041be:	d4f7      	bmi.n	80041b0 <HAL_RCC_OscConfig+0x2fc>
 80041c0:	2d00      	cmp	r5, #0
 80041c2:	f47f af61 	bne.w	8004088 <HAL_RCC_OscConfig+0x1d4>
 80041c6:	e760      	b.n	800408a <HAL_RCC_OscConfig+0x1d6>
        __HAL_RCC_HSI_DISABLE();
 80041c8:	4945      	ldr	r1, [pc, #276]	; (80042e0 <HAL_RCC_OscConfig+0x42c>)
	return tick++;;
 80041ca:	4b43      	ldr	r3, [pc, #268]	; (80042d8 <HAL_RCC_OscConfig+0x424>)
        __HAL_RCC_HSI_DISABLE();
 80041cc:	600a      	str	r2, [r1, #0]
	return tick++;;
 80041ce:	681a      	ldr	r2, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80041d0:	4940      	ldr	r1, [pc, #256]	; (80042d4 <HAL_RCC_OscConfig+0x420>)
	return tick++;;
 80041d2:	1c54      	adds	r4, r2, #1
 80041d4:	601c      	str	r4, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80041d6:	680c      	ldr	r4, [r1, #0]
 80041d8:	07a6      	lsls	r6, r4, #30
 80041da:	d578      	bpl.n	80042ce <HAL_RCC_OscConfig+0x41a>
 80041dc:	680d      	ldr	r5, [r1, #0]
 80041de:	07ad      	lsls	r5, r5, #30
	return tick++;;
 80041e0:	f102 0402 	add.w	r4, r2, #2
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80041e4:	d505      	bpl.n	80041f2 <HAL_RCC_OscConfig+0x33e>
 80041e6:	6809      	ldr	r1, [r1, #0]
 80041e8:	0789      	lsls	r1, r1, #30
	return tick++;;
 80041ea:	f102 0403 	add.w	r4, r2, #3
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80041ee:	f53f aee9 	bmi.w	8003fc4 <HAL_RCC_OscConfig+0x110>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80041f2:	6801      	ldr	r1, [r0, #0]
 80041f4:	601c      	str	r4, [r3, #0]
 80041f6:	e6cb      	b.n	8003f90 <HAL_RCC_OscConfig+0xdc>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80041f8:	4b36      	ldr	r3, [pc, #216]	; (80042d4 <HAL_RCC_OscConfig+0x420>)
 80041fa:	681a      	ldr	r2, [r3, #0]
 80041fc:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8004200:	601a      	str	r2, [r3, #0]
 8004202:	681a      	ldr	r2, [r3, #0]
 8004204:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8004208:	601a      	str	r2, [r3, #0]
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 800420a:	e7a1      	b.n	8004150 <HAL_RCC_OscConfig+0x29c>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800420c:	6801      	ldr	r1, [r0, #0]
 800420e:	e6f8      	b.n	8004002 <HAL_RCC_OscConfig+0x14e>
        __HAL_RCC_PLL_DISABLE();
 8004210:	2600      	movs	r6, #0
 8004212:	6616      	str	r6, [r2, #96]	; 0x60
	return tick++;;
 8004214:	681c      	ldr	r4, [r3, #0]
 8004216:	1c62      	adds	r2, r4, #1
 8004218:	f504 14f4 	add.w	r4, r4, #1998848	; 0x1e8000
 800421c:	601a      	str	r2, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800421e:	f204 4482 	addw	r4, r4, #1154	; 0x482
 8004222:	e005      	b.n	8004230 <HAL_RCC_OscConfig+0x37c>
	return tick++;;
 8004224:	3201      	adds	r2, #1
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8004226:	42a2      	cmp	r2, r4
 8004228:	f04f 0601 	mov.w	r6, #1
 800422c:	f43f aecb 	beq.w	8003fc6 <HAL_RCC_OscConfig+0x112>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8004230:	6829      	ldr	r1, [r5, #0]
 8004232:	018f      	lsls	r7, r1, #6
 8004234:	d4f6      	bmi.n	8004224 <HAL_RCC_OscConfig+0x370>
 8004236:	b106      	cbz	r6, 800423a <HAL_RCC_OscConfig+0x386>
 8004238:	601a      	str	r2, [r3, #0]
 800423a:	f647 75c0 	movw	r5, #32704	; 0x7fc0
 800423e:	fa95 f5a5 	rbit	r5, r5
 8004242:	f44f 3140 	mov.w	r1, #196608	; 0x30000
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 8004246:	fab5 f585 	clz	r5, r5
 800424a:	fa91 f1a1 	rbit	r1, r1
 800424e:	f04f 6470 	mov.w	r4, #251658240	; 0xf000000
 8004252:	fab1 f181 	clz	r1, r1
 8004256:	fa94 f4a4 	rbit	r4, r4
 800425a:	6a82      	ldr	r2, [r0, #40]	; 0x28
 800425c:	0852      	lsrs	r2, r2, #1
 800425e:	3a01      	subs	r2, #1
 8004260:	fa02 f101 	lsl.w	r1, r2, r1
 8004264:	e9d0 2607 	ldrd	r2, r6, [r0, #28]
 8004268:	4332      	orrs	r2, r6
 800426a:	6a46      	ldr	r6, [r0, #36]	; 0x24
 800426c:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 800426e:	fa06 f505 	lsl.w	r5, r6, r5
 8004272:	fab4 f484 	clz	r4, r4
 8004276:	432a      	orrs	r2, r5
 8004278:	40a0      	lsls	r0, r4
 800427a:	430a      	orrs	r2, r1
 800427c:	4c15      	ldr	r4, [pc, #84]	; (80042d4 <HAL_RCC_OscConfig+0x420>)
        __HAL_RCC_PLL_ENABLE();
 800427e:	4918      	ldr	r1, [pc, #96]	; (80042e0 <HAL_RCC_OscConfig+0x42c>)
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 8004280:	4302      	orrs	r2, r0
        __HAL_RCC_PLL_ENABLE();
 8004282:	2001      	movs	r0, #1
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 8004284:	6062      	str	r2, [r4, #4]
        __HAL_RCC_PLL_ENABLE();
 8004286:	6608      	str	r0, [r1, #96]	; 0x60
	return tick++;;
 8004288:	6818      	ldr	r0, [r3, #0]
 800428a:	1c42      	adds	r2, r0, #1
 800428c:	f500 10f4 	add.w	r0, r0, #1998848	; 0x1e8000
 8004290:	601a      	str	r2, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8004292:	f200 4082 	addw	r0, r0, #1154	; 0x482
 8004296:	2500      	movs	r5, #0
 8004298:	e005      	b.n	80042a6 <HAL_RCC_OscConfig+0x3f2>
	return tick++;;
 800429a:	3201      	adds	r2, #1
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800429c:	4282      	cmp	r2, r0
 800429e:	f04f 0501 	mov.w	r5, #1
 80042a2:	f43f ae90 	beq.w	8003fc6 <HAL_RCC_OscConfig+0x112>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80042a6:	6821      	ldr	r1, [r4, #0]
 80042a8:	018e      	lsls	r6, r1, #6
 80042aa:	d5f6      	bpl.n	800429a <HAL_RCC_OscConfig+0x3e6>
 80042ac:	2d00      	cmp	r5, #0
 80042ae:	f47f af0c 	bne.w	80040ca <HAL_RCC_OscConfig+0x216>
 80042b2:	e70b      	b.n	80040cc <HAL_RCC_OscConfig+0x218>
 80042b4:	6019      	str	r1, [r3, #0]
          return HAL_TIMEOUT;
 80042b6:	2003      	movs	r0, #3
 80042b8:	e6cd      	b.n	8004056 <HAL_RCC_OscConfig+0x1a2>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80042ba:	4906      	ldr	r1, [pc, #24]	; (80042d4 <HAL_RCC_OscConfig+0x420>)
 80042bc:	6f0c      	ldr	r4, [r1, #112]	; 0x70
 80042be:	f044 0404 	orr.w	r4, r4, #4
 80042c2:	670c      	str	r4, [r1, #112]	; 0x70
 80042c4:	6f0c      	ldr	r4, [r1, #112]	; 0x70
 80042c6:	f044 0401 	orr.w	r4, r4, #1
 80042ca:	670c      	str	r4, [r1, #112]	; 0x70
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 80042cc:	e6cb      	b.n	8004066 <HAL_RCC_OscConfig+0x1b2>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80042ce:	6801      	ldr	r1, [r0, #0]
 80042d0:	e65e      	b.n	8003f90 <HAL_RCC_OscConfig+0xdc>
 80042d2:	bf00      	nop
 80042d4:	40023800 	.word	0x40023800
 80042d8:	200018dc 	.word	0x200018dc
 80042dc:	05f5e102 	.word	0x05f5e102
 80042e0:	42470000 	.word	0x42470000

080042e4 <HAL_RCC_ClockConfig>:
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 80042e4:	4a63      	ldr	r2, [pc, #396]	; (8004474 <HAL_RCC_ClockConfig+0x190>)
 80042e6:	6813      	ldr	r3, [r2, #0]
 80042e8:	f003 030f 	and.w	r3, r3, #15
 80042ec:	428b      	cmp	r3, r1
 80042ee:	d208      	bcs.n	8004302 <HAL_RCC_ClockConfig+0x1e>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80042f0:	b2cb      	uxtb	r3, r1
 80042f2:	7013      	strb	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 80042f4:	6813      	ldr	r3, [r2, #0]
 80042f6:	f003 030f 	and.w	r3, r3, #15
 80042fa:	428b      	cmp	r3, r1
 80042fc:	d001      	beq.n	8004302 <HAL_RCC_ClockConfig+0x1e>
    {
      return HAL_ERROR;
 80042fe:	2001      	movs	r0, #1

  /* Configure the source of time base considering new system clocks settings*/
  //HAL_InitTick (TICK_INT_PRIORITY);

  return HAL_OK;
}
 8004300:	4770      	bx	lr
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8004302:	6803      	ldr	r3, [r0, #0]
{
 8004304:	b5f0      	push	{r4, r5, r6, r7, lr}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8004306:	079e      	lsls	r6, r3, #30
 8004308:	d506      	bpl.n	8004318 <HAL_RCC_ClockConfig+0x34>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800430a:	4c5b      	ldr	r4, [pc, #364]	; (8004478 <HAL_RCC_ClockConfig+0x194>)
 800430c:	6885      	ldr	r5, [r0, #8]
 800430e:	68a2      	ldr	r2, [r4, #8]
 8004310:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8004314:	432a      	orrs	r2, r5
 8004316:	60a2      	str	r2, [r4, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8004318:	07dd      	lsls	r5, r3, #31
 800431a:	d527      	bpl.n	800436c <HAL_RCC_ClockConfig+0x88>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800431c:	6844      	ldr	r4, [r0, #4]
 800431e:	2c01      	cmp	r4, #1
 8004320:	d06d      	beq.n	80043fe <HAL_RCC_ClockConfig+0x11a>
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 8004322:	1ea2      	subs	r2, r4, #2
 8004324:	2a01      	cmp	r2, #1
 8004326:	d949      	bls.n	80043bc <HAL_RCC_ClockConfig+0xd8>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8004328:	4d53      	ldr	r5, [pc, #332]	; (8004478 <HAL_RCC_ClockConfig+0x194>)
 800432a:	682a      	ldr	r2, [r5, #0]
 800432c:	0796      	lsls	r6, r2, #30
 800432e:	d52a      	bpl.n	8004386 <HAL_RCC_ClockConfig+0xa2>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8004330:	68aa      	ldr	r2, [r5, #8]
	return tick++;;
 8004332:	4e52      	ldr	r6, [pc, #328]	; (800447c <HAL_RCC_ClockConfig+0x198>)
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8004334:	f022 0203 	bic.w	r2, r2, #3
 8004338:	4314      	orrs	r4, r2
 800433a:	60ac      	str	r4, [r5, #8]
	return tick++;;
 800433c:	6837      	ldr	r7, [r6, #0]
 800433e:	1c7a      	adds	r2, r7, #1
 8004340:	f04f 0c00 	mov.w	ip, #0
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8004344:	f241 3e88 	movw	lr, #5000	; 0x1388
	return tick++;;
 8004348:	6032      	str	r2, [r6, #0]
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800434a:	43ff      	mvns	r7, r7
 800434c:	e006      	b.n	800435c <HAL_RCC_ClockConfig+0x78>
	return tick++;;
 800434e:	3201      	adds	r2, #1
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8004350:	18bc      	adds	r4, r7, r2
 8004352:	4574      	cmp	r4, lr
 8004354:	f04f 0c01 	mov.w	ip, #1
 8004358:	f200 8088 	bhi.w	800446c <HAL_RCC_ClockConfig+0x188>
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 800435c:	68ac      	ldr	r4, [r5, #8]
 800435e:	f014 0f0c 	tst.w	r4, #12
 8004362:	d1f4      	bne.n	800434e <HAL_RCC_ClockConfig+0x6a>
 8004364:	f1bc 0f00 	cmp.w	ip, #0
 8004368:	d000      	beq.n	800436c <HAL_RCC_ClockConfig+0x88>
 800436a:	6032      	str	r2, [r6, #0]
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
 800436c:	4c41      	ldr	r4, [pc, #260]	; (8004474 <HAL_RCC_ClockConfig+0x190>)
 800436e:	6822      	ldr	r2, [r4, #0]
 8004370:	f002 020f 	and.w	r2, r2, #15
 8004374:	428a      	cmp	r2, r1
 8004376:	d909      	bls.n	800438c <HAL_RCC_ClockConfig+0xa8>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8004378:	b2cb      	uxtb	r3, r1
 800437a:	7023      	strb	r3, [r4, #0]
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 800437c:	6823      	ldr	r3, [r4, #0]
 800437e:	f003 030f 	and.w	r3, r3, #15
 8004382:	428b      	cmp	r3, r1
 8004384:	d001      	beq.n	800438a <HAL_RCC_ClockConfig+0xa6>
      return HAL_ERROR;
 8004386:	2001      	movs	r0, #1
}
 8004388:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800438a:	6803      	ldr	r3, [r0, #0]
 800438c:	075a      	lsls	r2, r3, #29
 800438e:	d506      	bpl.n	800439e <HAL_RCC_ClockConfig+0xba>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8004390:	4939      	ldr	r1, [pc, #228]	; (8004478 <HAL_RCC_ClockConfig+0x194>)
 8004392:	68c4      	ldr	r4, [r0, #12]
 8004394:	688a      	ldr	r2, [r1, #8]
 8004396:	f422 52e0 	bic.w	r2, r2, #7168	; 0x1c00
 800439a:	4322      	orrs	r2, r4
 800439c:	608a      	str	r2, [r1, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800439e:	f013 0308 	ands.w	r3, r3, #8
 80043a2:	d009      	beq.n	80043b8 <HAL_RCC_ClockConfig+0xd4>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 80043a4:	4a34      	ldr	r2, [pc, #208]	; (8004478 <HAL_RCC_ClockConfig+0x194>)
 80043a6:	6901      	ldr	r1, [r0, #16]
 80043a8:	6893      	ldr	r3, [r2, #8]
 80043aa:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 80043ae:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
  return HAL_OK;
 80043b2:	2000      	movs	r0, #0
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 80043b4:	6093      	str	r3, [r2, #8]
}
 80043b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  return HAL_OK;
 80043b8:	4618      	mov	r0, r3
}
 80043ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80043bc:	4f2e      	ldr	r7, [pc, #184]	; (8004478 <HAL_RCC_ClockConfig+0x194>)
 80043be:	683a      	ldr	r2, [r7, #0]
 80043c0:	0192      	lsls	r2, r2, #6
 80043c2:	d5e0      	bpl.n	8004386 <HAL_RCC_ClockConfig+0xa2>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80043c4:	68ba      	ldr	r2, [r7, #8]
	return tick++;;
 80043c6:	4e2d      	ldr	r6, [pc, #180]	; (800447c <HAL_RCC_ClockConfig+0x198>)
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80043c8:	f022 0203 	bic.w	r2, r2, #3
 80043cc:	4322      	orrs	r2, r4
 80043ce:	60ba      	str	r2, [r7, #8]
	return tick++;;
 80043d0:	6835      	ldr	r5, [r6, #0]
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80043d2:	2c02      	cmp	r4, #2
	return tick++;;
 80043d4:	f105 0201 	add.w	r2, r5, #1
 80043d8:	6032      	str	r2, [r6, #0]
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80043da:	d136      	bne.n	800444a <HAL_RCC_ClockConfig+0x166>
 80043dc:	f505 559c 	add.w	r5, r5, #4992	; 0x1380
 80043e0:	350a      	adds	r5, #10
 80043e2:	f04f 0c00 	mov.w	ip, #0
 80043e6:	e004      	b.n	80043f2 <HAL_RCC_ClockConfig+0x10e>
	return tick++;;
 80043e8:	3201      	adds	r2, #1
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80043ea:	4295      	cmp	r5, r2
 80043ec:	f04f 0c01 	mov.w	ip, #1
 80043f0:	d028      	beq.n	8004444 <HAL_RCC_ClockConfig+0x160>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80043f2:	68bc      	ldr	r4, [r7, #8]
 80043f4:	f004 040c 	and.w	r4, r4, #12
 80043f8:	2c08      	cmp	r4, #8
 80043fa:	d1f5      	bne.n	80043e8 <HAL_RCC_ClockConfig+0x104>
 80043fc:	e7b2      	b.n	8004364 <HAL_RCC_ClockConfig+0x80>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80043fe:	4f1e      	ldr	r7, [pc, #120]	; (8004478 <HAL_RCC_ClockConfig+0x194>)
 8004400:	683a      	ldr	r2, [r7, #0]
 8004402:	0394      	lsls	r4, r2, #14
 8004404:	d5bf      	bpl.n	8004386 <HAL_RCC_ClockConfig+0xa2>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8004406:	68ba      	ldr	r2, [r7, #8]
	return tick++;;
 8004408:	4e1c      	ldr	r6, [pc, #112]	; (800447c <HAL_RCC_ClockConfig+0x198>)
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 800440a:	f022 0203 	bic.w	r2, r2, #3
 800440e:	f042 0201 	orr.w	r2, r2, #1
 8004412:	60ba      	str	r2, [r7, #8]
	return tick++;;
 8004414:	6835      	ldr	r5, [r6, #0]
 8004416:	1c6c      	adds	r4, r5, #1
 8004418:	f505 559c 	add.w	r5, r5, #4992	; 0x1380
 800441c:	f04f 0c00 	mov.w	ip, #0
 8004420:	6034      	str	r4, [r6, #0]
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8004422:	350a      	adds	r5, #10
 8004424:	e004      	b.n	8004430 <HAL_RCC_ClockConfig+0x14c>
	return tick++;;
 8004426:	3401      	adds	r4, #1
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8004428:	42a5      	cmp	r5, r4
 800442a:	f04f 0c01 	mov.w	ip, #1
 800442e:	d009      	beq.n	8004444 <HAL_RCC_ClockConfig+0x160>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8004430:	68ba      	ldr	r2, [r7, #8]
 8004432:	f002 020c 	and.w	r2, r2, #12
 8004436:	2a04      	cmp	r2, #4
 8004438:	d1f5      	bne.n	8004426 <HAL_RCC_ClockConfig+0x142>
 800443a:	f1bc 0f00 	cmp.w	ip, #0
 800443e:	d095      	beq.n	800436c <HAL_RCC_ClockConfig+0x88>
 8004440:	6034      	str	r4, [r6, #0]
 8004442:	e793      	b.n	800436c <HAL_RCC_ClockConfig+0x88>
 8004444:	6035      	str	r5, [r6, #0]
          return HAL_TIMEOUT;
 8004446:	2003      	movs	r0, #3
}
 8004448:	bdf0      	pop	{r4, r5, r6, r7, pc}
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK)
 800444a:	f505 559c 	add.w	r5, r5, #4992	; 0x1380
 800444e:	350a      	adds	r5, #10
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8004450:	f04f 0c00 	mov.w	ip, #0
 8004454:	e004      	b.n	8004460 <HAL_RCC_ClockConfig+0x17c>
	return tick++;;
 8004456:	3201      	adds	r2, #1
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8004458:	4295      	cmp	r5, r2
 800445a:	f04f 0c01 	mov.w	ip, #1
 800445e:	d0f1      	beq.n	8004444 <HAL_RCC_ClockConfig+0x160>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLRCLK)
 8004460:	68bc      	ldr	r4, [r7, #8]
 8004462:	f004 040c 	and.w	r4, r4, #12
 8004466:	2c0c      	cmp	r4, #12
 8004468:	d1f5      	bne.n	8004456 <HAL_RCC_ClockConfig+0x172>
 800446a:	e77b      	b.n	8004364 <HAL_RCC_ClockConfig+0x80>
 800446c:	6032      	str	r2, [r6, #0]
          return HAL_TIMEOUT;
 800446e:	2003      	movs	r0, #3
}
 8004470:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004472:	bf00      	nop
 8004474:	40023c00 	.word	0x40023c00
 8004478:	40023800 	.word	0x40023800
 800447c:	200018dc 	.word	0x200018dc

08004480 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8004480:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 8004484:	2300      	movs	r3, #0
  {
    /* Get the IO position */
    ioposition = 0x01U << position;
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8004486:	680d      	ldr	r5, [r1, #0]
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8004488:	f8df 8234 	ldr.w	r8, [pc, #564]	; 80046c0 <HAL_GPIO_Init+0x240>
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 800448c:	4f8d      	ldr	r7, [pc, #564]	; (80046c4 <HAL_GPIO_Init+0x244>)
{
 800448e:	b083      	sub	sp, #12
 8004490:	e003      	b.n	800449a <HAL_GPIO_Init+0x1a>
  for(position = 0U; position < GPIO_NUMBER; position++)
 8004492:	3301      	adds	r3, #1
 8004494:	2b10      	cmp	r3, #16
 8004496:	f000 80a5 	beq.w	80045e4 <HAL_GPIO_Init+0x164>
    ioposition = 0x01U << position;
 800449a:	2201      	movs	r2, #1
 800449c:	409a      	lsls	r2, r3
    if(iocurrent == ioposition)
 800449e:	ea32 0405 	bics.w	r4, r2, r5
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 80044a2:	ea02 0c05 	and.w	ip, r2, r5
    if(iocurrent == ioposition)
 80044a6:	d1f4      	bne.n	8004492 <HAL_GPIO_Init+0x12>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 80044a8:	684e      	ldr	r6, [r1, #4]
 80044aa:	f026 0910 	bic.w	r9, r6, #16
 80044ae:	f1b9 0f02 	cmp.w	r9, #2
 80044b2:	f000 809a 	beq.w	80045ea <HAL_GPIO_Init+0x16a>
      temp = GPIOx->MODER;
 80044b6:	f8d0 b000 	ldr.w	fp, [r0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 80044ba:	ea4f 0e43 	mov.w	lr, r3, lsl #1
 80044be:	2403      	movs	r4, #3
 80044c0:	fa04 f40e 	lsl.w	r4, r4, lr
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 80044c4:	f006 0a03 	and.w	sl, r6, #3
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 80044c8:	ea2b 0b04 	bic.w	fp, fp, r4
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80044cc:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 80044d0:	fa0a fa0e 	lsl.w	sl, sl, lr
 80044d4:	ea4a 0a0b 	orr.w	sl, sl, fp
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80044d8:	f1b9 0f01 	cmp.w	r9, #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 80044dc:	ea6f 0404 	mvn.w	r4, r4
      GPIOx->MODER = temp;
 80044e0:	f8c0 a000 	str.w	sl, [r0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80044e4:	f240 80aa 	bls.w	800463c <HAL_GPIO_Init+0x1bc>
      temp = GPIOx->PUPDR;
 80044e8:	68c2      	ldr	r2, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 80044ea:	4014      	ands	r4, r2
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 80044ec:	688a      	ldr	r2, [r1, #8]
 80044ee:	fa02 f20e 	lsl.w	r2, r2, lr
 80044f2:	4322      	orrs	r2, r4
      GPIOx->PUPDR = temp;
 80044f4:	60c2      	str	r2, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 80044f6:	00f2      	lsls	r2, r6, #3
 80044f8:	d5cb      	bpl.n	8004492 <HAL_GPIO_Init+0x12>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80044fa:	2200      	movs	r2, #0
 80044fc:	9201      	str	r2, [sp, #4]
 80044fe:	f8d8 2044 	ldr.w	r2, [r8, #68]	; 0x44
 8004502:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8004506:	f8c8 2044 	str.w	r2, [r8, #68]	; 0x44
 800450a:	f8d8 2044 	ldr.w	r2, [r8, #68]	; 0x44
 800450e:	f402 4280 	and.w	r2, r2, #16384	; 0x4000
 8004512:	9201      	str	r2, [sp, #4]
 8004514:	9a01      	ldr	r2, [sp, #4]
        temp = SYSCFG->EXTICR[position >> 2U];
 8004516:	f023 0203 	bic.w	r2, r3, #3
 800451a:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 800451e:	f502 329c 	add.w	r2, r2, #79872	; 0x13800
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8004522:	f003 0903 	and.w	r9, r3, #3
        temp = SYSCFG->EXTICR[position >> 2U];
 8004526:	f8d2 e008 	ldr.w	lr, [r2, #8]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 800452a:	ea4f 0989 	mov.w	r9, r9, lsl #2
 800452e:	240f      	movs	r4, #15
 8004530:	fa04 f409 	lsl.w	r4, r4, r9
 8004534:	ea2e 0404 	bic.w	r4, lr, r4
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8004538:	f8df e18c 	ldr.w	lr, [pc, #396]	; 80046c8 <HAL_GPIO_Init+0x248>
 800453c:	4570      	cmp	r0, lr
 800453e:	d029      	beq.n	8004594 <HAL_GPIO_Init+0x114>
 8004540:	f50e 6e80 	add.w	lr, lr, #1024	; 0x400
 8004544:	4570      	cmp	r0, lr
 8004546:	f000 8090 	beq.w	800466a <HAL_GPIO_Init+0x1ea>
 800454a:	f8df e180 	ldr.w	lr, [pc, #384]	; 80046cc <HAL_GPIO_Init+0x24c>
 800454e:	4570      	cmp	r0, lr
 8004550:	f000 8092 	beq.w	8004678 <HAL_GPIO_Init+0x1f8>
 8004554:	f8df e178 	ldr.w	lr, [pc, #376]	; 80046d0 <HAL_GPIO_Init+0x250>
 8004558:	4570      	cmp	r0, lr
 800455a:	f000 8094 	beq.w	8004686 <HAL_GPIO_Init+0x206>
 800455e:	f8df e174 	ldr.w	lr, [pc, #372]	; 80046d4 <HAL_GPIO_Init+0x254>
 8004562:	4570      	cmp	r0, lr
 8004564:	f000 8096 	beq.w	8004694 <HAL_GPIO_Init+0x214>
 8004568:	f8df e16c 	ldr.w	lr, [pc, #364]	; 80046d8 <HAL_GPIO_Init+0x258>
 800456c:	4570      	cmp	r0, lr
 800456e:	f000 8098 	beq.w	80046a2 <HAL_GPIO_Init+0x222>
 8004572:	f8df e168 	ldr.w	lr, [pc, #360]	; 80046dc <HAL_GPIO_Init+0x25c>
 8004576:	4570      	cmp	r0, lr
 8004578:	f000 809a 	beq.w	80046b0 <HAL_GPIO_Init+0x230>
 800457c:	f8df e160 	ldr.w	lr, [pc, #352]	; 80046e0 <HAL_GPIO_Init+0x260>
 8004580:	4570      	cmp	r0, lr
 8004582:	bf0c      	ite	eq
 8004584:	f04f 0e07 	moveq.w	lr, #7
 8004588:	f04f 0e08 	movne.w	lr, #8
 800458c:	fa0e f909 	lsl.w	r9, lr, r9
 8004590:	ea44 0409 	orr.w	r4, r4, r9
        SYSCFG->EXTICR[position >> 2U] = temp;
 8004594:	6094      	str	r4, [r2, #8]
        temp = EXTI->IMR;
 8004596:	683a      	ldr	r2, [r7, #0]
        temp &= ~((uint32_t)iocurrent);
 8004598:	ea6f 0e0c 	mvn.w	lr, ip
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800459c:	03f4      	lsls	r4, r6, #15
        temp &= ~((uint32_t)iocurrent);
 800459e:	bf54      	ite	pl
 80045a0:	ea0e 0202 	andpl.w	r2, lr, r2
        {
          temp |= iocurrent;
 80045a4:	ea4c 0202 	orrmi.w	r2, ip, r2
        }
        EXTI->IMR = temp;
 80045a8:	603a      	str	r2, [r7, #0]

        temp = EXTI->EMR;
 80045aa:	687c      	ldr	r4, [r7, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 80045ac:	03b2      	lsls	r2, r6, #14
        temp &= ~((uint32_t)iocurrent);
 80045ae:	bf54      	ite	pl
 80045b0:	ea0e 0404 	andpl.w	r4, lr, r4
        {
          temp |= iocurrent;
 80045b4:	ea4c 0404 	orrmi.w	r4, ip, r4
        }
        EXTI->EMR = temp;
 80045b8:	607c      	str	r4, [r7, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 80045ba:	68bc      	ldr	r4, [r7, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 80045bc:	02f2      	lsls	r2, r6, #11
        temp &= ~((uint32_t)iocurrent);
 80045be:	bf54      	ite	pl
 80045c0:	ea0e 0404 	andpl.w	r4, lr, r4
        {
          temp |= iocurrent;
 80045c4:	ea4c 0404 	orrmi.w	r4, ip, r4
        }
        EXTI->RTSR = temp;
 80045c8:	60bc      	str	r4, [r7, #8]

        temp = EXTI->FTSR;
 80045ca:	68fa      	ldr	r2, [r7, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 80045cc:	02b4      	lsls	r4, r6, #10
  for(position = 0U; position < GPIO_NUMBER; position++)
 80045ce:	f103 0301 	add.w	r3, r3, #1
        temp &= ~((uint32_t)iocurrent);
 80045d2:	bf54      	ite	pl
 80045d4:	ea0e 0202 	andpl.w	r2, lr, r2
        {
          temp |= iocurrent;
 80045d8:	ea4c 0202 	orrmi.w	r2, ip, r2
  for(position = 0U; position < GPIO_NUMBER; position++)
 80045dc:	2b10      	cmp	r3, #16
        }
        EXTI->FTSR = temp;
 80045de:	60fa      	str	r2, [r7, #12]
  for(position = 0U; position < GPIO_NUMBER; position++)
 80045e0:	f47f af5b 	bne.w	800449a <HAL_GPIO_Init+0x1a>
      }
    }
  }
}
 80045e4:	b003      	add	sp, #12
 80045e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp = GPIOx->AFR[position >> 3U];
 80045ea:	ea4f 0ed3 	mov.w	lr, r3, lsr #3
 80045ee:	eb00 0e8e 	add.w	lr, r0, lr, lsl #2
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 80045f2:	690c      	ldr	r4, [r1, #16]
        temp = GPIOx->AFR[position >> 3U];
 80045f4:	f8de a020 	ldr.w	sl, [lr, #32]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 80045f8:	f003 0907 	and.w	r9, r3, #7
 80045fc:	ea4f 0989 	mov.w	r9, r9, lsl #2
 8004600:	f04f 0b0f 	mov.w	fp, #15
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 8004604:	fa04 f409 	lsl.w	r4, r4, r9
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8004608:	fa0b f909 	lsl.w	r9, fp, r9
 800460c:	ea2a 0909 	bic.w	r9, sl, r9
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 8004610:	ea44 0409 	orr.w	r4, r4, r9
        GPIOx->AFR[position >> 3U] = temp;
 8004614:	f8ce 4020 	str.w	r4, [lr, #32]
      temp = GPIOx->MODER;
 8004618:	f8d0 a000 	ldr.w	sl, [r0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 800461c:	ea4f 0e43 	mov.w	lr, r3, lsl #1
 8004620:	2403      	movs	r4, #3
 8004622:	fa04 f40e 	lsl.w	r4, r4, lr
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8004626:	f006 0903 	and.w	r9, r6, #3
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 800462a:	ea2a 0a04 	bic.w	sl, sl, r4
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800462e:	fa09 f90e 	lsl.w	r9, r9, lr
 8004632:	ea49 090a 	orr.w	r9, r9, sl
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8004636:	43e4      	mvns	r4, r4
      GPIOx->MODER = temp;
 8004638:	f8c0 9000 	str.w	r9, [r0]
        temp = GPIOx->OSPEEDR;
 800463c:	f8d0 a008 	ldr.w	sl, [r0, #8]
        temp |= (GPIO_Init->Speed << (position * 2U));
 8004640:	f8d1 900c 	ldr.w	r9, [r1, #12]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8004644:	ea04 0a0a 	and.w	sl, r4, sl
        temp |= (GPIO_Init->Speed << (position * 2U));
 8004648:	fa09 f90e 	lsl.w	r9, r9, lr
 800464c:	ea49 090a 	orr.w	r9, r9, sl
        GPIOx->OSPEEDR = temp;
 8004650:	f8c0 9008 	str.w	r9, [r0, #8]
        temp = GPIOx->OTYPER;
 8004654:	f8d0 9004 	ldr.w	r9, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8004658:	ea29 0902 	bic.w	r9, r9, r2
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 800465c:	f3c6 1200 	ubfx	r2, r6, #4, #1
 8004660:	409a      	lsls	r2, r3
 8004662:	ea42 0209 	orr.w	r2, r2, r9
        GPIOx->OTYPER = temp;
 8004666:	6042      	str	r2, [r0, #4]
 8004668:	e73e      	b.n	80044e8 <HAL_GPIO_Init+0x68>
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 800466a:	f04f 0e01 	mov.w	lr, #1
 800466e:	fa0e f909 	lsl.w	r9, lr, r9
 8004672:	ea44 0409 	orr.w	r4, r4, r9
 8004676:	e78d      	b.n	8004594 <HAL_GPIO_Init+0x114>
 8004678:	f04f 0e02 	mov.w	lr, #2
 800467c:	fa0e f909 	lsl.w	r9, lr, r9
 8004680:	ea44 0409 	orr.w	r4, r4, r9
 8004684:	e786      	b.n	8004594 <HAL_GPIO_Init+0x114>
 8004686:	f04f 0e03 	mov.w	lr, #3
 800468a:	fa0e f909 	lsl.w	r9, lr, r9
 800468e:	ea44 0409 	orr.w	r4, r4, r9
 8004692:	e77f      	b.n	8004594 <HAL_GPIO_Init+0x114>
 8004694:	f04f 0e04 	mov.w	lr, #4
 8004698:	fa0e f909 	lsl.w	r9, lr, r9
 800469c:	ea44 0409 	orr.w	r4, r4, r9
 80046a0:	e778      	b.n	8004594 <HAL_GPIO_Init+0x114>
 80046a2:	f04f 0e05 	mov.w	lr, #5
 80046a6:	fa0e f909 	lsl.w	r9, lr, r9
 80046aa:	ea44 0409 	orr.w	r4, r4, r9
 80046ae:	e771      	b.n	8004594 <HAL_GPIO_Init+0x114>
 80046b0:	f04f 0e06 	mov.w	lr, #6
 80046b4:	fa0e f909 	lsl.w	r9, lr, r9
 80046b8:	ea44 0409 	orr.w	r4, r4, r9
 80046bc:	e76a      	b.n	8004594 <HAL_GPIO_Init+0x114>
 80046be:	bf00      	nop
 80046c0:	40023800 	.word	0x40023800
 80046c4:	40013c00 	.word	0x40013c00
 80046c8:	40020000 	.word	0x40020000
 80046cc:	40020800 	.word	0x40020800
 80046d0:	40020c00 	.word	0x40020c00
 80046d4:	40021000 	.word	0x40021000
 80046d8:	40021400 	.word	0x40021400
 80046dc:	40021800 	.word	0x40021800
 80046e0:	40021c00 	.word	0x40021c00

080046e4 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 80046e4:	b902      	cbnz	r2, 80046e8 <HAL_GPIO_WritePin+0x4>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 80046e6:	0409      	lsls	r1, r1, #16
 80046e8:	6181      	str	r1, [r0, #24]
  }
}
 80046ea:	4770      	bx	lr

080046ec <HAL_UART_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
  /* Check the UART handle allocation */
  if(huart == NULL)
 80046ec:	2800      	cmp	r0, #0
 80046ee:	d075      	beq.n	80047dc <HAL_UART_Init+0xf0>
{
 80046f0:	b430      	push	{r4, r5}
    assert_param(IS_UART_INSTANCE(huart->Instance));
  }
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));

  if(huart->gState == HAL_UART_STATE_RESET)
 80046f2:	f890 2039 	ldrb.w	r2, [r0, #57]	; 0x39
 80046f6:	4603      	mov	r3, r0
 80046f8:	f002 01ff 	and.w	r1, r2, #255	; 0xff
 80046fc:	2a00      	cmp	r2, #0
 80046fe:	d050      	beq.n	80047a2 <HAL_UART_Init+0xb6>
  }

  huart->gState = HAL_UART_STATE_BUSY;

  /* Disable the peripheral */
  __HAL_UART_DISABLE(huart);
 8004700:	681a      	ldr	r2, [r3, #0]
  tmpreg |= (uint32_t)huart->Init.StopBits;
 8004702:	68dc      	ldr	r4, [r3, #12]
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8004704:	691d      	ldr	r5, [r3, #16]
  huart->gState = HAL_UART_STATE_BUSY;
 8004706:	2124      	movs	r1, #36	; 0x24
 8004708:	f883 1039 	strb.w	r1, [r3, #57]	; 0x39
  __HAL_UART_DISABLE(huart);
 800470c:	68d1      	ldr	r1, [r2, #12]
 800470e:	f421 5100 	bic.w	r1, r1, #8192	; 0x2000
 8004712:	60d1      	str	r1, [r2, #12]
  tmpreg = huart->Instance->CR2;
 8004714:	6910      	ldr	r0, [r2, #16]
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8004716:	6899      	ldr	r1, [r3, #8]
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 8004718:	f420 5040 	bic.w	r0, r0, #12288	; 0x3000
  tmpreg |= (uint32_t)huart->Init.StopBits;
 800471c:	4320      	orrs	r0, r4
  WRITE_REG(huart->Instance->CR2, (uint32_t)tmpreg);
 800471e:	6110      	str	r0, [r2, #16]
  tmpreg = huart->Instance->CR1;
 8004720:	68d0      	ldr	r0, [r2, #12]
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8004722:	69dc      	ldr	r4, [r3, #28]
 8004724:	4329      	orrs	r1, r5
 8004726:	695d      	ldr	r5, [r3, #20]
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | \
 8004728:	f420 4016 	bic.w	r0, r0, #38400	; 0x9600
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 800472c:	4329      	orrs	r1, r5
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | \
 800472e:	f020 000c 	bic.w	r0, r0, #12
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8004732:	4321      	orrs	r1, r4
 8004734:	4301      	orrs	r1, r0
  WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
 8004736:	60d1      	str	r1, [r2, #12]
  tmpreg = huart->Instance->CR3;
 8004738:	6951      	ldr	r1, [r2, #20]
  tmpreg |= huart->Init.HwFlowCtl;
 800473a:	6998      	ldr	r0, [r3, #24]
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE));
 800473c:	f421 7140 	bic.w	r1, r1, #768	; 0x300
  tmpreg |= huart->Init.HwFlowCtl;
 8004740:	4301      	orrs	r1, r0
  if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8004742:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
  WRITE_REG(huart->Instance->CR3, (uint32_t)tmpreg);
 8004746:	6151      	str	r1, [r2, #20]
  if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8004748:	d02e      	beq.n	80047a8 <HAL_UART_Init+0xbc>
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 800474a:	6858      	ldr	r0, [r3, #4]
 800474c:	4c24      	ldr	r4, [pc, #144]	; (80047e0 <HAL_UART_Init+0xf4>)
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 800474e:	4925      	ldr	r1, [pc, #148]	; (80047e4 <HAL_UART_Init+0xf8>)
 8004750:	0080      	lsls	r0, r0, #2
 8004752:	fbb1 f1f0 	udiv	r1, r1, r0
 8004756:	fba4 5001 	umull	r5, r0, r4, r1
 800475a:	0940      	lsrs	r0, r0, #5
 800475c:	f04f 0c64 	mov.w	ip, #100	; 0x64
 8004760:	fb0c 1110 	mls	r1, ip, r0, r1
 8004764:	0109      	lsls	r1, r1, #4
 8004766:	3132      	adds	r1, #50	; 0x32
 8004768:	fba4 4101 	umull	r4, r1, r4, r1
 800476c:	0100      	lsls	r0, r0, #4
 800476e:	eb00 1151 	add.w	r1, r0, r1, lsr #5
 8004772:	6091      	str	r1, [r2, #8]
  UART_SetConfig(huart);

  /* In asynchronous mode, the following bits must be kept cleared:
     - LINEN and CLKEN bits in the USART_CR2 register,
     - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8004774:	6911      	ldr	r1, [r2, #16]
 8004776:	f421 4190 	bic.w	r1, r1, #18432	; 0x4800
 800477a:	6111      	str	r1, [r2, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 800477c:	6951      	ldr	r1, [r2, #20]
 800477e:	f021 012a 	bic.w	r1, r1, #42	; 0x2a
 8004782:	6151      	str	r1, [r2, #20]

  /* Enable the peripheral */
  __HAL_UART_ENABLE(huart);
 8004784:	68d1      	ldr	r1, [r2, #12]

  /* Initialize the UART state */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8004786:	2400      	movs	r4, #0
  huart->gState= HAL_UART_STATE_READY;
 8004788:	f04f 0c20 	mov.w	ip, #32
  __HAL_UART_ENABLE(huart);
 800478c:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
 8004790:	60d1      	str	r1, [r2, #12]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8004792:	63dc      	str	r4, [r3, #60]	; 0x3c
  huart->gState= HAL_UART_STATE_READY;
 8004794:	f883 c039 	strb.w	ip, [r3, #57]	; 0x39
  huart->RxState= HAL_UART_STATE_READY;
 8004798:	f883 c03a 	strb.w	ip, [r3, #58]	; 0x3a

  return HAL_OK;
 800479c:	4620      	mov	r0, r4
}
 800479e:	bc30      	pop	{r4, r5}
 80047a0:	4770      	bx	lr
    huart->Lock = HAL_UNLOCKED;
 80047a2:	f880 1038 	strb.w	r1, [r0, #56]	; 0x38
 80047a6:	e7ab      	b.n	8004700 <HAL_UART_Init+0x14>
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 80047a8:	685c      	ldr	r4, [r3, #4]
 80047aa:	4d0d      	ldr	r5, [pc, #52]	; (80047e0 <HAL_UART_Init+0xf4>)
 80047ac:	480d      	ldr	r0, [pc, #52]	; (80047e4 <HAL_UART_Init+0xf8>)
 80047ae:	0064      	lsls	r4, r4, #1
 80047b0:	fbb0 f0f4 	udiv	r0, r0, r4
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 80047b4:	fba5 1400 	umull	r1, r4, r5, r0
 80047b8:	0964      	lsrs	r4, r4, #5
 80047ba:	2164      	movs	r1, #100	; 0x64
 80047bc:	fb01 0114 	mls	r1, r1, r4, r0
 80047c0:	00c9      	lsls	r1, r1, #3
 80047c2:	3132      	adds	r1, #50	; 0x32
 80047c4:	fba5 0101 	umull	r0, r1, r5, r1
 80047c8:	f3c1 1042 	ubfx	r0, r1, #5, #3
 80047cc:	0909      	lsrs	r1, r1, #4
 80047ce:	eb00 1004 	add.w	r0, r0, r4, lsl #4
 80047d2:	f401 71f8 	and.w	r1, r1, #496	; 0x1f0
 80047d6:	4401      	add	r1, r0
 80047d8:	6091      	str	r1, [r2, #8]
 80047da:	e7cb      	b.n	8004774 <HAL_UART_Init+0x88>
    return HAL_ERROR;
 80047dc:	2001      	movs	r0, #1
}
 80047de:	4770      	bx	lr
 80047e0:	51eb851f 	.word	0x51eb851f
 80047e4:	0afb6e90 	.word	0x0afb6e90

080047e8 <HAL_UART_Transmit>:
{
  uint16_t* tmp;
  //uint32_t tickstart = 0U;

  /* Check that a Tx process is not already ongoing */
  if(huart->gState == HAL_UART_STATE_READY)
 80047e8:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 80047ec:	2b20      	cmp	r3, #32
 80047ee:	d142      	bne.n	8004876 <HAL_UART_Transmit+0x8e>
  {
    if((pData == NULL ) || (Size == 0))
 80047f0:	2900      	cmp	r1, #0
 80047f2:	d03e      	beq.n	8004872 <HAL_UART_Transmit+0x8a>
 80047f4:	2a00      	cmp	r2, #0
 80047f6:	d03c      	beq.n	8004872 <HAL_UART_Transmit+0x8a>
    {
      return  HAL_ERROR;
    }

    /* Process Locked */
    __HAL_LOCK(huart);
 80047f8:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 80047fc:	2b01      	cmp	r3, #1
 80047fe:	d03a      	beq.n	8004876 <HAL_UART_Transmit+0x8e>
{
 8004800:	b410      	push	{r4}

    huart->ErrorCode = HAL_UART_ERROR_NONE;
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8004802:	2321      	movs	r3, #33	; 0x21
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8004804:	2400      	movs	r4, #0
 8004806:	63c4      	str	r4, [r0, #60]	; 0x3c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8004808:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39

    /* Init tickstart for timeout managment */
    //tickstart = HAL_GetTick();

    huart->TxXferSize = Size;
    huart->TxXferCount = Size;
 800480c:	84c2      	strh	r2, [r0, #38]	; 0x26
    while(huart->TxXferCount > 0U)
 800480e:	8cc3      	ldrh	r3, [r0, #38]	; 0x26
    huart->TxXferSize = Size;
 8004810:	8482      	strh	r2, [r0, #36]	; 0x24
    __HAL_LOCK(huart);
 8004812:	2401      	movs	r4, #1
    while(huart->TxXferCount > 0U)
 8004814:	b29b      	uxth	r3, r3
    __HAL_LOCK(huart);
 8004816:	f880 4038 	strb.w	r4, [r0, #56]	; 0x38
    while(huart->TxXferCount > 0U)
 800481a:	2b00      	cmp	r3, #0
 800481c:	d02f      	beq.n	800487e <HAL_UART_Transmit+0x96>
    {
      huart->TxXferCount--;
      if(huart->Init.WordLength == UART_WORDLENGTH_9B)
 800481e:	6884      	ldr	r4, [r0, #8]
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status);
 8004820:	6802      	ldr	r2, [r0, #0]
      huart->TxXferCount--;
 8004822:	8cc3      	ldrh	r3, [r0, #38]	; 0x26
 8004824:	3b01      	subs	r3, #1
 8004826:	b29b      	uxth	r3, r3
      if(huart->Init.WordLength == UART_WORDLENGTH_9B)
 8004828:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
      huart->TxXferCount--;
 800482c:	84c3      	strh	r3, [r0, #38]	; 0x26
      if(huart->Init.WordLength == UART_WORDLENGTH_9B)
 800482e:	d015      	beq.n	800485c <HAL_UART_Transmit+0x74>
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status);
 8004830:	6813      	ldr	r3, [r2, #0]
 8004832:	061b      	lsls	r3, r3, #24
 8004834:	d5fc      	bpl.n	8004830 <HAL_UART_Transmit+0x48>
      {
        if(UART_WaitOnFlagForever(huart, UART_FLAG_TXE, RESET) != HAL_OK)
        {
          return HAL_TIMEOUT;
        }
        huart->Instance->DR = (*pData++ & (uint8_t)0xFF);
 8004836:	f811 3b01 	ldrb.w	r3, [r1], #1
 800483a:	6053      	str	r3, [r2, #4]
    while(huart->TxXferCount > 0U)
 800483c:	8cc3      	ldrh	r3, [r0, #38]	; 0x26
 800483e:	b29b      	uxth	r3, r3
 8004840:	2b00      	cmp	r3, #0
 8004842:	d1ee      	bne.n	8004822 <HAL_UART_Transmit+0x3a>
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status);
 8004844:	6813      	ldr	r3, [r2, #0]
 8004846:	065b      	lsls	r3, r3, #25
 8004848:	d5fc      	bpl.n	8004844 <HAL_UART_Transmit+0x5c>

    /* At end of Tx process, restore huart->gState to Ready */
      huart->gState = HAL_UART_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(huart);
 800484a:	2300      	movs	r3, #0
      huart->gState = HAL_UART_STATE_READY;
 800484c:	2220      	movs	r2, #32
 800484e:	f880 2039 	strb.w	r2, [r0, #57]	; 0x39
    __HAL_UNLOCK(huart);
 8004852:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
  }
  else
  {
    return HAL_BUSY;
  }
}
 8004856:	bc10      	pop	{r4}
    return HAL_OK;
 8004858:	4618      	mov	r0, r3
}
 800485a:	4770      	bx	lr
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status);
 800485c:	6813      	ldr	r3, [r2, #0]
 800485e:	061b      	lsls	r3, r3, #24
 8004860:	d5fc      	bpl.n	800485c <HAL_UART_Transmit+0x74>
        huart->Instance->DR = (*tmp & (uint16_t)0x01FF);
 8004862:	880b      	ldrh	r3, [r1, #0]
 8004864:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8004868:	6053      	str	r3, [r2, #4]
        if(huart->Init.Parity == UART_PARITY_NONE)
 800486a:	6903      	ldr	r3, [r0, #16]
 800486c:	b92b      	cbnz	r3, 800487a <HAL_UART_Transmit+0x92>
          pData +=2U;
 800486e:	3102      	adds	r1, #2
 8004870:	e7e4      	b.n	800483c <HAL_UART_Transmit+0x54>
      return  HAL_ERROR;
 8004872:	2001      	movs	r0, #1
 8004874:	4770      	bx	lr
    return HAL_BUSY;
 8004876:	2002      	movs	r0, #2
}
 8004878:	4770      	bx	lr
          pData +=1U;
 800487a:	3101      	adds	r1, #1
 800487c:	e7de      	b.n	800483c <HAL_UART_Transmit+0x54>
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status);
 800487e:	6802      	ldr	r2, [r0, #0]
 8004880:	e7e0      	b.n	8004844 <HAL_UART_Transmit+0x5c>
 8004882:	bf00      	nop

08004884 <HAL_UART_Receive>:
{
  uint16_t* tmp;
  //uint32_t tickstart = 0U;

  /* Check that a Rx process is not already ongoing */
  if(huart->RxState == HAL_UART_STATE_READY)
 8004884:	f890 303a 	ldrb.w	r3, [r0, #58]	; 0x3a
 8004888:	2b20      	cmp	r3, #32
 800488a:	d15c      	bne.n	8004946 <HAL_UART_Receive+0xc2>
  {
    if((pData == NULL ) || (Size == 0))
 800488c:	2900      	cmp	r1, #0
 800488e:	d052      	beq.n	8004936 <HAL_UART_Receive+0xb2>
 8004890:	2a00      	cmp	r2, #0
 8004892:	d050      	beq.n	8004936 <HAL_UART_Receive+0xb2>
    {
      return  HAL_ERROR;
    }

    /* Process Locked */
    __HAL_LOCK(huart);
 8004894:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 8004898:	2b01      	cmp	r3, #1
 800489a:	d054      	beq.n	8004946 <HAL_UART_Receive+0xc2>
{
 800489c:	b410      	push	{r4}

    huart->ErrorCode = HAL_UART_ERROR_NONE;
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 800489e:	2322      	movs	r3, #34	; 0x22
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 80048a0:	2400      	movs	r4, #0
 80048a2:	63c4      	str	r4, [r0, #60]	; 0x3c
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 80048a4:	f880 303a 	strb.w	r3, [r0, #58]	; 0x3a

    /* Init tickstart for timeout managment */
    //tickstart = HAL_GetTick();

    huart->RxXferSize = Size;
    huart->RxXferCount = Size;
 80048a8:	85c2      	strh	r2, [r0, #46]	; 0x2e

    /* Check the remain data to be received */
    while(huart->RxXferCount > 0U)
 80048aa:	8dc3      	ldrh	r3, [r0, #46]	; 0x2e
    huart->RxXferSize = Size;
 80048ac:	8582      	strh	r2, [r0, #44]	; 0x2c
    __HAL_LOCK(huart);
 80048ae:	2401      	movs	r4, #1
    while(huart->RxXferCount > 0U)
 80048b0:	b29b      	uxth	r3, r3
    __HAL_LOCK(huart);
 80048b2:	f880 4038 	strb.w	r4, [r0, #56]	; 0x38
    while(huart->RxXferCount > 0U)
 80048b6:	b1ab      	cbz	r3, 80048e4 <HAL_UART_Receive+0x60>
    {
      huart->RxXferCount--;
 80048b8:	8dc3      	ldrh	r3, [r0, #46]	; 0x2e
      if(huart->Init.WordLength == UART_WORDLENGTH_9B)
 80048ba:	6882      	ldr	r2, [r0, #8]
      huart->RxXferCount--;
 80048bc:	3b01      	subs	r3, #1
 80048be:	b29b      	uxth	r3, r3
      if(huart->Init.WordLength == UART_WORDLENGTH_9B)
 80048c0:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
      huart->RxXferCount--;
 80048c4:	85c3      	strh	r3, [r0, #46]	; 0x2e
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status);
 80048c6:	6802      	ldr	r2, [r0, #0]
      if(huart->Init.WordLength == UART_WORDLENGTH_9B)
 80048c8:	d015      	beq.n	80048f6 <HAL_UART_Receive+0x72>
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status);
 80048ca:	6813      	ldr	r3, [r2, #0]
 80048cc:	069c      	lsls	r4, r3, #26
 80048ce:	d5fc      	bpl.n	80048ca <HAL_UART_Receive+0x46>
      {
        if(UART_WaitOnFlagForever(huart, UART_FLAG_RXNE, RESET) != HAL_OK)
        {
          return HAL_TIMEOUT;
        }
        if(huart->Init.Parity == UART_PARITY_NONE)
 80048d0:	6903      	ldr	r3, [r0, #16]
 80048d2:	2b00      	cmp	r3, #0
 80048d4:	d131      	bne.n	800493a <HAL_UART_Receive+0xb6>
        {
          *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
 80048d6:	6853      	ldr	r3, [r2, #4]
 80048d8:	f801 3b01 	strb.w	r3, [r1], #1
    while(huart->RxXferCount > 0U)
 80048dc:	8dc3      	ldrh	r3, [r0, #46]	; 0x2e
 80048de:	b29b      	uxth	r3, r3
 80048e0:	2b00      	cmp	r3, #0
 80048e2:	d1e9      	bne.n	80048b8 <HAL_UART_Receive+0x34>

    /* At end of Rx process, restore huart->RxState to Ready */
    huart->RxState = HAL_UART_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(huart);
 80048e4:	2300      	movs	r3, #0
    huart->RxState = HAL_UART_STATE_READY;
 80048e6:	2220      	movs	r2, #32
 80048e8:	f880 203a 	strb.w	r2, [r0, #58]	; 0x3a
    __HAL_UNLOCK(huart);
 80048ec:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
  }
  else
  {
    return HAL_BUSY;
  }
}
 80048f0:	bc10      	pop	{r4}
    return HAL_OK;
 80048f2:	4618      	mov	r0, r3
}
 80048f4:	4770      	bx	lr
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status);
 80048f6:	6813      	ldr	r3, [r2, #0]
 80048f8:	069b      	lsls	r3, r3, #26
 80048fa:	d5fc      	bpl.n	80048f6 <HAL_UART_Receive+0x72>
        if(huart->Init.Parity == UART_PARITY_NONE)
 80048fc:	6904      	ldr	r4, [r0, #16]
          *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
 80048fe:	6853      	ldr	r3, [r2, #4]
        if(huart->Init.Parity == UART_PARITY_NONE)
 8004900:	bb1c      	cbnz	r4, 800494a <HAL_UART_Receive+0xc6>
          *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
 8004902:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8004906:	f821 3b02 	strh.w	r3, [r1], #2
    while(huart->RxXferCount > 0U)
 800490a:	8dc3      	ldrh	r3, [r0, #46]	; 0x2e
 800490c:	b29b      	uxth	r3, r3
 800490e:	2b00      	cmp	r3, #0
 8004910:	d0e8      	beq.n	80048e4 <HAL_UART_Receive+0x60>
      huart->RxXferCount--;
 8004912:	8dc3      	ldrh	r3, [r0, #46]	; 0x2e
 8004914:	3b01      	subs	r3, #1
 8004916:	b29b      	uxth	r3, r3
 8004918:	85c3      	strh	r3, [r0, #46]	; 0x2e
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status);
 800491a:	6813      	ldr	r3, [r2, #0]
 800491c:	069b      	lsls	r3, r3, #26
 800491e:	d5fc      	bpl.n	800491a <HAL_UART_Receive+0x96>
          *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
 8004920:	6853      	ldr	r3, [r2, #4]
        if(huart->Init.Parity == UART_PARITY_NONE)
 8004922:	b994      	cbnz	r4, 800494a <HAL_UART_Receive+0xc6>
          *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
 8004924:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8004928:	f821 3b02 	strh.w	r3, [r1], #2
    while(huart->RxXferCount > 0U)
 800492c:	8dc3      	ldrh	r3, [r0, #46]	; 0x2e
 800492e:	b29b      	uxth	r3, r3
 8004930:	2b00      	cmp	r3, #0
 8004932:	d1ee      	bne.n	8004912 <HAL_UART_Receive+0x8e>
 8004934:	e7d6      	b.n	80048e4 <HAL_UART_Receive+0x60>
      return  HAL_ERROR;
 8004936:	2001      	movs	r0, #1
 8004938:	4770      	bx	lr
          *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
 800493a:	6853      	ldr	r3, [r2, #4]
 800493c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8004940:	f801 3b01 	strb.w	r3, [r1], #1
 8004944:	e7ca      	b.n	80048dc <HAL_UART_Receive+0x58>
    return HAL_BUSY;
 8004946:	2002      	movs	r0, #2
}
 8004948:	4770      	bx	lr
          *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
 800494a:	b2db      	uxtb	r3, r3
 800494c:	f821 3b01 	strh.w	r3, [r1], #1
 8004950:	e7db      	b.n	800490a <HAL_UART_Receive+0x86>
 8004952:	bf00      	nop

08004954 <_sbrk>:
{
	extern char end asm("end");
	static char *heap_end;
	char *prev_heap_end;

	if (heap_end == 0)
 8004954:	4a0b      	ldr	r2, [pc, #44]	; (8004984 <_sbrk+0x30>)
{
 8004956:	b508      	push	{r3, lr}
 8004958:	4603      	mov	r3, r0
	if (heap_end == 0)
 800495a:	6810      	ldr	r0, [r2, #0]
 800495c:	b128      	cbz	r0, 800496a <_sbrk+0x16>
		heap_end = &end;

	prev_heap_end = heap_end;
	if (heap_end + incr > stack_ptr)
 800495e:	4403      	add	r3, r0
 8004960:	4669      	mov	r1, sp
 8004962:	428b      	cmp	r3, r1
 8004964:	d807      	bhi.n	8004976 <_sbrk+0x22>
	{
		errno = ENOMEM;
		return (char *) -1;
	}

	heap_end += incr;
 8004966:	6013      	str	r3, [r2, #0]

	return (char *) prev_heap_end;
}
 8004968:	bd08      	pop	{r3, pc}
		heap_end = &end;
 800496a:	4807      	ldr	r0, [pc, #28]	; (8004988 <_sbrk+0x34>)
 800496c:	6010      	str	r0, [r2, #0]
	if (heap_end + incr > stack_ptr)
 800496e:	4403      	add	r3, r0
 8004970:	4669      	mov	r1, sp
 8004972:	428b      	cmp	r3, r1
 8004974:	d9f7      	bls.n	8004966 <_sbrk+0x12>
		errno = ENOMEM;
 8004976:	f7fb fc51 	bl	800021c <__errno>
 800497a:	230c      	movs	r3, #12
 800497c:	6003      	str	r3, [r0, #0]
		return (char *) -1;
 800497e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 8004982:	bd08      	pop	{r3, pc}
 8004984:	200018e0 	.word	0x200018e0
 8004988:	20001920 	.word	0x20001920

0800498c <HAL_RNG_MspInit>:
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hrng);
  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_RNG_MspInit must be implemented in the user file.
   */
}
 800498c:	4770      	bx	lr
 800498e:	bf00      	nop

08004990 <HAL_RNG_Init>:
  if(hrng == NULL)
 8004990:	b1c0      	cbz	r0, 80049c4 <HAL_RNG_Init+0x34>
{ 
 8004992:	b510      	push	{r4, lr}
  __HAL_LOCK(hrng);
 8004994:	7903      	ldrb	r3, [r0, #4]
 8004996:	2b01      	cmp	r3, #1
 8004998:	4604      	mov	r4, r0
 800499a:	d015      	beq.n	80049c8 <HAL_RNG_Init+0x38>
  if(hrng->State == HAL_RNG_STATE_RESET)
 800499c:	7943      	ldrb	r3, [r0, #5]
 800499e:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80049a2:	b15b      	cbz	r3, 80049bc <HAL_RNG_Init+0x2c>
  __HAL_RNG_ENABLE(hrng);
 80049a4:	6822      	ldr	r2, [r4, #0]
  hrng->State = HAL_RNG_STATE_BUSY;
 80049a6:	2302      	movs	r3, #2
 80049a8:	7163      	strb	r3, [r4, #5]
  __HAL_RNG_ENABLE(hrng);
 80049aa:	6813      	ldr	r3, [r2, #0]
  __HAL_UNLOCK(hrng);
 80049ac:	2000      	movs	r0, #0
  __HAL_RNG_ENABLE(hrng);
 80049ae:	f043 0304 	orr.w	r3, r3, #4
  hrng->State = HAL_RNG_STATE_READY;
 80049b2:	2101      	movs	r1, #1
  __HAL_RNG_ENABLE(hrng);
 80049b4:	6013      	str	r3, [r2, #0]
  hrng->State = HAL_RNG_STATE_READY;
 80049b6:	7161      	strb	r1, [r4, #5]
  __HAL_UNLOCK(hrng);
 80049b8:	7120      	strb	r0, [r4, #4]
}
 80049ba:	bd10      	pop	{r4, pc}
    hrng->Lock = HAL_UNLOCKED;
 80049bc:	7102      	strb	r2, [r0, #4]
    HAL_RNG_MspInit(hrng);
 80049be:	f7ff ffe5 	bl	800498c <HAL_RNG_MspInit>
 80049c2:	e7ef      	b.n	80049a4 <HAL_RNG_Init+0x14>
    return HAL_ERROR;
 80049c4:	2001      	movs	r0, #1
}
 80049c6:	4770      	bx	lr
  __HAL_LOCK(hrng);
 80049c8:	2002      	movs	r0, #2
}
 80049ca:	bd10      	pop	{r4, pc}

080049cc <Reset_Handler>:
 80049cc:	2100      	movs	r1, #0
 80049ce:	e003      	b.n	80049d8 <LoopCopyDataInit>

080049d0 <CopyDataInit>:
 80049d0:	4b0b      	ldr	r3, [pc, #44]	; (8004a00 <LoopForever+0x2>)
 80049d2:	585b      	ldr	r3, [r3, r1]
 80049d4:	5043      	str	r3, [r0, r1]
 80049d6:	3104      	adds	r1, #4

080049d8 <LoopCopyDataInit>:
 80049d8:	480a      	ldr	r0, [pc, #40]	; (8004a04 <LoopForever+0x6>)
 80049da:	4b0b      	ldr	r3, [pc, #44]	; (8004a08 <LoopForever+0xa>)
 80049dc:	1842      	adds	r2, r0, r1
 80049de:	429a      	cmp	r2, r3
 80049e0:	d3f6      	bcc.n	80049d0 <CopyDataInit>
 80049e2:	4a0a      	ldr	r2, [pc, #40]	; (8004a0c <LoopForever+0xe>)
 80049e4:	e002      	b.n	80049ec <LoopFillZerobss>

080049e6 <FillZerobss>:
 80049e6:	2300      	movs	r3, #0
 80049e8:	6013      	str	r3, [r2, #0]
 80049ea:	3204      	adds	r2, #4

080049ec <LoopFillZerobss>:
 80049ec:	4b08      	ldr	r3, [pc, #32]	; (8004a10 <LoopForever+0x12>)
 80049ee:	429a      	cmp	r2, r3
 80049f0:	d3f9      	bcc.n	80049e6 <FillZerobss>
 80049f2:	f3af 8000 	nop.w
 80049f6:	f7fb fc3d 	bl	8000274 <__libc_init_array>
 80049fa:	f7fc fb33 	bl	8001064 <main>

080049fe <LoopForever>:
 80049fe:	e7fe      	b.n	80049fe <LoopForever>
 8004a00:	08004f18 	.word	0x08004f18
 8004a04:	20000000 	.word	0x20000000
 8004a08:	20000840 	.word	0x20000840
 8004a0c:	20000840 	.word	0x20000840
 8004a10:	2000191c 	.word	0x2000191c

08004a14 <BusFault_Handler>:
 8004a14:	e7fe      	b.n	8004a14 <BusFault_Handler>
 8004a16:	0000      	movs	r0, r0

08004a18 <register_fini>:
 8004a18:	4b02      	ldr	r3, [pc, #8]	; (8004a24 <register_fini+0xc>)
 8004a1a:	b113      	cbz	r3, 8004a22 <register_fini+0xa>
 8004a1c:	4802      	ldr	r0, [pc, #8]	; (8004a28 <register_fini+0x10>)
 8004a1e:	f7fb bbf7 	b.w	8000210 <atexit>
 8004a22:	4770      	bx	lr
 8004a24:	00000000 	.word	0x00000000
 8004a28:	08000249 	.word	0x08000249

08004a2c <_init>:
 8004a2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004a2e:	bf00      	nop
 8004a30:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8004a32:	bc08      	pop	{r3}
 8004a34:	469e      	mov	lr, r3
 8004a36:	4770      	bx	lr

08004a38 <_fini>:
 8004a38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004a3a:	bf00      	nop
 8004a3c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8004a3e:	bc08      	pop	{r3}
 8004a40:	469e      	mov	lr, r3
 8004a42:	4770      	bx	lr
